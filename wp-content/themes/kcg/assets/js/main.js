/*! For license information please see main.js.LICENSE.txt */ ! function (e, t) {
    if ("object" == typeof exports && "object" == typeof module) module.exports = t();
    else if ("function" == typeof define && define.amd) define([], t);
    else {
        var n = t();
        for (var i in n) ("object" == typeof exports ? exports : e)[i] = n[i]
    }
}(window, (function () {
    return function (e) {
        var t = {};

        function n(i) {
            if (t[i]) return t[i].exports;
            var r = t[i] = {
                i: i,
                l: !1,
                exports: {}
            };
            return e[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports
        }
        return n.m = e, n.c = t, n.d = function (e, t, i) {
            n.o(e, t) || Object.defineProperty(e, t, {
                enumerable: !0,
                get: i
            })
        }, n.r = function (e) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }, n.t = function (e, t) {
            if (1 & t && (e = n(e)), 8 & t) return e;
            if (4 & t && "object" == typeof e && e && e.__esModule) return e;
            var i = Object.create(null);
            if (n.r(i), Object.defineProperty(i, "default", {
                enumerable: !0,
                value: e
            }), 2 & t && "string" != typeof e)
                for (var r in e) n.d(i, r, function (t) {
                    return e[t]
                }.bind(null, r));
            return i
        }, n.n = function (e) {
            var t = e && e.__esModule ? function () {
                return e.default
            } : function () {
                return e
            };
            return n.d(t, "a", t), t
        }, n.o = function (e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }, n.p = "", n(n.s = 6)
    }([function (e, t, n) {
        var i;
        ! function (t, n) {
            "use strict";
            "object" == typeof e.exports ? e.exports = t.document ? n(t, !0) : function (e) {
                if (!e.document) throw new Error("jQuery requires a window with a document");
                return n(e)
            } : n(t)
        }("undefined" != typeof window ? window : this, (function (n, r) {
            "use strict";
            var o = [],
                a = Object.getPrototypeOf,
                s = o.slice,
                l = o.flat ? function (e) {
                    return o.flat.call(e)
                } : function (e) {
                    return o.concat.apply([], e)
                },
                c = o.push,
                u = o.indexOf,
                h = {},
                d = h.toString,
                p = h.hasOwnProperty,
                f = p.toString,
                m = f.call(Object),
                g = {},
                v = function (e) {
                    return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item
                },
                y = function (e) {
                    return null != e && e === e.window
                },
                x = n.document,
                w = {
                    type: !0,
                    src: !0,
                    nonce: !0,
                    noModule: !0
                };

            function b(e, t, n) {
                var i, r, o = (n = n || x).createElement("script");
                if (o.text = e, t)
                    for (i in w) (r = t[i] || t.getAttribute && t.getAttribute(i)) && o.setAttribute(i, r);
                n.head.appendChild(o).parentNode.removeChild(o)
            }

            function _(e) {
                return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? h[d.call(e)] || "object" : typeof e
            }
            var M = "3.6.0",
                T = function (e, t) {
                    return new T.fn.init(e, t)
                };

            function S(e) {
                var t = !!e && "length" in e && e.length,
                    n = _(e);
                return !v(e) && !y(e) && ("array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e)
            }
            T.fn = T.prototype = {
                jquery: M,
                constructor: T,
                length: 0,
                toArray: function () {
                    return s.call(this)
                },
                get: function (e) {
                    return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e]
                },
                pushStack: function (e) {
                    var t = T.merge(this.constructor(), e);
                    return t.prevObject = this, t
                },
                each: function (e) {
                    return T.each(this, e)
                },
                map: function (e) {
                    return this.pushStack(T.map(this, (function (t, n) {
                        return e.call(t, n, t)
                    })))
                },
                slice: function () {
                    return this.pushStack(s.apply(this, arguments))
                },
                first: function () {
                    return this.eq(0)
                },
                last: function () {
                    return this.eq(-1)
                },
                even: function () {
                    return this.pushStack(T.grep(this, (function (e, t) {
                        return (t + 1) % 2
                    })))
                },
                odd: function () {
                    return this.pushStack(T.grep(this, (function (e, t) {
                        return t % 2
                    })))
                },
                eq: function (e) {
                    var t = this.length,
                        n = +e + (e < 0 ? t : 0);
                    return this.pushStack(n >= 0 && n < t ? [this[n]] : [])
                },
                end: function () {
                    return this.prevObject || this.constructor()
                },
                push: c,
                sort: o.sort,
                splice: o.splice
            }, T.extend = T.fn.extend = function () {
                var e, t, n, i, r, o, a = arguments[0] || {},
                    s = 1,
                    l = arguments.length,
                    c = !1;
                for ("boolean" == typeof a && (c = a, a = arguments[s] || {}, s++), "object" == typeof a || v(a) || (a = {}), s === l && (a = this, s--); s < l; s++)
                    if (null != (e = arguments[s]))
                        for (t in e) i = e[t], "__proto__" !== t && a !== i && (c && i && (T.isPlainObject(i) || (r = Array.isArray(i))) ? (n = a[t], o = r && !Array.isArray(n) ? [] : r || T.isPlainObject(n) ? n : {}, r = !1, a[t] = T.extend(c, o, i)) : void 0 !== i && (a[t] = i));
                return a
            }, T.extend({
                expando: "jQuery" + (M + Math.random()).replace(/\D/g, ""),
                isReady: !0,
                error: function (e) {
                    throw new Error(e)
                },
                noop: function () { },
                isPlainObject: function (e) {
                    var t, n;
                    return !(!e || "[object Object]" !== d.call(e)) && (!(t = a(e)) || "function" == typeof (n = p.call(t, "constructor") && t.constructor) && f.call(n) === m)
                },
                isEmptyObject: function (e) {
                    var t;
                    for (t in e) return !1;
                    return !0
                },
                globalEval: function (e, t, n) {
                    b(e, {
                        nonce: t && t.nonce
                    }, n)
                },
                each: function (e, t) {
                    var n, i = 0;
                    if (S(e))
                        for (n = e.length; i < n && !1 !== t.call(e[i], i, e[i]); i++);
                    else
                        for (i in e)
                            if (!1 === t.call(e[i], i, e[i])) break;
                    return e
                },
                makeArray: function (e, t) {
                    var n = t || [];
                    return null != e && (S(Object(e)) ? T.merge(n, "string" == typeof e ? [e] : e) : c.call(n, e)), n
                },
                inArray: function (e, t, n) {
                    return null == t ? -1 : u.call(t, e, n)
                },
                merge: function (e, t) {
                    for (var n = +t.length, i = 0, r = e.length; i < n; i++) e[r++] = t[i];
                    return e.length = r, e
                },
                grep: function (e, t, n) {
                    for (var i = [], r = 0, o = e.length, a = !n; r < o; r++) !t(e[r], r) !== a && i.push(e[r]);
                    return i
                },
                map: function (e, t, n) {
                    var i, r, o = 0,
                        a = [];
                    if (S(e))
                        for (i = e.length; o < i; o++) null != (r = t(e[o], o, n)) && a.push(r);
                    else
                        for (o in e) null != (r = t(e[o], o, n)) && a.push(r);
                    return l(a)
                },
                guid: 1,
                support: g
            }), "function" == typeof Symbol && (T.fn[Symbol.iterator] = o[Symbol.iterator]), T.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function (e, t) {
                h["[object " + t + "]"] = t.toLowerCase()
            }));
            var E = function (e) {
                var t, n, i, r, o, a, s, l, c, u, h, d, p, f, m, g, v, y, x, w = "sizzle" + 1 * new Date,
                    b = e.document,
                    _ = 0,
                    M = 0,
                    T = le(),
                    S = le(),
                    E = le(),
                    A = le(),
                    C = function (e, t) {
                        return e === t && (h = !0), 0
                    },
                    L = {}.hasOwnProperty,
                    P = [],
                    R = P.pop,
                    O = P.push,
                    D = P.push,
                    k = P.slice,
                    N = function (e, t) {
                        for (var n = 0, i = e.length; n < i; n++)
                            if (e[n] === t) return n;
                        return -1
                    },
                    I = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                    z = "[\\x20\\t\\r\\n\\f]",
                    F = "(?:\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
                    H = "\\[[\\x20\\t\\r\\n\\f]*(" + F + ")(?:" + z + "*([*^$|!~]?=)" + z + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + F + "))|)" + z + "*\\]",
                    B = ":(" + F + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + H + ")*)|.*)\\)|)",
                    U = new RegExp(z + "+", "g"),
                    j = new RegExp("^[\\x20\\t\\r\\n\\f]+|((?:^|[^\\\\])(?:\\\\.)*)[\\x20\\t\\r\\n\\f]+$", "g"),
                    G = new RegExp("^[\\x20\\t\\r\\n\\f]*,[\\x20\\t\\r\\n\\f]*"),
                    V = new RegExp("^[\\x20\\t\\r\\n\\f]*([>+~]|[\\x20\\t\\r\\n\\f])[\\x20\\t\\r\\n\\f]*"),
                    W = new RegExp(z + "|>"),
                    q = new RegExp(B),
                    $ = new RegExp("^" + F + "$"),
                    X = {
                        ID: new RegExp("^#(" + F + ")"),
                        CLASS: new RegExp("^\\.(" + F + ")"),
                        TAG: new RegExp("^(" + F + "|[*])"),
                        ATTR: new RegExp("^" + H),
                        PSEUDO: new RegExp("^" + B),
                        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\([\\x20\\t\\r\\n\\f]*(even|odd|(([+-]|)(\\d*)n|)[\\x20\\t\\r\\n\\f]*(?:([+-]|)[\\x20\\t\\r\\n\\f]*(\\d+)|))[\\x20\\t\\r\\n\\f]*\\)|)", "i"),
                        bool: new RegExp("^(?:" + I + ")$", "i"),
                        needsContext: new RegExp("^[\\x20\\t\\r\\n\\f]*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\([\\x20\\t\\r\\n\\f]*((?:-\\d)?\\d*)[\\x20\\t\\r\\n\\f]*\\)|)(?=[^-]|$)", "i")
                    },
                    Y = /HTML$/i,
                    Z = /^(?:input|select|textarea|button)$/i,
                    J = /^h\d$/i,
                    Q = /^[^{]+\{\s*\[native \w/,
                    K = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                    ee = /[+~]/,
                    te = new RegExp("\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\([^\\r\\n\\f])", "g"),
                    ne = function (e, t) {
                        var n = "0x" + e.slice(1) - 65536;
                        return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
                    },
                    ie = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                    re = function (e, t) {
                        return t ? "\0" === e ? "ï¿½" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e
                    },
                    oe = function () {
                        d()
                    },
                    ae = we((function (e) {
                        return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase()
                    }), {
                        dir: "parentNode",
                        next: "legend"
                    });
                try {
                    D.apply(P = k.call(b.childNodes), b.childNodes), P[b.childNodes.length].nodeType
                } catch (e) {
                    D = {
                        apply: P.length ? function (e, t) {
                            O.apply(e, k.call(t))
                        } : function (e, t) {
                            for (var n = e.length, i = 0; e[n++] = t[i++];);
                            e.length = n - 1
                        }
                    }
                }

                function se(e, t, i, r) {
                    var o, s, c, u, h, f, v, y = t && t.ownerDocument,
                        b = t ? t.nodeType : 9;
                    if (i = i || [], "string" != typeof e || !e || 1 !== b && 9 !== b && 11 !== b) return i;
                    if (!r && (d(t), t = t || p, m)) {
                        if (11 !== b && (h = K.exec(e)))
                            if (o = h[1]) {
                                if (9 === b) {
                                    if (!(c = t.getElementById(o))) return i;
                                    if (c.id === o) return i.push(c), i
                                } else if (y && (c = y.getElementById(o)) && x(t, c) && c.id === o) return i.push(c), i
                            } else {
                                if (h[2]) return D.apply(i, t.getElementsByTagName(e)), i;
                                if ((o = h[3]) && n.getElementsByClassName && t.getElementsByClassName) return D.apply(i, t.getElementsByClassName(o)), i
                            }
                        if (n.qsa && !A[e + " "] && (!g || !g.test(e)) && (1 !== b || "object" !== t.nodeName.toLowerCase())) {
                            if (v = e, y = t, 1 === b && (W.test(e) || V.test(e))) {
                                for ((y = ee.test(e) && ve(t.parentNode) || t) === t && n.scope || ((u = t.getAttribute("id")) ? u = u.replace(ie, re) : t.setAttribute("id", u = w)), s = (f = a(e)).length; s--;) f[s] = (u ? "#" + u : ":scope") + " " + xe(f[s]);
                                v = f.join(",")
                            }
                            try {
                                return D.apply(i, y.querySelectorAll(v)), i
                            } catch (t) {
                                A(e, !0)
                            } finally {
                                u === w && t.removeAttribute("id")
                            }
                        }
                    }
                    return l(e.replace(j, "$1"), t, i, r)
                }

                function le() {
                    var e = [];
                    return function t(n, r) {
                        return e.push(n + " ") > i.cacheLength && delete t[e.shift()], t[n + " "] = r
                    }
                }

                function ce(e) {
                    return e[w] = !0, e
                }

                function ue(e) {
                    var t = p.createElement("fieldset");
                    try {
                        return !!e(t)
                    } catch (e) {
                        return !1
                    } finally {
                        t.parentNode && t.parentNode.removeChild(t), t = null
                    }
                }

                function he(e, t) {
                    for (var n = e.split("|"), r = n.length; r--;) i.attrHandle[n[r]] = t
                }

                function de(e, t) {
                    var n = t && e,
                        i = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
                    if (i) return i;
                    if (n)
                        for (; n = n.nextSibling;)
                            if (n === t) return -1;
                    return e ? 1 : -1
                }

                function pe(e) {
                    return function (t) {
                        return "input" === t.nodeName.toLowerCase() && t.type === e
                    }
                }

                function fe(e) {
                    return function (t) {
                        var n = t.nodeName.toLowerCase();
                        return ("input" === n || "button" === n) && t.type === e
                    }
                }

                function me(e) {
                    return function (t) {
                        return "form" in t ? t.parentNode && !1 === t.disabled ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && ae(t) === e : t.disabled === e : "label" in t && t.disabled === e
                    }
                }

                function ge(e) {
                    return ce((function (t) {
                        return t = +t, ce((function (n, i) {
                            for (var r, o = e([], n.length, t), a = o.length; a--;) n[r = o[a]] && (n[r] = !(i[r] = n[r]))
                        }))
                    }))
                }

                function ve(e) {
                    return e && void 0 !== e.getElementsByTagName && e
                }
                for (t in n = se.support = {}, o = se.isXML = function (e) {
                    var t = e && e.namespaceURI,
                        n = e && (e.ownerDocument || e).documentElement;
                    return !Y.test(t || n && n.nodeName || "HTML")
                }, d = se.setDocument = function (e) {
                    var t, r, a = e ? e.ownerDocument || e : b;
                    return a != p && 9 === a.nodeType && a.documentElement ? (f = (p = a).documentElement, m = !o(p), b != p && (r = p.defaultView) && r.top !== r && (r.addEventListener ? r.addEventListener("unload", oe, !1) : r.attachEvent && r.attachEvent("onunload", oe)), n.scope = ue((function (e) {
                        return f.appendChild(e).appendChild(p.createElement("div")), void 0 !== e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length
                    })), n.attributes = ue((function (e) {
                        return e.className = "i", !e.getAttribute("className")
                    })), n.getElementsByTagName = ue((function (e) {
                        return e.appendChild(p.createComment("")), !e.getElementsByTagName("*").length
                    })), n.getElementsByClassName = Q.test(p.getElementsByClassName), n.getById = ue((function (e) {
                        return f.appendChild(e).id = w, !p.getElementsByName || !p.getElementsByName(w).length
                    })), n.getById ? (i.filter.ID = function (e) {
                        var t = e.replace(te, ne);
                        return function (e) {
                            return e.getAttribute("id") === t
                        }
                    }, i.find.ID = function (e, t) {
                        if (void 0 !== t.getElementById && m) {
                            var n = t.getElementById(e);
                            return n ? [n] : []
                        }
                    }) : (i.filter.ID = function (e) {
                        var t = e.replace(te, ne);
                        return function (e) {
                            var n = void 0 !== e.getAttributeNode && e.getAttributeNode("id");
                            return n && n.value === t
                        }
                    }, i.find.ID = function (e, t) {
                        if (void 0 !== t.getElementById && m) {
                            var n, i, r, o = t.getElementById(e);
                            if (o) {
                                if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
                                for (r = t.getElementsByName(e), i = 0; o = r[i++];)
                                    if ((n = o.getAttributeNode("id")) && n.value === e) return [o]
                            }
                            return []
                        }
                    }), i.find.TAG = n.getElementsByTagName ? function (e, t) {
                        return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0
                    } : function (e, t) {
                        var n, i = [],
                            r = 0,
                            o = t.getElementsByTagName(e);
                        if ("*" === e) {
                            for (; n = o[r++];) 1 === n.nodeType && i.push(n);
                            return i
                        }
                        return o
                    }, i.find.CLASS = n.getElementsByClassName && function (e, t) {
                        if (void 0 !== t.getElementsByClassName && m) return t.getElementsByClassName(e)
                    }, v = [], g = [], (n.qsa = Q.test(p.querySelectorAll)) && (ue((function (e) {
                        var t;
                        f.appendChild(e).innerHTML = "<a id='" + w + "'></a><select id='" + w + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && g.push("[*^$]=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"), e.querySelectorAll("[selected]").length || g.push("\\[[\\x20\\t\\r\\n\\f]*(?:value|" + I + ")"), e.querySelectorAll("[id~=" + w + "-]").length || g.push("~="), (t = p.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || g.push("\\[[\\x20\\t\\r\\n\\f]*name[\\x20\\t\\r\\n\\f]*=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"), e.querySelectorAll(":checked").length || g.push(":checked"), e.querySelectorAll("a#" + w + "+*").length || g.push(".#.+[+~]"), e.querySelectorAll("\\\f"), g.push("[\\r\\n\\f]")
                    })), ue((function (e) {
                        e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                        var t = p.createElement("input");
                        t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && g.push("name[\\x20\\t\\r\\n\\f]*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && g.push(":enabled", ":disabled"), f.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && g.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), g.push(",.*:")
                    }))), (n.matchesSelector = Q.test(y = f.matches || f.webkitMatchesSelector || f.mozMatchesSelector || f.oMatchesSelector || f.msMatchesSelector)) && ue((function (e) {
                        n.disconnectedMatch = y.call(e, "*"), y.call(e, "[s!='']:x"), v.push("!=", B)
                    })), g = g.length && new RegExp(g.join("|")), v = v.length && new RegExp(v.join("|")), t = Q.test(f.compareDocumentPosition), x = t || Q.test(f.contains) ? function (e, t) {
                        var n = 9 === e.nodeType ? e.documentElement : e,
                            i = t && t.parentNode;
                        return e === i || !(!i || 1 !== i.nodeType || !(n.contains ? n.contains(i) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(i)))
                    } : function (e, t) {
                        if (t)
                            for (; t = t.parentNode;)
                                if (t === e) return !0;
                        return !1
                    }, C = t ? function (e, t) {
                        if (e === t) return h = !0, 0;
                        var i = !e.compareDocumentPosition - !t.compareDocumentPosition;
                        return i || (1 & (i = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !n.sortDetached && t.compareDocumentPosition(e) === i ? e == p || e.ownerDocument == b && x(b, e) ? -1 : t == p || t.ownerDocument == b && x(b, t) ? 1 : u ? N(u, e) - N(u, t) : 0 : 4 & i ? -1 : 1)
                    } : function (e, t) {
                        if (e === t) return h = !0, 0;
                        var n, i = 0,
                            r = e.parentNode,
                            o = t.parentNode,
                            a = [e],
                            s = [t];
                        if (!r || !o) return e == p ? -1 : t == p ? 1 : r ? -1 : o ? 1 : u ? N(u, e) - N(u, t) : 0;
                        if (r === o) return de(e, t);
                        for (n = e; n = n.parentNode;) a.unshift(n);
                        for (n = t; n = n.parentNode;) s.unshift(n);
                        for (; a[i] === s[i];) i++;
                        return i ? de(a[i], s[i]) : a[i] == b ? -1 : s[i] == b ? 1 : 0
                    }, p) : p
                }, se.matches = function (e, t) {
                    return se(e, null, null, t)
                }, se.matchesSelector = function (e, t) {
                    if (d(e), n.matchesSelector && m && !A[t + " "] && (!v || !v.test(t)) && (!g || !g.test(t))) try {
                        var i = y.call(e, t);
                        if (i || n.disconnectedMatch || e.document && 11 !== e.document.nodeType) return i
                    } catch (e) {
                        A(t, !0)
                    }
                    return se(t, p, null, [e]).length > 0
                }, se.contains = function (e, t) {
                    return (e.ownerDocument || e) != p && d(e), x(e, t)
                }, se.attr = function (e, t) {
                    (e.ownerDocument || e) != p && d(e);
                    var r = i.attrHandle[t.toLowerCase()],
                        o = r && L.call(i.attrHandle, t.toLowerCase()) ? r(e, t, !m) : void 0;
                    return void 0 !== o ? o : n.attributes || !m ? e.getAttribute(t) : (o = e.getAttributeNode(t)) && o.specified ? o.value : null
                }, se.escape = function (e) {
                    return (e + "").replace(ie, re)
                }, se.error = function (e) {
                    throw new Error("Syntax error, unrecognized expression: " + e)
                }, se.uniqueSort = function (e) {
                    var t, i = [],
                        r = 0,
                        o = 0;
                    if (h = !n.detectDuplicates, u = !n.sortStable && e.slice(0), e.sort(C), h) {
                        for (; t = e[o++];) t === e[o] && (r = i.push(o));
                        for (; r--;) e.splice(i[r], 1)
                    }
                    return u = null, e
                }, r = se.getText = function (e) {
                    var t, n = "",
                        i = 0,
                        o = e.nodeType;
                    if (o) {
                        if (1 === o || 9 === o || 11 === o) {
                            if ("string" == typeof e.textContent) return e.textContent;
                            for (e = e.firstChild; e; e = e.nextSibling) n += r(e)
                        } else if (3 === o || 4 === o) return e.nodeValue
                    } else
                        for (; t = e[i++];) n += r(t);
                    return n
                }, (i = se.selectors = {
                    cacheLength: 50,
                    createPseudo: ce,
                    match: X,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: !0
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: !0
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: function (e) {
                            return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
                        },
                        CHILD: function (e) {
                            return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e
                        },
                        PSEUDO: function (e) {
                            var t, n = !e[6] && e[2];
                            return X.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && q.test(n) && (t = a(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
                        }
                    },
                    filter: {
                        TAG: function (e) {
                            var t = e.replace(te, ne).toLowerCase();
                            return "*" === e ? function () {
                                return !0
                            } : function (e) {
                                return e.nodeName && e.nodeName.toLowerCase() === t
                            }
                        },
                        CLASS: function (e) {
                            var t = T[e + " "];
                            return t || (t = new RegExp("(^|[\\x20\\t\\r\\n\\f])" + e + "(" + z + "|$)")) && T(e, (function (e) {
                                return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "")
                            }))
                        },
                        ATTR: function (e, t, n) {
                            return function (i) {
                                var r = se.attr(i, e);
                                return null == r ? "!=" === t : !t || (r += "", "=" === t ? r === n : "!=" === t ? r !== n : "^=" === t ? n && 0 === r.indexOf(n) : "*=" === t ? n && r.indexOf(n) > -1 : "$=" === t ? n && r.slice(-n.length) === n : "~=" === t ? (" " + r.replace(U, " ") + " ").indexOf(n) > -1 : "|=" === t && (r === n || r.slice(0, n.length + 1) === n + "-"))
                            }
                        },
                        CHILD: function (e, t, n, i, r) {
                            var o = "nth" !== e.slice(0, 3),
                                a = "last" !== e.slice(-4),
                                s = "of-type" === t;
                            return 1 === i && 0 === r ? function (e) {
                                return !!e.parentNode
                            } : function (t, n, l) {
                                var c, u, h, d, p, f, m = o !== a ? "nextSibling" : "previousSibling",
                                    g = t.parentNode,
                                    v = s && t.nodeName.toLowerCase(),
                                    y = !l && !s,
                                    x = !1;
                                if (g) {
                                    if (o) {
                                        for (; m;) {
                                            for (d = t; d = d[m];)
                                                if (s ? d.nodeName.toLowerCase() === v : 1 === d.nodeType) return !1;
                                            f = m = "only" === e && !f && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (f = [a ? g.firstChild : g.lastChild], a && y) {
                                        for (x = (p = (c = (u = (h = (d = g)[w] || (d[w] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[e] || [])[0] === _ && c[1]) && c[2], d = p && g.childNodes[p]; d = ++p && d && d[m] || (x = p = 0) || f.pop();)
                                            if (1 === d.nodeType && ++x && d === t) {
                                                u[e] = [_, p, x];
                                                break
                                            }
                                    } else if (y && (x = p = (c = (u = (h = (d = t)[w] || (d[w] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[e] || [])[0] === _ && c[1]), !1 === x)
                                        for (;
                                            (d = ++p && d && d[m] || (x = p = 0) || f.pop()) && ((s ? d.nodeName.toLowerCase() !== v : 1 !== d.nodeType) || !++x || (y && ((u = (h = d[w] || (d[w] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[e] = [_, x]), d !== t)););
                                    return (x -= r) === i || x % i == 0 && x / i >= 0
                                }
                            }
                        },
                        PSEUDO: function (e, t) {
                            var n, r = i.pseudos[e] || i.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e);
                            return r[w] ? r(t) : r.length > 1 ? (n = [e, e, "", t], i.setFilters.hasOwnProperty(e.toLowerCase()) ? ce((function (e, n) {
                                for (var i, o = r(e, t), a = o.length; a--;) e[i = N(e, o[a])] = !(n[i] = o[a])
                            })) : function (e) {
                                return r(e, 0, n)
                            }) : r
                        }
                    },
                    pseudos: {
                        not: ce((function (e) {
                            var t = [],
                                n = [],
                                i = s(e.replace(j, "$1"));
                            return i[w] ? ce((function (e, t, n, r) {
                                for (var o, a = i(e, null, r, []), s = e.length; s--;)(o = a[s]) && (e[s] = !(t[s] = o))
                            })) : function (e, r, o) {
                                return t[0] = e, i(t, null, o, n), t[0] = null, !n.pop()
                            }
                        })),
                        has: ce((function (e) {
                            return function (t) {
                                return se(e, t).length > 0
                            }
                        })),
                        contains: ce((function (e) {
                            return e = e.replace(te, ne),
                                function (t) {
                                    return (t.textContent || r(t)).indexOf(e) > -1
                                }
                        })),
                        lang: ce((function (e) {
                            return $.test(e || "") || se.error("unsupported lang: " + e), e = e.replace(te, ne).toLowerCase(),
                                function (t) {
                                    var n;
                                    do {
                                        if (n = m ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + "-")
                                    } while ((t = t.parentNode) && 1 === t.nodeType);
                                    return !1
                                }
                        })),
                        target: function (t) {
                            var n = e.location && e.location.hash;
                            return n && n.slice(1) === t.id
                        },
                        root: function (e) {
                            return e === f
                        },
                        focus: function (e) {
                            return e === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
                        },
                        enabled: me(!1),
                        disabled: me(!0),
                        checked: function (e) {
                            var t = e.nodeName.toLowerCase();
                            return "input" === t && !!e.checked || "option" === t && !!e.selected
                        },
                        selected: function (e) {
                            return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected
                        },
                        empty: function (e) {
                            for (e = e.firstChild; e; e = e.nextSibling)
                                if (e.nodeType < 6) return !1;
                            return !0
                        },
                        parent: function (e) {
                            return !i.pseudos.empty(e)
                        },
                        header: function (e) {
                            return J.test(e.nodeName)
                        },
                        input: function (e) {
                            return Z.test(e.nodeName)
                        },
                        button: function (e) {
                            var t = e.nodeName.toLowerCase();
                            return "input" === t && "button" === e.type || "button" === t
                        },
                        text: function (e) {
                            var t;
                            return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
                        },
                        first: ge((function () {
                            return [0]
                        })),
                        last: ge((function (e, t) {
                            return [t - 1]
                        })),
                        eq: ge((function (e, t, n) {
                            return [n < 0 ? n + t : n]
                        })),
                        even: ge((function (e, t) {
                            for (var n = 0; n < t; n += 2) e.push(n);
                            return e
                        })),
                        odd: ge((function (e, t) {
                            for (var n = 1; n < t; n += 2) e.push(n);
                            return e
                        })),
                        lt: ge((function (e, t, n) {
                            for (var i = n < 0 ? n + t : n > t ? t : n; --i >= 0;) e.push(i);
                            return e
                        })),
                        gt: ge((function (e, t, n) {
                            for (var i = n < 0 ? n + t : n; ++i < t;) e.push(i);
                            return e
                        }))
                    }
                }).pseudos.nth = i.pseudos.eq, {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                }) i.pseudos[t] = pe(t);
                for (t in {
                    submit: !0,
                    reset: !0
                }) i.pseudos[t] = fe(t);

                function ye() { }

                function xe(e) {
                    for (var t = 0, n = e.length, i = ""; t < n; t++) i += e[t].value;
                    return i
                }

                function we(e, t, n) {
                    var i = t.dir,
                        r = t.next,
                        o = r || i,
                        a = n && "parentNode" === o,
                        s = M++;
                    return t.first ? function (t, n, r) {
                        for (; t = t[i];)
                            if (1 === t.nodeType || a) return e(t, n, r);
                        return !1
                    } : function (t, n, l) {
                        var c, u, h, d = [_, s];
                        if (l) {
                            for (; t = t[i];)
                                if ((1 === t.nodeType || a) && e(t, n, l)) return !0
                        } else
                            for (; t = t[i];)
                                if (1 === t.nodeType || a)
                                    if (u = (h = t[w] || (t[w] = {}))[t.uniqueID] || (h[t.uniqueID] = {}), r && r === t.nodeName.toLowerCase()) t = t[i] || t;
                                    else {
                                        if ((c = u[o]) && c[0] === _ && c[1] === s) return d[2] = c[2];
                                        if (u[o] = d, d[2] = e(t, n, l)) return !0
                                    } return !1
                    }
                }

                function be(e) {
                    return e.length > 1 ? function (t, n, i) {
                        for (var r = e.length; r--;)
                            if (!e[r](t, n, i)) return !1;
                        return !0
                    } : e[0]
                }

                function _e(e, t, n, i, r) {
                    for (var o, a = [], s = 0, l = e.length, c = null != t; s < l; s++)(o = e[s]) && (n && !n(o, i, r) || (a.push(o), c && t.push(s)));
                    return a
                }

                function Me(e, t, n, i, r, o) {
                    return i && !i[w] && (i = Me(i)), r && !r[w] && (r = Me(r, o)), ce((function (o, a, s, l) {
                        var c, u, h, d = [],
                            p = [],
                            f = a.length,
                            m = o || function (e, t, n) {
                                for (var i = 0, r = t.length; i < r; i++) se(e, t[i], n);
                                return n
                            }(t || "*", s.nodeType ? [s] : s, []),
                            g = !e || !o && t ? m : _e(m, d, e, s, l),
                            v = n ? r || (o ? e : f || i) ? [] : a : g;
                        if (n && n(g, v, s, l), i)
                            for (c = _e(v, p), i(c, [], s, l), u = c.length; u--;)(h = c[u]) && (v[p[u]] = !(g[p[u]] = h));
                        if (o) {
                            if (r || e) {
                                if (r) {
                                    for (c = [], u = v.length; u--;)(h = v[u]) && c.push(g[u] = h);
                                    r(null, v = [], c, l)
                                }
                                for (u = v.length; u--;)(h = v[u]) && (c = r ? N(o, h) : d[u]) > -1 && (o[c] = !(a[c] = h))
                            }
                        } else v = _e(v === a ? v.splice(f, v.length) : v), r ? r(null, a, v, l) : D.apply(a, v)
                    }))
                }

                function Te(e) {
                    for (var t, n, r, o = e.length, a = i.relative[e[0].type], s = a || i.relative[" "], l = a ? 1 : 0, u = we((function (e) {
                        return e === t
                    }), s, !0), h = we((function (e) {
                        return N(t, e) > -1
                    }), s, !0), d = [function (e, n, i) {
                        var r = !a && (i || n !== c) || ((t = n).nodeType ? u(e, n, i) : h(e, n, i));
                        return t = null, r
                    }]; l < o; l++)
                        if (n = i.relative[e[l].type]) d = [we(be(d), n)];
                        else {
                            if ((n = i.filter[e[l].type].apply(null, e[l].matches))[w]) {
                                for (r = ++l; r < o && !i.relative[e[r].type]; r++);
                                return Me(l > 1 && be(d), l > 1 && xe(e.slice(0, l - 1).concat({
                                    value: " " === e[l - 2].type ? "*" : ""
                                })).replace(j, "$1"), n, l < r && Te(e.slice(l, r)), r < o && Te(e = e.slice(r)), r < o && xe(e))
                            }
                            d.push(n)
                        }
                    return be(d)
                }
                return ye.prototype = i.filters = i.pseudos, i.setFilters = new ye, a = se.tokenize = function (e, t) {
                    var n, r, o, a, s, l, c, u = S[e + " "];
                    if (u) return t ? 0 : u.slice(0);
                    for (s = e, l = [], c = i.preFilter; s;) {
                        for (a in n && !(r = G.exec(s)) || (r && (s = s.slice(r[0].length) || s), l.push(o = [])), n = !1, (r = V.exec(s)) && (n = r.shift(), o.push({
                            value: n,
                            type: r[0].replace(j, " ")
                        }), s = s.slice(n.length)), i.filter) !(r = X[a].exec(s)) || c[a] && !(r = c[a](r)) || (n = r.shift(), o.push({
                            value: n,
                            type: a,
                            matches: r
                        }), s = s.slice(n.length));
                        if (!n) break
                    }
                    return t ? s.length : s ? se.error(e) : S(e, l).slice(0)
                }, s = se.compile = function (e, t) {
                    var n, r = [],
                        o = [],
                        s = E[e + " "];
                    if (!s) {
                        for (t || (t = a(e)), n = t.length; n--;)(s = Te(t[n]))[w] ? r.push(s) : o.push(s);
                        (s = E(e, function (e, t) {
                            var n = t.length > 0,
                                r = e.length > 0,
                                o = function (o, a, s, l, u) {
                                    var h, f, g, v = 0,
                                        y = "0",
                                        x = o && [],
                                        w = [],
                                        b = c,
                                        M = o || r && i.find.TAG("*", u),
                                        T = _ += null == b ? 1 : Math.random() || .1,
                                        S = M.length;
                                    for (u && (c = a == p || a || u); y !== S && null != (h = M[y]); y++) {
                                        if (r && h) {
                                            for (f = 0, a || h.ownerDocument == p || (d(h), s = !m); g = e[f++];)
                                                if (g(h, a || p, s)) {
                                                    l.push(h);
                                                    break
                                                }
                                            u && (_ = T)
                                        }
                                        n && ((h = !g && h) && v--, o && x.push(h))
                                    }
                                    if (v += y, n && y !== v) {
                                        for (f = 0; g = t[f++];) g(x, w, a, s);
                                        if (o) {
                                            if (v > 0)
                                                for (; y--;) x[y] || w[y] || (w[y] = R.call(l));
                                            w = _e(w)
                                        }
                                        D.apply(l, w), u && !o && w.length > 0 && v + t.length > 1 && se.uniqueSort(l)
                                    }
                                    return u && (_ = T, c = b), x
                                };
                            return n ? ce(o) : o
                        }(o, r))).selector = e
                    }
                    return s
                }, l = se.select = function (e, t, n, r) {
                    var o, l, c, u, h, d = "function" == typeof e && e,
                        p = !r && a(e = d.selector || e);
                    if (n = n || [], 1 === p.length) {
                        if ((l = p[0] = p[0].slice(0)).length > 2 && "ID" === (c = l[0]).type && 9 === t.nodeType && m && i.relative[l[1].type]) {
                            if (!(t = (i.find.ID(c.matches[0].replace(te, ne), t) || [])[0])) return n;
                            d && (t = t.parentNode), e = e.slice(l.shift().value.length)
                        }
                        for (o = X.needsContext.test(e) ? 0 : l.length; o-- && (c = l[o], !i.relative[u = c.type]);)
                            if ((h = i.find[u]) && (r = h(c.matches[0].replace(te, ne), ee.test(l[0].type) && ve(t.parentNode) || t))) {
                                if (l.splice(o, 1), !(e = r.length && xe(l))) return D.apply(n, r), n;
                                break
                            }
                    }
                    return (d || s(e, p))(r, t, !m, n, !t || ee.test(e) && ve(t.parentNode) || t), n
                }, n.sortStable = w.split("").sort(C).join("") === w, n.detectDuplicates = !!h, d(), n.sortDetached = ue((function (e) {
                    return 1 & e.compareDocumentPosition(p.createElement("fieldset"))
                })), ue((function (e) {
                    return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
                })) || he("type|href|height|width", (function (e, t, n) {
                    if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
                })), n.attributes && ue((function (e) {
                    return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
                })) || he("value", (function (e, t, n) {
                    if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue
                })), ue((function (e) {
                    return null == e.getAttribute("disabled")
                })) || he(I, (function (e, t, n) {
                    var i;
                    if (!n) return !0 === e[t] ? t.toLowerCase() : (i = e.getAttributeNode(t)) && i.specified ? i.value : null
                })), se
            }(n);
            T.find = E, T.expr = E.selectors, T.expr[":"] = T.expr.pseudos, T.uniqueSort = T.unique = E.uniqueSort, T.text = E.getText, T.isXMLDoc = E.isXML, T.contains = E.contains, T.escapeSelector = E.escape;
            var A = function (e, t, n) {
                for (var i = [], r = void 0 !== n;
                    (e = e[t]) && 9 !== e.nodeType;)
                    if (1 === e.nodeType) {
                        if (r && T(e).is(n)) break;
                        i.push(e)
                    }
                return i
            },
                C = function (e, t) {
                    for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
                    return n
                },
                L = T.expr.match.needsContext;

            function P(e, t) {
                return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
            }
            var R = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

            function O(e, t, n) {
                return v(t) ? T.grep(e, (function (e, i) {
                    return !!t.call(e, i, e) !== n
                })) : t.nodeType ? T.grep(e, (function (e) {
                    return e === t !== n
                })) : "string" != typeof t ? T.grep(e, (function (e) {
                    return u.call(t, e) > -1 !== n
                })) : T.filter(t, e, n)
            }
            T.filter = function (e, t, n) {
                var i = t[0];
                return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === i.nodeType ? T.find.matchesSelector(i, e) ? [i] : [] : T.find.matches(e, T.grep(t, (function (e) {
                    return 1 === e.nodeType
                })))
            }, T.fn.extend({
                find: function (e) {
                    var t, n, i = this.length,
                        r = this;
                    if ("string" != typeof e) return this.pushStack(T(e).filter((function () {
                        for (t = 0; t < i; t++)
                            if (T.contains(r[t], this)) return !0
                    })));
                    for (n = this.pushStack([]), t = 0; t < i; t++) T.find(e, r[t], n);
                    return i > 1 ? T.uniqueSort(n) : n
                },
                filter: function (e) {
                    return this.pushStack(O(this, e || [], !1))
                },
                not: function (e) {
                    return this.pushStack(O(this, e || [], !0))
                },
                is: function (e) {
                    return !!O(this, "string" == typeof e && L.test(e) ? T(e) : e || [], !1).length
                }
            });
            var D, k = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
            (T.fn.init = function (e, t, n) {
                var i, r;
                if (!e) return this;
                if (n = n || D, "string" == typeof e) {
                    if (!(i = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : k.exec(e)) || !i[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
                    if (i[1]) {
                        if (t = t instanceof T ? t[0] : t, T.merge(this, T.parseHTML(i[1], t && t.nodeType ? t.ownerDocument || t : x, !0)), R.test(i[1]) && T.isPlainObject(t))
                            for (i in t) v(this[i]) ? this[i](t[i]) : this.attr(i, t[i]);
                        return this
                    }
                    return (r = x.getElementById(i[2])) && (this[0] = r, this.length = 1), this
                }
                return e.nodeType ? (this[0] = e, this.length = 1, this) : v(e) ? void 0 !== n.ready ? n.ready(e) : e(T) : T.makeArray(e, this)
            }).prototype = T.fn, D = T(x);
            var N = /^(?:parents|prev(?:Until|All))/,
                I = {
                    children: !0,
                    contents: !0,
                    next: !0,
                    prev: !0
                };

            function z(e, t) {
                for (;
                    (e = e[t]) && 1 !== e.nodeType;);
                return e
            }
            T.fn.extend({
                has: function (e) {
                    var t = T(e, this),
                        n = t.length;
                    return this.filter((function () {
                        for (var e = 0; e < n; e++)
                            if (T.contains(this, t[e])) return !0
                    }))
                },
                closest: function (e, t) {
                    var n, i = 0,
                        r = this.length,
                        o = [],
                        a = "string" != typeof e && T(e);
                    if (!L.test(e))
                        for (; i < r; i++)
                            for (n = this[i]; n && n !== t; n = n.parentNode)
                                if (n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && T.find.matchesSelector(n, e))) {
                                    o.push(n);
                                    break
                                }
                    return this.pushStack(o.length > 1 ? T.uniqueSort(o) : o)
                },
                index: function (e) {
                    return e ? "string" == typeof e ? u.call(T(e), this[0]) : u.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
                },
                add: function (e, t) {
                    return this.pushStack(T.uniqueSort(T.merge(this.get(), T(e, t))))
                },
                addBack: function (e) {
                    return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
                }
            }), T.each({
                parent: function (e) {
                    var t = e.parentNode;
                    return t && 11 !== t.nodeType ? t : null
                },
                parents: function (e) {
                    return A(e, "parentNode")
                },
                parentsUntil: function (e, t, n) {
                    return A(e, "parentNode", n)
                },
                next: function (e) {
                    return z(e, "nextSibling")
                },
                prev: function (e) {
                    return z(e, "previousSibling")
                },
                nextAll: function (e) {
                    return A(e, "nextSibling")
                },
                prevAll: function (e) {
                    return A(e, "previousSibling")
                },
                nextUntil: function (e, t, n) {
                    return A(e, "nextSibling", n)
                },
                prevUntil: function (e, t, n) {
                    return A(e, "previousSibling", n)
                },
                siblings: function (e) {
                    return C((e.parentNode || {}).firstChild, e)
                },
                children: function (e) {
                    return C(e.firstChild)
                },
                contents: function (e) {
                    return null != e.contentDocument && a(e.contentDocument) ? e.contentDocument : (P(e, "template") && (e = e.content || e), T.merge([], e.childNodes))
                }
            }, (function (e, t) {
                T.fn[e] = function (n, i) {
                    var r = T.map(this, t, n);
                    return "Until" !== e.slice(-5) && (i = n), i && "string" == typeof i && (r = T.filter(i, r)), this.length > 1 && (I[e] || T.uniqueSort(r), N.test(e) && r.reverse()), this.pushStack(r)
                }
            }));
            var F = /[^\x20\t\r\n\f]+/g;

            function H(e) {
                return e
            }

            function B(e) {
                throw e
            }

            function U(e, t, n, i) {
                var r;
                try {
                    e && v(r = e.promise) ? r.call(e).done(t).fail(n) : e && v(r = e.then) ? r.call(e, t, n) : t.apply(void 0, [e].slice(i))
                } catch (e) {
                    n.apply(void 0, [e])
                }
            }
            T.Callbacks = function (e) {
                e = "string" == typeof e ? function (e) {
                    var t = {};
                    return T.each(e.match(F) || [], (function (e, n) {
                        t[n] = !0
                    })), t
                }(e) : T.extend({}, e);
                var t, n, i, r, o = [],
                    a = [],
                    s = -1,
                    l = function () {
                        for (r = r || e.once, i = t = !0; a.length; s = -1)
                            for (n = a.shift(); ++s < o.length;) !1 === o[s].apply(n[0], n[1]) && e.stopOnFalse && (s = o.length, n = !1);
                        e.memory || (n = !1), t = !1, r && (o = n ? [] : "")
                    },
                    c = {
                        add: function () {
                            return o && (n && !t && (s = o.length - 1, a.push(n)), function t(n) {
                                T.each(n, (function (n, i) {
                                    v(i) ? e.unique && c.has(i) || o.push(i) : i && i.length && "string" !== _(i) && t(i)
                                }))
                            }(arguments), n && !t && l()), this
                        },
                        remove: function () {
                            return T.each(arguments, (function (e, t) {
                                for (var n;
                                    (n = T.inArray(t, o, n)) > -1;) o.splice(n, 1), n <= s && s--
                            })), this
                        },
                        has: function (e) {
                            return e ? T.inArray(e, o) > -1 : o.length > 0
                        },
                        empty: function () {
                            return o && (o = []), this
                        },
                        disable: function () {
                            return r = a = [], o = n = "", this
                        },
                        disabled: function () {
                            return !o
                        },
                        lock: function () {
                            return r = a = [], n || t || (o = n = ""), this
                        },
                        locked: function () {
                            return !!r
                        },
                        fireWith: function (e, n) {
                            return r || (n = [e, (n = n || []).slice ? n.slice() : n], a.push(n), t || l()), this
                        },
                        fire: function () {
                            return c.fireWith(this, arguments), this
                        },
                        fired: function () {
                            return !!i
                        }
                    };
                return c
            }, T.extend({
                Deferred: function (e) {
                    var t = [
                        ["notify", "progress", T.Callbacks("memory"), T.Callbacks("memory"), 2],
                        ["resolve", "done", T.Callbacks("once memory"), T.Callbacks("once memory"), 0, "resolved"],
                        ["reject", "fail", T.Callbacks("once memory"), T.Callbacks("once memory"), 1, "rejected"]
                    ],
                        i = "pending",
                        r = {
                            state: function () {
                                return i
                            },
                            always: function () {
                                return o.done(arguments).fail(arguments), this
                            },
                            catch: function (e) {
                                return r.then(null, e)
                            },
                            pipe: function () {
                                var e = arguments;
                                return T.Deferred((function (n) {
                                    T.each(t, (function (t, i) {
                                        var r = v(e[i[4]]) && e[i[4]];
                                        o[i[1]]((function () {
                                            var e = r && r.apply(this, arguments);
                                            e && v(e.promise) ? e.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[i[0] + "With"](this, r ? [e] : arguments)
                                        }))
                                    })), e = null
                                })).promise()
                            },
                            then: function (e, i, r) {
                                var o = 0;

                                function a(e, t, i, r) {
                                    return function () {
                                        var s = this,
                                            l = arguments,
                                            c = function () {
                                                var n, c;
                                                if (!(e < o)) {
                                                    if ((n = i.apply(s, l)) === t.promise()) throw new TypeError("Thenable self-resolution");
                                                    c = n && ("object" == typeof n || "function" == typeof n) && n.then, v(c) ? r ? c.call(n, a(o, t, H, r), a(o, t, B, r)) : (o++, c.call(n, a(o, t, H, r), a(o, t, B, r), a(o, t, H, t.notifyWith))) : (i !== H && (s = void 0, l = [n]), (r || t.resolveWith)(s, l))
                                                }
                                            },
                                            u = r ? c : function () {
                                                try {
                                                    c()
                                                } catch (n) {
                                                    T.Deferred.exceptionHook && T.Deferred.exceptionHook(n, u.stackTrace), e + 1 >= o && (i !== B && (s = void 0, l = [n]), t.rejectWith(s, l))
                                                }
                                            };
                                        e ? u() : (T.Deferred.getStackHook && (u.stackTrace = T.Deferred.getStackHook()), n.setTimeout(u))
                                    }
                                }
                                return T.Deferred((function (n) {
                                    t[0][3].add(a(0, n, v(r) ? r : H, n.notifyWith)), t[1][3].add(a(0, n, v(e) ? e : H)), t[2][3].add(a(0, n, v(i) ? i : B))
                                })).promise()
                            },
                            promise: function (e) {
                                return null != e ? T.extend(e, r) : r
                            }
                        },
                        o = {};
                    return T.each(t, (function (e, n) {
                        var a = n[2],
                            s = n[5];
                        r[n[1]] = a.add, s && a.add((function () {
                            i = s
                        }), t[3 - e][2].disable, t[3 - e][3].disable, t[0][2].lock, t[0][3].lock), a.add(n[3].fire), o[n[0]] = function () {
                            return o[n[0] + "With"](this === o ? void 0 : this, arguments), this
                        }, o[n[0] + "With"] = a.fireWith
                    })), r.promise(o), e && e.call(o, o), o
                },
                when: function (e) {
                    var t = arguments.length,
                        n = t,
                        i = Array(n),
                        r = s.call(arguments),
                        o = T.Deferred(),
                        a = function (e) {
                            return function (n) {
                                i[e] = this, r[e] = arguments.length > 1 ? s.call(arguments) : n, --t || o.resolveWith(i, r)
                            }
                        };
                    if (t <= 1 && (U(e, o.done(a(n)).resolve, o.reject, !t), "pending" === o.state() || v(r[n] && r[n].then))) return o.then();
                    for (; n--;) U(r[n], a(n), o.reject);
                    return o.promise()
                }
            });
            var j = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
            T.Deferred.exceptionHook = function (e, t) {
                n.console && n.console.warn && e && j.test(e.name) && n.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t)
            }, T.readyException = function (e) {
                n.setTimeout((function () {
                    throw e
                }))
            };
            var G = T.Deferred();

            function V() {
                x.removeEventListener("DOMContentLoaded", V), n.removeEventListener("load", V), T.ready()
            }
            T.fn.ready = function (e) {
                return G.then(e).catch((function (e) {
                    T.readyException(e)
                })), this
            }, T.extend({
                isReady: !1,
                readyWait: 1,
                ready: function (e) {
                    (!0 === e ? --T.readyWait : T.isReady) || (T.isReady = !0, !0 !== e && --T.readyWait > 0 || G.resolveWith(x, [T]))
                }
            }), T.ready.then = G.then, "complete" === x.readyState || "loading" !== x.readyState && !x.documentElement.doScroll ? n.setTimeout(T.ready) : (x.addEventListener("DOMContentLoaded", V), n.addEventListener("load", V));
            var W = function (e, t, n, i, r, o, a) {
                var s = 0,
                    l = e.length,
                    c = null == n;
                if ("object" === _(n))
                    for (s in r = !0, n) W(e, t, s, n[s], !0, o, a);
                else if (void 0 !== i && (r = !0, v(i) || (a = !0), c && (a ? (t.call(e, i), t = null) : (c = t, t = function (e, t, n) {
                    return c.call(T(e), n)
                })), t))
                    for (; s < l; s++) t(e[s], n, a ? i : i.call(e[s], s, t(e[s], n)));
                return r ? e : c ? t.call(e) : l ? t(e[0], n) : o
            },
                q = /^-ms-/,
                $ = /-([a-z])/g;

            function X(e, t) {
                return t.toUpperCase()
            }

            function Y(e) {
                return e.replace(q, "ms-").replace($, X)
            }
            var Z = function (e) {
                return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
            };

            function J() {
                this.expando = T.expando + J.uid++
            }
            J.uid = 1, J.prototype = {
                cache: function (e) {
                    var t = e[this.expando];
                    return t || (t = {}, Z(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
                        value: t,
                        configurable: !0
                    }))), t
                },
                set: function (e, t, n) {
                    var i, r = this.cache(e);
                    if ("string" == typeof t) r[Y(t)] = n;
                    else
                        for (i in t) r[Y(i)] = t[i];
                    return r
                },
                get: function (e, t) {
                    return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][Y(t)]
                },
                access: function (e, t, n) {
                    return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t)
                },
                remove: function (e, t) {
                    var n, i = e[this.expando];
                    if (void 0 !== i) {
                        if (void 0 !== t) {
                            n = (t = Array.isArray(t) ? t.map(Y) : (t = Y(t)) in i ? [t] : t.match(F) || []).length;
                            for (; n--;) delete i[t[n]]
                        } (void 0 === t || T.isEmptyObject(i)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
                    }
                },
                hasData: function (e) {
                    var t = e[this.expando];
                    return void 0 !== t && !T.isEmptyObject(t)
                }
            };
            var Q = new J,
                K = new J,
                ee = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                te = /[A-Z]/g;

            function ne(e, t, n) {
                var i;
                if (void 0 === n && 1 === e.nodeType)
                    if (i = "data-" + t.replace(te, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(i))) {
                        try {
                            n = function (e) {
                                return "true" === e || "false" !== e && ("null" === e ? null : e === +e + "" ? +e : ee.test(e) ? JSON.parse(e) : e)
                            }(n)
                        } catch (e) { }
                        K.set(e, t, n)
                    } else n = void 0;
                return n
            }
            T.extend({
                hasData: function (e) {
                    return K.hasData(e) || Q.hasData(e)
                },
                data: function (e, t, n) {
                    return K.access(e, t, n)
                },
                removeData: function (e, t) {
                    K.remove(e, t)
                },
                _data: function (e, t, n) {
                    return Q.access(e, t, n)
                },
                _removeData: function (e, t) {
                    Q.remove(e, t)
                }
            }), T.fn.extend({
                data: function (e, t) {
                    var n, i, r, o = this[0],
                        a = o && o.attributes;
                    if (void 0 === e) {
                        if (this.length && (r = K.get(o), 1 === o.nodeType && !Q.get(o, "hasDataAttrs"))) {
                            for (n = a.length; n--;) a[n] && 0 === (i = a[n].name).indexOf("data-") && (i = Y(i.slice(5)), ne(o, i, r[i]));
                            Q.set(o, "hasDataAttrs", !0)
                        }
                        return r
                    }
                    return "object" == typeof e ? this.each((function () {
                        K.set(this, e)
                    })) : W(this, (function (t) {
                        var n;
                        if (o && void 0 === t) return void 0 !== (n = K.get(o, e)) || void 0 !== (n = ne(o, e)) ? n : void 0;
                        this.each((function () {
                            K.set(this, e, t)
                        }))
                    }), null, t, arguments.length > 1, null, !0)
                },
                removeData: function (e) {
                    return this.each((function () {
                        K.remove(this, e)
                    }))
                }
            }), T.extend({
                queue: function (e, t, n) {
                    var i;
                    if (e) return t = (t || "fx") + "queue", i = Q.get(e, t), n && (!i || Array.isArray(n) ? i = Q.access(e, t, T.makeArray(n)) : i.push(n)), i || []
                },
                dequeue: function (e, t) {
                    t = t || "fx";
                    var n = T.queue(e, t),
                        i = n.length,
                        r = n.shift(),
                        o = T._queueHooks(e, t);
                    "inprogress" === r && (r = n.shift(), i--), r && ("fx" === t && n.unshift("inprogress"), delete o.stop, r.call(e, (function () {
                        T.dequeue(e, t)
                    }), o)), !i && o && o.empty.fire()
                },
                _queueHooks: function (e, t) {
                    var n = t + "queueHooks";
                    return Q.get(e, n) || Q.access(e, n, {
                        empty: T.Callbacks("once memory").add((function () {
                            Q.remove(e, [t + "queue", n])
                        }))
                    })
                }
            }), T.fn.extend({
                queue: function (e, t) {
                    var n = 2;
                    return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? T.queue(this[0], e) : void 0 === t ? this : this.each((function () {
                        var n = T.queue(this, e, t);
                        T._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && T.dequeue(this, e)
                    }))
                },
                dequeue: function (e) {
                    return this.each((function () {
                        T.dequeue(this, e)
                    }))
                },
                clearQueue: function (e) {
                    return this.queue(e || "fx", [])
                },
                promise: function (e, t) {
                    var n, i = 1,
                        r = T.Deferred(),
                        o = this,
                        a = this.length,
                        s = function () {
                            --i || r.resolveWith(o, [o])
                        };
                    for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; a--;)(n = Q.get(o[a], e + "queueHooks")) && n.empty && (i++, n.empty.add(s));
                    return s(), r.promise(t)
                }
            });
            var ie = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
                re = new RegExp("^(?:([+-])=|)(" + ie + ")([a-z%]*)$", "i"),
                oe = ["Top", "Right", "Bottom", "Left"],
                ae = x.documentElement,
                se = function (e) {
                    return T.contains(e.ownerDocument, e)
                },
                le = {
                    composed: !0
                };
            ae.getRootNode && (se = function (e) {
                return T.contains(e.ownerDocument, e) || e.getRootNode(le) === e.ownerDocument
            });
            var ce = function (e, t) {
                return "none" === (e = t || e).style.display || "" === e.style.display && se(e) && "none" === T.css(e, "display")
            };

            function ue(e, t, n, i) {
                var r, o, a = 20,
                    s = i ? function () {
                        return i.cur()
                    } : function () {
                        return T.css(e, t, "")
                    },
                    l = s(),
                    c = n && n[3] || (T.cssNumber[t] ? "" : "px"),
                    u = e.nodeType && (T.cssNumber[t] || "px" !== c && +l) && re.exec(T.css(e, t));
                if (u && u[3] !== c) {
                    for (l /= 2, c = c || u[3], u = +l || 1; a--;) T.style(e, t, u + c), (1 - o) * (1 - (o = s() / l || .5)) <= 0 && (a = 0), u /= o;
                    u *= 2, T.style(e, t, u + c), n = n || []
                }
                return n && (u = +u || +l || 0, r = n[1] ? u + (n[1] + 1) * n[2] : +n[2], i && (i.unit = c, i.start = u, i.end = r)), r
            }
            var he = {};

            function de(e) {
                var t, n = e.ownerDocument,
                    i = e.nodeName,
                    r = he[i];
                return r || (t = n.body.appendChild(n.createElement(i)), r = T.css(t, "display"), t.parentNode.removeChild(t), "none" === r && (r = "block"), he[i] = r, r)
            }

            function pe(e, t) {
                for (var n, i, r = [], o = 0, a = e.length; o < a; o++)(i = e[o]).style && (n = i.style.display, t ? ("none" === n && (r[o] = Q.get(i, "display") || null, r[o] || (i.style.display = "")), "" === i.style.display && ce(i) && (r[o] = de(i))) : "none" !== n && (r[o] = "none", Q.set(i, "display", n)));
                for (o = 0; o < a; o++) null != r[o] && (e[o].style.display = r[o]);
                return e
            }
            T.fn.extend({
                show: function () {
                    return pe(this, !0)
                },
                hide: function () {
                    return pe(this)
                },
                toggle: function (e) {
                    return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each((function () {
                        ce(this) ? T(this).show() : T(this).hide()
                    }))
                }
            });
            var fe, me, ge = /^(?:checkbox|radio)$/i,
                ve = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
                ye = /^$|^module$|\/(?:java|ecma)script/i;
            fe = x.createDocumentFragment().appendChild(x.createElement("div")), (me = x.createElement("input")).setAttribute("type", "radio"), me.setAttribute("checked", "checked"), me.setAttribute("name", "t"), fe.appendChild(me), g.checkClone = fe.cloneNode(!0).cloneNode(!0).lastChild.checked, fe.innerHTML = "<textarea>x</textarea>", g.noCloneChecked = !!fe.cloneNode(!0).lastChild.defaultValue, fe.innerHTML = "<option></option>", g.option = !!fe.lastChild;
            var xe = {
                thead: [1, "<table>", "</table>"],
                col: [2, "<table><colgroup>", "</colgroup></table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                _default: [0, "", ""]
            };

            function we(e, t) {
                var n;
                return n = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && P(e, t) ? T.merge([e], n) : n
            }

            function be(e, t) {
                for (var n = 0, i = e.length; n < i; n++) Q.set(e[n], "globalEval", !t || Q.get(t[n], "globalEval"))
            }
            xe.tbody = xe.tfoot = xe.colgroup = xe.caption = xe.thead, xe.th = xe.td, g.option || (xe.optgroup = xe.option = [1, "<select multiple='multiple'>", "</select>"]);
            var _e = /<|&#?\w+;/;

            function Me(e, t, n, i, r) {
                for (var o, a, s, l, c, u, h = t.createDocumentFragment(), d = [], p = 0, f = e.length; p < f; p++)
                    if ((o = e[p]) || 0 === o)
                        if ("object" === _(o)) T.merge(d, o.nodeType ? [o] : o);
                        else if (_e.test(o)) {
                            for (a = a || h.appendChild(t.createElement("div")), s = (ve.exec(o) || ["", ""])[1].toLowerCase(), l = xe[s] || xe._default, a.innerHTML = l[1] + T.htmlPrefilter(o) + l[2], u = l[0]; u--;) a = a.lastChild;
                            T.merge(d, a.childNodes), (a = h.firstChild).textContent = ""
                        } else d.push(t.createTextNode(o));
                for (h.textContent = "", p = 0; o = d[p++];)
                    if (i && T.inArray(o, i) > -1) r && r.push(o);
                    else if (c = se(o), a = we(h.appendChild(o), "script"), c && be(a), n)
                        for (u = 0; o = a[u++];) ye.test(o.type || "") && n.push(o);
                return h
            }
            var Te = /^([^.]*)(?:\.(.+)|)/;

            function Se() {
                return !0
            }

            function Ee() {
                return !1
            }

            function Ae(e, t) {
                return e === function () {
                    try {
                        return x.activeElement
                    } catch (e) { }
                }() == ("focus" === t)
            }

            function Ce(e, t, n, i, r, o) {
                var a, s;
                if ("object" == typeof t) {
                    for (s in "string" != typeof n && (i = i || n, n = void 0), t) Ce(e, s, n, i, t[s], o);
                    return e
                }
                if (null == i && null == r ? (r = n, i = n = void 0) : null == r && ("string" == typeof n ? (r = i, i = void 0) : (r = i, i = n, n = void 0)), !1 === r) r = Ee;
                else if (!r) return e;
                return 1 === o && (a = r, (r = function (e) {
                    return T().off(e), a.apply(this, arguments)
                }).guid = a.guid || (a.guid = T.guid++)), e.each((function () {
                    T.event.add(this, t, r, i, n)
                }))
            }

            function Le(e, t, n) {
                n ? (Q.set(e, t, !1), T.event.add(e, t, {
                    namespace: !1,
                    handler: function (e) {
                        var i, r, o = Q.get(this, t);
                        if (1 & e.isTrigger && this[t]) {
                            if (o.length) (T.event.special[t] || {}).delegateType && e.stopPropagation();
                            else if (o = s.call(arguments), Q.set(this, t, o), i = n(this, t), this[t](), o !== (r = Q.get(this, t)) || i ? Q.set(this, t, !1) : r = {}, o !== r) return e.stopImmediatePropagation(), e.preventDefault(), r && r.value
                        } else o.length && (Q.set(this, t, {
                            value: T.event.trigger(T.extend(o[0], T.Event.prototype), o.slice(1), this)
                        }), e.stopImmediatePropagation())
                    }
                })) : void 0 === Q.get(e, t) && T.event.add(e, t, Se)
            }
            T.event = {
                global: {},
                add: function (e, t, n, i, r) {
                    var o, a, s, l, c, u, h, d, p, f, m, g = Q.get(e);
                    if (Z(e))
                        for (n.handler && (n = (o = n).handler, r = o.selector), r && T.find.matchesSelector(ae, r), n.guid || (n.guid = T.guid++), (l = g.events) || (l = g.events = Object.create(null)), (a = g.handle) || (a = g.handle = function (t) {
                            return void 0 !== T && T.event.triggered !== t.type ? T.event.dispatch.apply(e, arguments) : void 0
                        }), c = (t = (t || "").match(F) || [""]).length; c--;) p = m = (s = Te.exec(t[c]) || [])[1], f = (s[2] || "").split(".").sort(), p && (h = T.event.special[p] || {}, p = (r ? h.delegateType : h.bindType) || p, h = T.event.special[p] || {}, u = T.extend({
                            type: p,
                            origType: m,
                            data: i,
                            handler: n,
                            guid: n.guid,
                            selector: r,
                            needsContext: r && T.expr.match.needsContext.test(r),
                            namespace: f.join(".")
                        }, o), (d = l[p]) || ((d = l[p] = []).delegateCount = 0, h.setup && !1 !== h.setup.call(e, i, f, a) || e.addEventListener && e.addEventListener(p, a)), h.add && (h.add.call(e, u), u.handler.guid || (u.handler.guid = n.guid)), r ? d.splice(d.delegateCount++, 0, u) : d.push(u), T.event.global[p] = !0)
                },
                remove: function (e, t, n, i, r) {
                    var o, a, s, l, c, u, h, d, p, f, m, g = Q.hasData(e) && Q.get(e);
                    if (g && (l = g.events)) {
                        for (c = (t = (t || "").match(F) || [""]).length; c--;)
                            if (p = m = (s = Te.exec(t[c]) || [])[1], f = (s[2] || "").split(".").sort(), p) {
                                for (h = T.event.special[p] || {}, d = l[p = (i ? h.delegateType : h.bindType) || p] || [], s = s[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = d.length; o--;) u = d[o], !r && m !== u.origType || n && n.guid !== u.guid || s && !s.test(u.namespace) || i && i !== u.selector && ("**" !== i || !u.selector) || (d.splice(o, 1), u.selector && d.delegateCount--, h.remove && h.remove.call(e, u));
                                a && !d.length && (h.teardown && !1 !== h.teardown.call(e, f, g.handle) || T.removeEvent(e, p, g.handle), delete l[p])
                            } else
                                for (p in l) T.event.remove(e, p + t[c], n, i, !0);
                        T.isEmptyObject(l) && Q.remove(e, "handle events")
                    }
                },
                dispatch: function (e) {
                    var t, n, i, r, o, a, s = new Array(arguments.length),
                        l = T.event.fix(e),
                        c = (Q.get(this, "events") || Object.create(null))[l.type] || [],
                        u = T.event.special[l.type] || {};
                    for (s[0] = l, t = 1; t < arguments.length; t++) s[t] = arguments[t];
                    if (l.delegateTarget = this, !u.preDispatch || !1 !== u.preDispatch.call(this, l)) {
                        for (a = T.event.handlers.call(this, l, c), t = 0;
                            (r = a[t++]) && !l.isPropagationStopped();)
                            for (l.currentTarget = r.elem, n = 0;
                                (o = r.handlers[n++]) && !l.isImmediatePropagationStopped();) l.rnamespace && !1 !== o.namespace && !l.rnamespace.test(o.namespace) || (l.handleObj = o, l.data = o.data, void 0 !== (i = ((T.event.special[o.origType] || {}).handle || o.handler).apply(r.elem, s)) && !1 === (l.result = i) && (l.preventDefault(), l.stopPropagation()));
                        return u.postDispatch && u.postDispatch.call(this, l), l.result
                    }
                },
                handlers: function (e, t) {
                    var n, i, r, o, a, s = [],
                        l = t.delegateCount,
                        c = e.target;
                    if (l && c.nodeType && !("click" === e.type && e.button >= 1))
                        for (; c !== this; c = c.parentNode || this)
                            if (1 === c.nodeType && ("click" !== e.type || !0 !== c.disabled)) {
                                for (o = [], a = {}, n = 0; n < l; n++) void 0 === a[r = (i = t[n]).selector + " "] && (a[r] = i.needsContext ? T(r, this).index(c) > -1 : T.find(r, this, null, [c]).length), a[r] && o.push(i);
                                o.length && s.push({
                                    elem: c,
                                    handlers: o
                                })
                            }
                    return c = this, l < t.length && s.push({
                        elem: c,
                        handlers: t.slice(l)
                    }), s
                },
                addProp: function (e, t) {
                    Object.defineProperty(T.Event.prototype, e, {
                        enumerable: !0,
                        configurable: !0,
                        get: v(t) ? function () {
                            if (this.originalEvent) return t(this.originalEvent)
                        } : function () {
                            if (this.originalEvent) return this.originalEvent[e]
                        },
                        set: function (t) {
                            Object.defineProperty(this, e, {
                                enumerable: !0,
                                configurable: !0,
                                writable: !0,
                                value: t
                            })
                        }
                    })
                },
                fix: function (e) {
                    return e[T.expando] ? e : new T.Event(e)
                },
                special: {
                    load: {
                        noBubble: !0
                    },
                    click: {
                        setup: function (e) {
                            var t = this || e;
                            return ge.test(t.type) && t.click && P(t, "input") && Le(t, "click", Se), !1
                        },
                        trigger: function (e) {
                            var t = this || e;
                            return ge.test(t.type) && t.click && P(t, "input") && Le(t, "click"), !0
                        },
                        _default: function (e) {
                            var t = e.target;
                            return ge.test(t.type) && t.click && P(t, "input") && Q.get(t, "click") || P(t, "a")
                        }
                    },
                    beforeunload: {
                        postDispatch: function (e) {
                            void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
                        }
                    }
                }
            }, T.removeEvent = function (e, t, n) {
                e.removeEventListener && e.removeEventListener(t, n)
            }, T.Event = function (e, t) {
                if (!(this instanceof T.Event)) return new T.Event(e, t);
                e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Se : Ee, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && T.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[T.expando] = !0
            }, T.Event.prototype = {
                constructor: T.Event,
                isDefaultPrevented: Ee,
                isPropagationStopped: Ee,
                isImmediatePropagationStopped: Ee,
                isSimulated: !1,
                preventDefault: function () {
                    var e = this.originalEvent;
                    this.isDefaultPrevented = Se, e && !this.isSimulated && e.preventDefault()
                },
                stopPropagation: function () {
                    var e = this.originalEvent;
                    this.isPropagationStopped = Se, e && !this.isSimulated && e.stopPropagation()
                },
                stopImmediatePropagation: function () {
                    var e = this.originalEvent;
                    this.isImmediatePropagationStopped = Se, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
                }
            }, T.each({
                altKey: !0,
                bubbles: !0,
                cancelable: !0,
                changedTouches: !0,
                ctrlKey: !0,
                detail: !0,
                eventPhase: !0,
                metaKey: !0,
                pageX: !0,
                pageY: !0,
                shiftKey: !0,
                view: !0,
                char: !0,
                code: !0,
                charCode: !0,
                key: !0,
                keyCode: !0,
                button: !0,
                buttons: !0,
                clientX: !0,
                clientY: !0,
                offsetX: !0,
                offsetY: !0,
                pointerId: !0,
                pointerType: !0,
                screenX: !0,
                screenY: !0,
                targetTouches: !0,
                toElement: !0,
                touches: !0,
                which: !0
            }, T.event.addProp), T.each({
                focus: "focusin",
                blur: "focusout"
            }, (function (e, t) {
                T.event.special[e] = {
                    setup: function () {
                        return Le(this, e, Ae), !1
                    },
                    trigger: function () {
                        return Le(this, e), !0
                    },
                    _default: function () {
                        return !0
                    },
                    delegateType: t
                }
            })), T.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, (function (e, t) {
                T.event.special[e] = {
                    delegateType: t,
                    bindType: t,
                    handle: function (e) {
                        var n, i = this,
                            r = e.relatedTarget,
                            o = e.handleObj;
                        return r && (r === i || T.contains(i, r)) || (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n
                    }
                }
            })), T.fn.extend({
                on: function (e, t, n, i) {
                    return Ce(this, e, t, n, i)
                },
                one: function (e, t, n, i) {
                    return Ce(this, e, t, n, i, 1)
                },
                off: function (e, t, n) {
                    var i, r;
                    if (e && e.preventDefault && e.handleObj) return i = e.handleObj, T(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this;
                    if ("object" == typeof e) {
                        for (r in e) this.off(r, t, e[r]);
                        return this
                    }
                    return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Ee), this.each((function () {
                        T.event.remove(this, e, n, t)
                    }))
                }
            });
            var Pe = /<script|<style|<link/i,
                Re = /checked\s*(?:[^=]|=\s*.checked.)/i,
                Oe = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

            function De(e, t) {
                return P(e, "table") && P(11 !== t.nodeType ? t : t.firstChild, "tr") && T(e).children("tbody")[0] || e
            }

            function ke(e) {
                return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
            }

            function Ne(e) {
                return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e
            }

            function Ie(e, t) {
                var n, i, r, o, a, s;
                if (1 === t.nodeType) {
                    if (Q.hasData(e) && (s = Q.get(e).events))
                        for (r in Q.remove(t, "handle events"), s)
                            for (n = 0, i = s[r].length; n < i; n++) T.event.add(t, r, s[r][n]);
                    K.hasData(e) && (o = K.access(e), a = T.extend({}, o), K.set(t, a))
                }
            }

            function ze(e, t) {
                var n = t.nodeName.toLowerCase();
                "input" === n && ge.test(e.type) ? t.checked = e.checked : "input" !== n && "textarea" !== n || (t.defaultValue = e.defaultValue)
            }

            function Fe(e, t, n, i) {
                t = l(t);
                var r, o, a, s, c, u, h = 0,
                    d = e.length,
                    p = d - 1,
                    f = t[0],
                    m = v(f);
                if (m || d > 1 && "string" == typeof f && !g.checkClone && Re.test(f)) return e.each((function (r) {
                    var o = e.eq(r);
                    m && (t[0] = f.call(this, r, o.html())), Fe(o, t, n, i)
                }));
                if (d && (o = (r = Me(t, e[0].ownerDocument, !1, e, i)).firstChild, 1 === r.childNodes.length && (r = o), o || i)) {
                    for (s = (a = T.map(we(r, "script"), ke)).length; h < d; h++) c = r, h !== p && (c = T.clone(c, !0, !0), s && T.merge(a, we(c, "script"))), n.call(e[h], c, h);
                    if (s)
                        for (u = a[a.length - 1].ownerDocument, T.map(a, Ne), h = 0; h < s; h++) c = a[h], ye.test(c.type || "") && !Q.access(c, "globalEval") && T.contains(u, c) && (c.src && "module" !== (c.type || "").toLowerCase() ? T._evalUrl && !c.noModule && T._evalUrl(c.src, {
                            nonce: c.nonce || c.getAttribute("nonce")
                        }, u) : b(c.textContent.replace(Oe, ""), c, u))
                }
                return e
            }

            function He(e, t, n) {
                for (var i, r = t ? T.filter(t, e) : e, o = 0; null != (i = r[o]); o++) n || 1 !== i.nodeType || T.cleanData(we(i)), i.parentNode && (n && se(i) && be(we(i, "script")), i.parentNode.removeChild(i));
                return e
            }
            T.extend({
                htmlPrefilter: function (e) {
                    return e
                },
                clone: function (e, t, n) {
                    var i, r, o, a, s = e.cloneNode(!0),
                        l = se(e);
                    if (!(g.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || T.isXMLDoc(e)))
                        for (a = we(s), i = 0, r = (o = we(e)).length; i < r; i++) ze(o[i], a[i]);
                    if (t)
                        if (n)
                            for (o = o || we(e), a = a || we(s), i = 0, r = o.length; i < r; i++) Ie(o[i], a[i]);
                        else Ie(e, s);
                    return (a = we(s, "script")).length > 0 && be(a, !l && we(e, "script")), s
                },
                cleanData: function (e) {
                    for (var t, n, i, r = T.event.special, o = 0; void 0 !== (n = e[o]); o++)
                        if (Z(n)) {
                            if (t = n[Q.expando]) {
                                if (t.events)
                                    for (i in t.events) r[i] ? T.event.remove(n, i) : T.removeEvent(n, i, t.handle);
                                n[Q.expando] = void 0
                            }
                            n[K.expando] && (n[K.expando] = void 0)
                        }
                }
            }), T.fn.extend({
                detach: function (e) {
                    return He(this, e, !0)
                },
                remove: function (e) {
                    return He(this, e)
                },
                text: function (e) {
                    return W(this, (function (e) {
                        return void 0 === e ? T.text(this) : this.empty().each((function () {
                            1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
                        }))
                    }), null, e, arguments.length)
                },
                append: function () {
                    return Fe(this, arguments, (function (e) {
                        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || De(this, e).appendChild(e)
                    }))
                },
                prepend: function () {
                    return Fe(this, arguments, (function (e) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var t = De(this, e);
                            t.insertBefore(e, t.firstChild)
                        }
                    }))
                },
                before: function () {
                    return Fe(this, arguments, (function (e) {
                        this.parentNode && this.parentNode.insertBefore(e, this)
                    }))
                },
                after: function () {
                    return Fe(this, arguments, (function (e) {
                        this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
                    }))
                },
                empty: function () {
                    for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (T.cleanData(we(e, !1)), e.textContent = "");
                    return this
                },
                clone: function (e, t) {
                    return e = null != e && e, t = null == t ? e : t, this.map((function () {
                        return T.clone(this, e, t)
                    }))
                },
                html: function (e) {
                    return W(this, (function (e) {
                        var t = this[0] || {},
                            n = 0,
                            i = this.length;
                        if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                        if ("string" == typeof e && !Pe.test(e) && !xe[(ve.exec(e) || ["", ""])[1].toLowerCase()]) {
                            e = T.htmlPrefilter(e);
                            try {
                                for (; n < i; n++) 1 === (t = this[n] || {}).nodeType && (T.cleanData(we(t, !1)), t.innerHTML = e);
                                t = 0
                            } catch (e) { }
                        }
                        t && this.empty().append(e)
                    }), null, e, arguments.length)
                },
                replaceWith: function () {
                    var e = [];
                    return Fe(this, arguments, (function (t) {
                        var n = this.parentNode;
                        T.inArray(this, e) < 0 && (T.cleanData(we(this)), n && n.replaceChild(t, this))
                    }), e)
                }
            }), T.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, (function (e, t) {
                T.fn[e] = function (e) {
                    for (var n, i = [], r = T(e), o = r.length - 1, a = 0; a <= o; a++) n = a === o ? this : this.clone(!0), T(r[a])[t](n), c.apply(i, n.get());
                    return this.pushStack(i)
                }
            }));
            var Be = new RegExp("^(" + ie + ")(?!px)[a-z%]+$", "i"),
                Ue = function (e) {
                    var t = e.ownerDocument.defaultView;
                    return t && t.opener || (t = n), t.getComputedStyle(e)
                },
                je = function (e, t, n) {
                    var i, r, o = {};
                    for (r in t) o[r] = e.style[r], e.style[r] = t[r];
                    for (r in i = n.call(e), t) e.style[r] = o[r];
                    return i
                },
                Ge = new RegExp(oe.join("|"), "i");

            function Ve(e, t, n) {
                var i, r, o, a, s = e.style;
                return (n = n || Ue(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || se(e) || (a = T.style(e, t)), !g.pixelBoxStyles() && Be.test(a) && Ge.test(t) && (i = s.width, r = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = i, s.minWidth = r, s.maxWidth = o)), void 0 !== a ? a + "" : a
            }

            function We(e, t) {
                return {
                    get: function () {
                        if (!e()) return (this.get = t).apply(this, arguments);
                        delete this.get
                    }
                }
            } ! function () {
                function e() {
                    if (u) {
                        c.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", u.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", ae.appendChild(c).appendChild(u);
                        var e = n.getComputedStyle(u);
                        i = "1%" !== e.top, l = 12 === t(e.marginLeft), u.style.right = "60%", a = 36 === t(e.right), r = 36 === t(e.width), u.style.position = "absolute", o = 12 === t(u.offsetWidth / 3), ae.removeChild(c), u = null
                    }
                }

                function t(e) {
                    return Math.round(parseFloat(e))
                }
                var i, r, o, a, s, l, c = x.createElement("div"),
                    u = x.createElement("div");
                u.style && (u.style.backgroundClip = "content-box", u.cloneNode(!0).style.backgroundClip = "", g.clearCloneStyle = "content-box" === u.style.backgroundClip, T.extend(g, {
                    boxSizingReliable: function () {
                        return e(), r
                    },
                    pixelBoxStyles: function () {
                        return e(), a
                    },
                    pixelPosition: function () {
                        return e(), i
                    },
                    reliableMarginLeft: function () {
                        return e(), l
                    },
                    scrollboxSize: function () {
                        return e(), o
                    },
                    reliableTrDimensions: function () {
                        var e, t, i, r;
                        return null == s && (e = x.createElement("table"), t = x.createElement("tr"), i = x.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", i.style.height = "9px", i.style.display = "block", ae.appendChild(e).appendChild(t).appendChild(i), r = n.getComputedStyle(t), s = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === t.offsetHeight, ae.removeChild(e)), s
                    }
                }))
            }();
            var qe = ["Webkit", "Moz", "ms"],
                $e = x.createElement("div").style,
                Xe = {};

            function Ye(e) {
                var t = T.cssProps[e] || Xe[e];
                return t || (e in $e ? e : Xe[e] = function (e) {
                    for (var t = e[0].toUpperCase() + e.slice(1), n = qe.length; n--;)
                        if ((e = qe[n] + t) in $e) return e
                }(e) || e)
            }
            var Ze = /^(none|table(?!-c[ea]).+)/,
                Je = /^--/,
                Qe = {
                    position: "absolute",
                    visibility: "hidden",
                    display: "block"
                },
                Ke = {
                    letterSpacing: "0",
                    fontWeight: "400"
                };

            function et(e, t, n) {
                var i = re.exec(t);
                return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || "px") : t
            }

            function tt(e, t, n, i, r, o) {
                var a = "width" === t ? 1 : 0,
                    s = 0,
                    l = 0;
                if (n === (i ? "border" : "content")) return 0;
                for (; a < 4; a += 2) "margin" === n && (l += T.css(e, n + oe[a], !0, r)), i ? ("content" === n && (l -= T.css(e, "padding" + oe[a], !0, r)), "margin" !== n && (l -= T.css(e, "border" + oe[a] + "Width", !0, r))) : (l += T.css(e, "padding" + oe[a], !0, r), "padding" !== n ? l += T.css(e, "border" + oe[a] + "Width", !0, r) : s += T.css(e, "border" + oe[a] + "Width", !0, r));
                return !i && o >= 0 && (l += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - l - s - .5)) || 0), l
            }

            function nt(e, t, n) {
                var i = Ue(e),
                    r = (!g.boxSizingReliable() || n) && "border-box" === T.css(e, "boxSizing", !1, i),
                    o = r,
                    a = Ve(e, t, i),
                    s = "offset" + t[0].toUpperCase() + t.slice(1);
                if (Be.test(a)) {
                    if (!n) return a;
                    a = "auto"
                }
                return (!g.boxSizingReliable() && r || !g.reliableTrDimensions() && P(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === T.css(e, "display", !1, i)) && e.getClientRects().length && (r = "border-box" === T.css(e, "boxSizing", !1, i), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + tt(e, t, n || (r ? "border" : "content"), o, i, a) + "px"
            }

            function it(e, t, n, i, r) {
                return new it.prototype.init(e, t, n, i, r)
            }
            T.extend({
                cssHooks: {
                    opacity: {
                        get: function (e, t) {
                            if (t) {
                                var n = Ve(e, "opacity");
                                return "" === n ? "1" : n
                            }
                        }
                    }
                },
                cssNumber: {
                    animationIterationCount: !0,
                    columnCount: !0,
                    fillOpacity: !0,
                    flexGrow: !0,
                    flexShrink: !0,
                    fontWeight: !0,
                    gridArea: !0,
                    gridColumn: !0,
                    gridColumnEnd: !0,
                    gridColumnStart: !0,
                    gridRow: !0,
                    gridRowEnd: !0,
                    gridRowStart: !0,
                    lineHeight: !0,
                    opacity: !0,
                    order: !0,
                    orphans: !0,
                    widows: !0,
                    zIndex: !0,
                    zoom: !0
                },
                cssProps: {},
                style: function (e, t, n, i) {
                    if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                        var r, o, a, s = Y(t),
                            l = Je.test(t),
                            c = e.style;
                        if (l || (t = Ye(s)), a = T.cssHooks[t] || T.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (r = a.get(e, !1, i)) ? r : c[t];
                        "string" === (o = typeof n) && (r = re.exec(n)) && r[1] && (n = ue(e, t, r), o = "number"), null != n && n == n && ("number" !== o || l || (n += r && r[3] || (T.cssNumber[s] ? "" : "px")), g.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (c[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, i)) || (l ? c.setProperty(t, n) : c[t] = n))
                    }
                },
                css: function (e, t, n, i) {
                    var r, o, a, s = Y(t);
                    return Je.test(t) || (t = Ye(s)), (a = T.cssHooks[t] || T.cssHooks[s]) && "get" in a && (r = a.get(e, !0, n)), void 0 === r && (r = Ve(e, t, i)), "normal" === r && t in Ke && (r = Ke[t]), "" === n || n ? (o = parseFloat(r), !0 === n || isFinite(o) ? o || 0 : r) : r
                }
            }), T.each(["height", "width"], (function (e, t) {
                T.cssHooks[t] = {
                    get: function (e, n, i) {
                        if (n) return !Ze.test(T.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? nt(e, t, i) : je(e, Qe, (function () {
                            return nt(e, t, i)
                        }))
                    },
                    set: function (e, n, i) {
                        var r, o = Ue(e),
                            a = !g.scrollboxSize() && "absolute" === o.position,
                            s = (a || i) && "border-box" === T.css(e, "boxSizing", !1, o),
                            l = i ? tt(e, t, i, s, o) : 0;
                        return s && a && (l -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(o[t]) - tt(e, t, "border", !1, o) - .5)), l && (r = re.exec(n)) && "px" !== (r[3] || "px") && (e.style[t] = n, n = T.css(e, t)), et(0, n, l)
                    }
                }
            })), T.cssHooks.marginLeft = We(g.reliableMarginLeft, (function (e, t) {
                if (t) return (parseFloat(Ve(e, "marginLeft")) || e.getBoundingClientRect().left - je(e, {
                    marginLeft: 0
                }, (function () {
                    return e.getBoundingClientRect().left
                }))) + "px"
            })), T.each({
                margin: "",
                padding: "",
                border: "Width"
            }, (function (e, t) {
                T.cssHooks[e + t] = {
                    expand: function (n) {
                        for (var i = 0, r = {}, o = "string" == typeof n ? n.split(" ") : [n]; i < 4; i++) r[e + oe[i] + t] = o[i] || o[i - 2] || o[0];
                        return r
                    }
                }, "margin" !== e && (T.cssHooks[e + t].set = et)
            })), T.fn.extend({
                css: function (e, t) {
                    return W(this, (function (e, t, n) {
                        var i, r, o = {},
                            a = 0;
                        if (Array.isArray(t)) {
                            for (i = Ue(e), r = t.length; a < r; a++) o[t[a]] = T.css(e, t[a], !1, i);
                            return o
                        }
                        return void 0 !== n ? T.style(e, t, n) : T.css(e, t)
                    }), e, t, arguments.length > 1)
                }
            }), T.Tween = it, it.prototype = {
                constructor: it,
                init: function (e, t, n, i, r, o) {
                    this.elem = e, this.prop = n, this.easing = r || T.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = i, this.unit = o || (T.cssNumber[n] ? "" : "px")
                },
                cur: function () {
                    var e = it.propHooks[this.prop];
                    return e && e.get ? e.get(this) : it.propHooks._default.get(this)
                },
                run: function (e) {
                    var t, n = it.propHooks[this.prop];
                    return this.options.duration ? this.pos = t = T.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : it.propHooks._default.set(this), this
                }
            }, it.prototype.init.prototype = it.prototype, it.propHooks = {
                _default: {
                    get: function (e) {
                        var t;
                        return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = T.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0
                    },
                    set: function (e) {
                        T.fx.step[e.prop] ? T.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !T.cssHooks[e.prop] && null == e.elem.style[Ye(e.prop)] ? e.elem[e.prop] = e.now : T.style(e.elem, e.prop, e.now + e.unit)
                    }
                }
            }, it.propHooks.scrollTop = it.propHooks.scrollLeft = {
                set: function (e) {
                    e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
                }
            }, T.easing = {
                linear: function (e) {
                    return e
                },
                swing: function (e) {
                    return .5 - Math.cos(e * Math.PI) / 2
                },
                _default: "swing"
            }, T.fx = it.prototype.init, T.fx.step = {};
            var rt, ot, at = /^(?:toggle|show|hide)$/,
                st = /queueHooks$/;

            function lt() {
                ot && (!1 === x.hidden && n.requestAnimationFrame ? n.requestAnimationFrame(lt) : n.setTimeout(lt, T.fx.interval), T.fx.tick())
            }

            function ct() {
                return n.setTimeout((function () {
                    rt = void 0
                })), rt = Date.now()
            }

            function ut(e, t) {
                var n, i = 0,
                    r = {
                        height: e
                    };
                for (t = t ? 1 : 0; i < 4; i += 2 - t) r["margin" + (n = oe[i])] = r["padding" + n] = e;
                return t && (r.opacity = r.width = e), r
            }

            function ht(e, t, n) {
                for (var i, r = (dt.tweeners[t] || []).concat(dt.tweeners["*"]), o = 0, a = r.length; o < a; o++)
                    if (i = r[o].call(n, t, e)) return i
            }

            function dt(e, t, n) {
                var i, r, o = 0,
                    a = dt.prefilters.length,
                    s = T.Deferred().always((function () {
                        delete l.elem
                    })),
                    l = function () {
                        if (r) return !1;
                        for (var t = rt || ct(), n = Math.max(0, c.startTime + c.duration - t), i = 1 - (n / c.duration || 0), o = 0, a = c.tweens.length; o < a; o++) c.tweens[o].run(i);
                        return s.notifyWith(e, [c, i, n]), i < 1 && a ? n : (a || s.notifyWith(e, [c, 1, 0]), s.resolveWith(e, [c]), !1)
                    },
                    c = s.promise({
                        elem: e,
                        props: T.extend({}, t),
                        opts: T.extend(!0, {
                            specialEasing: {},
                            easing: T.easing._default
                        }, n),
                        originalProperties: t,
                        originalOptions: n,
                        startTime: rt || ct(),
                        duration: n.duration,
                        tweens: [],
                        createTween: function (t, n) {
                            var i = T.Tween(e, c.opts, t, n, c.opts.specialEasing[t] || c.opts.easing);
                            return c.tweens.push(i), i
                        },
                        stop: function (t) {
                            var n = 0,
                                i = t ? c.tweens.length : 0;
                            if (r) return this;
                            for (r = !0; n < i; n++) c.tweens[n].run(1);
                            return t ? (s.notifyWith(e, [c, 1, 0]), s.resolveWith(e, [c, t])) : s.rejectWith(e, [c, t]), this
                        }
                    }),
                    u = c.props;
                for (! function (e, t) {
                    var n, i, r, o, a;
                    for (n in e)
                        if (r = t[i = Y(n)], o = e[n], Array.isArray(o) && (r = o[1], o = e[n] = o[0]), n !== i && (e[i] = o, delete e[n]), (a = T.cssHooks[i]) && "expand" in a)
                            for (n in o = a.expand(o), delete e[i], o) n in e || (e[n] = o[n], t[n] = r);
                        else t[i] = r
                }(u, c.opts.specialEasing); o < a; o++)
                    if (i = dt.prefilters[o].call(c, e, u, c.opts)) return v(i.stop) && (T._queueHooks(c.elem, c.opts.queue).stop = i.stop.bind(i)), i;
                return T.map(u, ht, c), v(c.opts.start) && c.opts.start.call(e, c), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), T.fx.timer(T.extend(l, {
                    elem: e,
                    anim: c,
                    queue: c.opts.queue
                })), c
            }
            T.Animation = T.extend(dt, {
                tweeners: {
                    "*": [function (e, t) {
                        var n = this.createTween(e, t);
                        return ue(n.elem, e, re.exec(t), n), n
                    }]
                },
                tweener: function (e, t) {
                    v(e) ? (t = e, e = ["*"]) : e = e.match(F);
                    for (var n, i = 0, r = e.length; i < r; i++) n = e[i], dt.tweeners[n] = dt.tweeners[n] || [], dt.tweeners[n].unshift(t)
                },
                prefilters: [function (e, t, n) {
                    var i, r, o, a, s, l, c, u, h = "width" in t || "height" in t,
                        d = this,
                        p = {},
                        f = e.style,
                        m = e.nodeType && ce(e),
                        g = Q.get(e, "fxshow");
                    for (i in n.queue || (null == (a = T._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () {
                        a.unqueued || s()
                    }), a.unqueued++, d.always((function () {
                        d.always((function () {
                            a.unqueued--, T.queue(e, "fx").length || a.empty.fire()
                        }))
                    }))), t)
                        if (r = t[i], at.test(r)) {
                            if (delete t[i], o = o || "toggle" === r, r === (m ? "hide" : "show")) {
                                if ("show" !== r || !g || void 0 === g[i]) continue;
                                m = !0
                            }
                            p[i] = g && g[i] || T.style(e, i)
                        }
                    if ((l = !T.isEmptyObject(t)) || !T.isEmptyObject(p))
                        for (i in h && 1 === e.nodeType && (n.overflow = [f.overflow, f.overflowX, f.overflowY], null == (c = g && g.display) && (c = Q.get(e, "display")), "none" === (u = T.css(e, "display")) && (c ? u = c : (pe([e], !0), c = e.style.display || c, u = T.css(e, "display"), pe([e]))), ("inline" === u || "inline-block" === u && null != c) && "none" === T.css(e, "float") && (l || (d.done((function () {
                            f.display = c
                        })), null == c && (u = f.display, c = "none" === u ? "" : u)), f.display = "inline-block")), n.overflow && (f.overflow = "hidden", d.always((function () {
                            f.overflow = n.overflow[0], f.overflowX = n.overflow[1], f.overflowY = n.overflow[2]
                        }))), l = !1, p) l || (g ? "hidden" in g && (m = g.hidden) : g = Q.access(e, "fxshow", {
                            display: c
                        }), o && (g.hidden = !m), m && pe([e], !0), d.done((function () {
                            for (i in m || pe([e]), Q.remove(e, "fxshow"), p) T.style(e, i, p[i])
                        }))), l = ht(m ? g[i] : 0, i, d), i in g || (g[i] = l.start, m && (l.end = l.start, l.start = 0))
                }],
                prefilter: function (e, t) {
                    t ? dt.prefilters.unshift(e) : dt.prefilters.push(e)
                }
            }), T.speed = function (e, t, n) {
                var i = e && "object" == typeof e ? T.extend({}, e) : {
                    complete: n || !n && t || v(e) && e,
                    duration: e,
                    easing: n && t || t && !v(t) && t
                };
                return T.fx.off ? i.duration = 0 : "number" != typeof i.duration && (i.duration in T.fx.speeds ? i.duration = T.fx.speeds[i.duration] : i.duration = T.fx.speeds._default), null != i.queue && !0 !== i.queue || (i.queue = "fx"), i.old = i.complete, i.complete = function () {
                    v(i.old) && i.old.call(this), i.queue && T.dequeue(this, i.queue)
                }, i
            }, T.fn.extend({
                fadeTo: function (e, t, n, i) {
                    return this.filter(ce).css("opacity", 0).show().end().animate({
                        opacity: t
                    }, e, n, i)
                },
                animate: function (e, t, n, i) {
                    var r = T.isEmptyObject(e),
                        o = T.speed(t, n, i),
                        a = function () {
                            var t = dt(this, T.extend({}, e), o);
                            (r || Q.get(this, "finish")) && t.stop(!0)
                        };
                    return a.finish = a, r || !1 === o.queue ? this.each(a) : this.queue(o.queue, a)
                },
                stop: function (e, t, n) {
                    var i = function (e) {
                        var t = e.stop;
                        delete e.stop, t(n)
                    };
                    return "string" != typeof e && (n = t, t = e, e = void 0), t && this.queue(e || "fx", []), this.each((function () {
                        var t = !0,
                            r = null != e && e + "queueHooks",
                            o = T.timers,
                            a = Q.get(this);
                        if (r) a[r] && a[r].stop && i(a[r]);
                        else
                            for (r in a) a[r] && a[r].stop && st.test(r) && i(a[r]);
                        for (r = o.length; r--;) o[r].elem !== this || null != e && o[r].queue !== e || (o[r].anim.stop(n), t = !1, o.splice(r, 1));
                        !t && n || T.dequeue(this, e)
                    }))
                },
                finish: function (e) {
                    return !1 !== e && (e = e || "fx"), this.each((function () {
                        var t, n = Q.get(this),
                            i = n[e + "queue"],
                            r = n[e + "queueHooks"],
                            o = T.timers,
                            a = i ? i.length : 0;
                        for (n.finish = !0, T.queue(this, e, []), r && r.stop && r.stop.call(this, !0), t = o.length; t--;) o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));
                        for (t = 0; t < a; t++) i[t] && i[t].finish && i[t].finish.call(this);
                        delete n.finish
                    }))
                }
            }), T.each(["toggle", "show", "hide"], (function (e, t) {
                var n = T.fn[t];
                T.fn[t] = function (e, i, r) {
                    return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(ut(t, !0), e, i, r)
                }
            })), T.each({
                slideDown: ut("show"),
                slideUp: ut("hide"),
                slideToggle: ut("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, (function (e, t) {
                T.fn[e] = function (e, n, i) {
                    return this.animate(t, e, n, i)
                }
            })), T.timers = [], T.fx.tick = function () {
                var e, t = 0,
                    n = T.timers;
                for (rt = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1);
                n.length || T.fx.stop(), rt = void 0
            }, T.fx.timer = function (e) {
                T.timers.push(e), T.fx.start()
            }, T.fx.interval = 13, T.fx.start = function () {
                ot || (ot = !0, lt())
            }, T.fx.stop = function () {
                ot = null
            }, T.fx.speeds = {
                slow: 600,
                fast: 200,
                _default: 400
            }, T.fn.delay = function (e, t) {
                return e = T.fx && T.fx.speeds[e] || e, t = t || "fx", this.queue(t, (function (t, i) {
                    var r = n.setTimeout(t, e);
                    i.stop = function () {
                        n.clearTimeout(r)
                    }
                }))
            },
                function () {
                    var e = x.createElement("input"),
                        t = x.createElement("select").appendChild(x.createElement("option"));
                    e.type = "checkbox", g.checkOn = "" !== e.value, g.optSelected = t.selected, (e = x.createElement("input")).value = "t", e.type = "radio", g.radioValue = "t" === e.value
                }();
            var pt, ft = T.expr.attrHandle;
            T.fn.extend({
                attr: function (e, t) {
                    return W(this, T.attr, e, t, arguments.length > 1)
                },
                removeAttr: function (e) {
                    return this.each((function () {
                        T.removeAttr(this, e)
                    }))
                }
            }), T.extend({
                attr: function (e, t, n) {
                    var i, r, o = e.nodeType;
                    if (3 !== o && 8 !== o && 2 !== o) return void 0 === e.getAttribute ? T.prop(e, t, n) : (1 === o && T.isXMLDoc(e) || (r = T.attrHooks[t.toLowerCase()] || (T.expr.match.bool.test(t) ? pt : void 0)), void 0 !== n ? null === n ? void T.removeAttr(e, t) : r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : (e.setAttribute(t, n + ""), n) : r && "get" in r && null !== (i = r.get(e, t)) ? i : null == (i = T.find.attr(e, t)) ? void 0 : i)
                },
                attrHooks: {
                    type: {
                        set: function (e, t) {
                            if (!g.radioValue && "radio" === t && P(e, "input")) {
                                var n = e.value;
                                return e.setAttribute("type", t), n && (e.value = n), t
                            }
                        }
                    }
                },
                removeAttr: function (e, t) {
                    var n, i = 0,
                        r = t && t.match(F);
                    if (r && 1 === e.nodeType)
                        for (; n = r[i++];) e.removeAttribute(n)
                }
            }), pt = {
                set: function (e, t, n) {
                    return !1 === t ? T.removeAttr(e, n) : e.setAttribute(n, n), n
                }
            }, T.each(T.expr.match.bool.source.match(/\w+/g), (function (e, t) {
                var n = ft[t] || T.find.attr;
                ft[t] = function (e, t, i) {
                    var r, o, a = t.toLowerCase();
                    return i || (o = ft[a], ft[a] = r, r = null != n(e, t, i) ? a : null, ft[a] = o), r
                }
            }));
            var mt = /^(?:input|select|textarea|button)$/i,
                gt = /^(?:a|area)$/i;

            function vt(e) {
                return (e.match(F) || []).join(" ")
            }

            function yt(e) {
                return e.getAttribute && e.getAttribute("class") || ""
            }

            function xt(e) {
                return Array.isArray(e) ? e : "string" == typeof e && e.match(F) || []
            }
            T.fn.extend({
                prop: function (e, t) {
                    return W(this, T.prop, e, t, arguments.length > 1)
                },
                removeProp: function (e) {
                    return this.each((function () {
                        delete this[T.propFix[e] || e]
                    }))
                }
            }), T.extend({
                prop: function (e, t, n) {
                    var i, r, o = e.nodeType;
                    if (3 !== o && 8 !== o && 2 !== o) return 1 === o && T.isXMLDoc(e) || (t = T.propFix[t] || t, r = T.propHooks[t]), void 0 !== n ? r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : e[t] = n : r && "get" in r && null !== (i = r.get(e, t)) ? i : e[t]
                },
                propHooks: {
                    tabIndex: {
                        get: function (e) {
                            var t = T.find.attr(e, "tabindex");
                            return t ? parseInt(t, 10) : mt.test(e.nodeName) || gt.test(e.nodeName) && e.href ? 0 : -1
                        }
                    }
                },
                propFix: {
                    for: "htmlFor",
                    class: "className"
                }
            }), g.optSelected || (T.propHooks.selected = {
                get: function (e) {
                    var t = e.parentNode;
                    return t && t.parentNode && t.parentNode.selectedIndex, null
                },
                set: function (e) {
                    var t = e.parentNode;
                    t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
                }
            }), T.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function () {
                T.propFix[this.toLowerCase()] = this
            })), T.fn.extend({
                addClass: function (e) {
                    var t, n, i, r, o, a, s, l = 0;
                    if (v(e)) return this.each((function (t) {
                        T(this).addClass(e.call(this, t, yt(this)))
                    }));
                    if ((t = xt(e)).length)
                        for (; n = this[l++];)
                            if (r = yt(n), i = 1 === n.nodeType && " " + vt(r) + " ") {
                                for (a = 0; o = t[a++];) i.indexOf(" " + o + " ") < 0 && (i += o + " ");
                                r !== (s = vt(i)) && n.setAttribute("class", s)
                            }
                    return this
                },
                removeClass: function (e) {
                    var t, n, i, r, o, a, s, l = 0;
                    if (v(e)) return this.each((function (t) {
                        T(this).removeClass(e.call(this, t, yt(this)))
                    }));
                    if (!arguments.length) return this.attr("class", "");
                    if ((t = xt(e)).length)
                        for (; n = this[l++];)
                            if (r = yt(n), i = 1 === n.nodeType && " " + vt(r) + " ") {
                                for (a = 0; o = t[a++];)
                                    for (; i.indexOf(" " + o + " ") > -1;) i = i.replace(" " + o + " ", " ");
                                r !== (s = vt(i)) && n.setAttribute("class", s)
                            }
                    return this
                },
                toggleClass: function (e, t) {
                    var n = typeof e,
                        i = "string" === n || Array.isArray(e);
                    return "boolean" == typeof t && i ? t ? this.addClass(e) : this.removeClass(e) : v(e) ? this.each((function (n) {
                        T(this).toggleClass(e.call(this, n, yt(this), t), t)
                    })) : this.each((function () {
                        var t, r, o, a;
                        if (i)
                            for (r = 0, o = T(this), a = xt(e); t = a[r++];) o.hasClass(t) ? o.removeClass(t) : o.addClass(t);
                        else void 0 !== e && "boolean" !== n || ((t = yt(this)) && Q.set(this, "__className__", t), this.setAttribute && this.setAttribute("class", t || !1 === e ? "" : Q.get(this, "__className__") || ""))
                    }))
                },
                hasClass: function (e) {
                    var t, n, i = 0;
                    for (t = " " + e + " "; n = this[i++];)
                        if (1 === n.nodeType && (" " + vt(yt(n)) + " ").indexOf(t) > -1) return !0;
                    return !1
                }
            });
            var wt = /\r/g;
            T.fn.extend({
                val: function (e) {
                    var t, n, i, r = this[0];
                    return arguments.length ? (i = v(e), this.each((function (n) {
                        var r;
                        1 === this.nodeType && (null == (r = i ? e.call(this, n, T(this).val()) : e) ? r = "" : "number" == typeof r ? r += "" : Array.isArray(r) && (r = T.map(r, (function (e) {
                            return null == e ? "" : e + ""
                        }))), (t = T.valHooks[this.type] || T.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, r, "value") || (this.value = r))
                    }))) : r ? (t = T.valHooks[r.type] || T.valHooks[r.nodeName.toLowerCase()]) && "get" in t && void 0 !== (n = t.get(r, "value")) ? n : "string" == typeof (n = r.value) ? n.replace(wt, "") : null == n ? "" : n : void 0
                }
            }), T.extend({
                valHooks: {
                    option: {
                        get: function (e) {
                            var t = T.find.attr(e, "value");
                            return null != t ? t : vt(T.text(e))
                        }
                    },
                    select: {
                        get: function (e) {
                            var t, n, i, r = e.options,
                                o = e.selectedIndex,
                                a = "select-one" === e.type,
                                s = a ? null : [],
                                l = a ? o + 1 : r.length;
                            for (i = o < 0 ? l : a ? o : 0; i < l; i++)
                                if (((n = r[i]).selected || i === o) && !n.disabled && (!n.parentNode.disabled || !P(n.parentNode, "optgroup"))) {
                                    if (t = T(n).val(), a) return t;
                                    s.push(t)
                                }
                            return s
                        },
                        set: function (e, t) {
                            for (var n, i, r = e.options, o = T.makeArray(t), a = r.length; a--;)((i = r[a]).selected = T.inArray(T.valHooks.option.get(i), o) > -1) && (n = !0);
                            return n || (e.selectedIndex = -1), o
                        }
                    }
                }
            }), T.each(["radio", "checkbox"], (function () {
                T.valHooks[this] = {
                    set: function (e, t) {
                        if (Array.isArray(t)) return e.checked = T.inArray(T(e).val(), t) > -1
                    }
                }, g.checkOn || (T.valHooks[this].get = function (e) {
                    return null === e.getAttribute("value") ? "on" : e.value
                })
            })), g.focusin = "onfocusin" in n;
            var bt = /^(?:focusinfocus|focusoutblur)$/,
                _t = function (e) {
                    e.stopPropagation()
                };
            T.extend(T.event, {
                trigger: function (e, t, i, r) {
                    var o, a, s, l, c, u, h, d, f = [i || x],
                        m = p.call(e, "type") ? e.type : e,
                        g = p.call(e, "namespace") ? e.namespace.split(".") : [];
                    if (a = d = s = i = i || x, 3 !== i.nodeType && 8 !== i.nodeType && !bt.test(m + T.event.triggered) && (m.indexOf(".") > -1 && (g = m.split("."), m = g.shift(), g.sort()), c = m.indexOf(":") < 0 && "on" + m, (e = e[T.expando] ? e : new T.Event(m, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = g.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + g.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = i), t = null == t ? [e] : T.makeArray(t, [e]), h = T.event.special[m] || {}, r || !h.trigger || !1 !== h.trigger.apply(i, t))) {
                        if (!r && !h.noBubble && !y(i)) {
                            for (l = h.delegateType || m, bt.test(l + m) || (a = a.parentNode); a; a = a.parentNode) f.push(a), s = a;
                            s === (i.ownerDocument || x) && f.push(s.defaultView || s.parentWindow || n)
                        }
                        for (o = 0;
                            (a = f[o++]) && !e.isPropagationStopped();) d = a, e.type = o > 1 ? l : h.bindType || m, (u = (Q.get(a, "events") || Object.create(null))[e.type] && Q.get(a, "handle")) && u.apply(a, t), (u = c && a[c]) && u.apply && Z(a) && (e.result = u.apply(a, t), !1 === e.result && e.preventDefault());
                        return e.type = m, r || e.isDefaultPrevented() || h._default && !1 !== h._default.apply(f.pop(), t) || !Z(i) || c && v(i[m]) && !y(i) && ((s = i[c]) && (i[c] = null), T.event.triggered = m, e.isPropagationStopped() && d.addEventListener(m, _t), i[m](), e.isPropagationStopped() && d.removeEventListener(m, _t), T.event.triggered = void 0, s && (i[c] = s)), e.result
                    }
                },
                simulate: function (e, t, n) {
                    var i = T.extend(new T.Event, n, {
                        type: e,
                        isSimulated: !0
                    });
                    T.event.trigger(i, null, t)
                }
            }), T.fn.extend({
                trigger: function (e, t) {
                    return this.each((function () {
                        T.event.trigger(e, t, this)
                    }))
                },
                triggerHandler: function (e, t) {
                    var n = this[0];
                    if (n) return T.event.trigger(e, t, n, !0)
                }
            }), g.focusin || T.each({
                focus: "focusin",
                blur: "focusout"
            }, (function (e, t) {
                var n = function (e) {
                    T.event.simulate(t, e.target, T.event.fix(e))
                };
                T.event.special[t] = {
                    setup: function () {
                        var i = this.ownerDocument || this.document || this,
                            r = Q.access(i, t);
                        r || i.addEventListener(e, n, !0), Q.access(i, t, (r || 0) + 1)
                    },
                    teardown: function () {
                        var i = this.ownerDocument || this.document || this,
                            r = Q.access(i, t) - 1;
                        r ? Q.access(i, t, r) : (i.removeEventListener(e, n, !0), Q.remove(i, t))
                    }
                }
            }));
            var Mt = n.location,
                Tt = {
                    guid: Date.now()
                },
                St = /\?/;
            T.parseXML = function (e) {
                var t, i;
                if (!e || "string" != typeof e) return null;
                try {
                    t = (new n.DOMParser).parseFromString(e, "text/xml")
                } catch (e) { }
                return i = t && t.getElementsByTagName("parsererror")[0], t && !i || T.error("Invalid XML: " + (i ? T.map(i.childNodes, (function (e) {
                    return e.textContent
                })).join("\n") : e)), t
            };
            var Et = /\[\]$/,
                At = /\r?\n/g,
                Ct = /^(?:submit|button|image|reset|file)$/i,
                Lt = /^(?:input|select|textarea|keygen)/i;

            function Pt(e, t, n, i) {
                var r;
                if (Array.isArray(t)) T.each(t, (function (t, r) {
                    n || Et.test(e) ? i(e, r) : Pt(e + "[" + ("object" == typeof r && null != r ? t : "") + "]", r, n, i)
                }));
                else if (n || "object" !== _(t)) i(e, t);
                else
                    for (r in t) Pt(e + "[" + r + "]", t[r], n, i)
            }
            T.param = function (e, t) {
                var n, i = [],
                    r = function (e, t) {
                        var n = v(t) ? t() : t;
                        i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n)
                    };
                if (null == e) return "";
                if (Array.isArray(e) || e.jquery && !T.isPlainObject(e)) T.each(e, (function () {
                    r(this.name, this.value)
                }));
                else
                    for (n in e) Pt(n, e[n], t, r);
                return i.join("&")
            }, T.fn.extend({
                serialize: function () {
                    return T.param(this.serializeArray())
                },
                serializeArray: function () {
                    return this.map((function () {
                        var e = T.prop(this, "elements");
                        return e ? T.makeArray(e) : this
                    })).filter((function () {
                        var e = this.type;
                        return this.name && !T(this).is(":disabled") && Lt.test(this.nodeName) && !Ct.test(e) && (this.checked || !ge.test(e))
                    })).map((function (e, t) {
                        var n = T(this).val();
                        return null == n ? null : Array.isArray(n) ? T.map(n, (function (e) {
                            return {
                                name: t.name,
                                value: e.replace(At, "\r\n")
                            }
                        })) : {
                            name: t.name,
                            value: n.replace(At, "\r\n")
                        }
                    })).get()
                }
            });
            var Rt = /%20/g,
                Ot = /#.*$/,
                Dt = /([?&])_=[^&]*/,
                kt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
                Nt = /^(?:GET|HEAD)$/,
                It = /^\/\//,
                zt = {},
                Ft = {},
                Ht = "*/".concat("*"),
                Bt = x.createElement("a");

            function Ut(e) {
                return function (t, n) {
                    "string" != typeof t && (n = t, t = "*");
                    var i, r = 0,
                        o = t.toLowerCase().match(F) || [];
                    if (v(n))
                        for (; i = o[r++];) "+" === i[0] ? (i = i.slice(1) || "*", (e[i] = e[i] || []).unshift(n)) : (e[i] = e[i] || []).push(n)
                }
            }

            function jt(e, t, n, i) {
                var r = {},
                    o = e === Ft;

                function a(s) {
                    var l;
                    return r[s] = !0, T.each(e[s] || [], (function (e, s) {
                        var c = s(t, n, i);
                        return "string" != typeof c || o || r[c] ? o ? !(l = c) : void 0 : (t.dataTypes.unshift(c), a(c), !1)
                    })), l
                }
                return a(t.dataTypes[0]) || !r["*"] && a("*")
            }

            function Gt(e, t) {
                var n, i, r = T.ajaxSettings.flatOptions || {};
                for (n in t) void 0 !== t[n] && ((r[n] ? e : i || (i = {}))[n] = t[n]);
                return i && T.extend(!0, e, i), e
            }
            Bt.href = Mt.href, T.extend({
                active: 0,
                lastModified: {},
                etag: {},
                ajaxSettings: {
                    url: Mt.href,
                    type: "GET",
                    isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Mt.protocol),
                    global: !0,
                    processData: !0,
                    async: !0,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    accepts: {
                        "*": Ht,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },
                    contents: {
                        xml: /\bxml\b/,
                        html: /\bhtml/,
                        json: /\bjson\b/
                    },
                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },
                    converters: {
                        "* text": String,
                        "text html": !0,
                        "text json": JSON.parse,
                        "text xml": T.parseXML
                    },
                    flatOptions: {
                        url: !0,
                        context: !0
                    }
                },
                ajaxSetup: function (e, t) {
                    return t ? Gt(Gt(e, T.ajaxSettings), t) : Gt(T.ajaxSettings, e)
                },
                ajaxPrefilter: Ut(zt),
                ajaxTransport: Ut(Ft),
                ajax: function (e, t) {
                    "object" == typeof e && (t = e, e = void 0), t = t || {};
                    var i, r, o, a, s, l, c, u, h, d, p = T.ajaxSetup({}, t),
                        f = p.context || p,
                        m = p.context && (f.nodeType || f.jquery) ? T(f) : T.event,
                        g = T.Deferred(),
                        v = T.Callbacks("once memory"),
                        y = p.statusCode || {},
                        w = {},
                        b = {},
                        _ = "canceled",
                        M = {
                            readyState: 0,
                            getResponseHeader: function (e) {
                                var t;
                                if (c) {
                                    if (!a)
                                        for (a = {}; t = kt.exec(o);) a[t[1].toLowerCase() + " "] = (a[t[1].toLowerCase() + " "] || []).concat(t[2]);
                                    t = a[e.toLowerCase() + " "]
                                }
                                return null == t ? null : t.join(", ")
                            },
                            getAllResponseHeaders: function () {
                                return c ? o : null
                            },
                            setRequestHeader: function (e, t) {
                                return null == c && (e = b[e.toLowerCase()] = b[e.toLowerCase()] || e, w[e] = t), this
                            },
                            overrideMimeType: function (e) {
                                return null == c && (p.mimeType = e), this
                            },
                            statusCode: function (e) {
                                var t;
                                if (e)
                                    if (c) M.always(e[M.status]);
                                    else
                                        for (t in e) y[t] = [y[t], e[t]];
                                return this
                            },
                            abort: function (e) {
                                var t = e || _;
                                return i && i.abort(t), S(0, t), this
                            }
                        };
                    if (g.promise(M), p.url = ((e || p.url || Mt.href) + "").replace(It, Mt.protocol + "//"), p.type = t.method || t.type || p.method || p.type, p.dataTypes = (p.dataType || "*").toLowerCase().match(F) || [""], null == p.crossDomain) {
                        l = x.createElement("a");
                        try {
                            l.href = p.url, l.href = l.href, p.crossDomain = Bt.protocol + "//" + Bt.host != l.protocol + "//" + l.host
                        } catch (e) {
                            p.crossDomain = !0
                        }
                    }
                    if (p.data && p.processData && "string" != typeof p.data && (p.data = T.param(p.data, p.traditional)), jt(zt, p, t, M), c) return M;
                    for (h in (u = T.event && p.global) && 0 == T.active++ && T.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Nt.test(p.type), r = p.url.replace(Ot, ""), p.hasContent ? p.data && p.processData && 0 === (p.contentType || "").indexOf("application/x-www-form-urlencoded") && (p.data = p.data.replace(Rt, "+")) : (d = p.url.slice(r.length), p.data && (p.processData || "string" == typeof p.data) && (r += (St.test(r) ? "&" : "?") + p.data, delete p.data), !1 === p.cache && (r = r.replace(Dt, "$1"), d = (St.test(r) ? "&" : "?") + "_=" + Tt.guid++ + d), p.url = r + d), p.ifModified && (T.lastModified[r] && M.setRequestHeader("If-Modified-Since", T.lastModified[r]), T.etag[r] && M.setRequestHeader("If-None-Match", T.etag[r])), (p.data && p.hasContent && !1 !== p.contentType || t.contentType) && M.setRequestHeader("Content-Type", p.contentType), M.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Ht + "; q=0.01" : "") : p.accepts["*"]), p.headers) M.setRequestHeader(h, p.headers[h]);
                    if (p.beforeSend && (!1 === p.beforeSend.call(f, M, p) || c)) return M.abort();
                    if (_ = "abort", v.add(p.complete), M.done(p.success), M.fail(p.error), i = jt(Ft, p, t, M)) {
                        if (M.readyState = 1, u && m.trigger("ajaxSend", [M, p]), c) return M;
                        p.async && p.timeout > 0 && (s = n.setTimeout((function () {
                            M.abort("timeout")
                        }), p.timeout));
                        try {
                            c = !1, i.send(w, S)
                        } catch (e) {
                            if (c) throw e;
                            S(-1, e)
                        }
                    } else S(-1, "No Transport");

                    function S(e, t, a, l) {
                        var h, d, x, w, b, _ = t;
                        c || (c = !0, s && n.clearTimeout(s), i = void 0, o = l || "", M.readyState = e > 0 ? 4 : 0, h = e >= 200 && e < 300 || 304 === e, a && (w = function (e, t, n) {
                            for (var i, r, o, a, s = e.contents, l = e.dataTypes;
                                "*" === l[0];) l.shift(), void 0 === i && (i = e.mimeType || t.getResponseHeader("Content-Type"));
                            if (i)
                                for (r in s)
                                    if (s[r] && s[r].test(i)) {
                                        l.unshift(r);
                                        break
                                    }
                            if (l[0] in n) o = l[0];
                            else {
                                for (r in n) {
                                    if (!l[0] || e.converters[r + " " + l[0]]) {
                                        o = r;
                                        break
                                    }
                                    a || (a = r)
                                }
                                o = o || a
                            }
                            if (o) return o !== l[0] && l.unshift(o), n[o]
                        }(p, M, a)), !h && T.inArray("script", p.dataTypes) > -1 && T.inArray("json", p.dataTypes) < 0 && (p.converters["text script"] = function () { }), w = function (e, t, n, i) {
                            var r, o, a, s, l, c = {},
                                u = e.dataTypes.slice();
                            if (u[1])
                                for (a in e.converters) c[a.toLowerCase()] = e.converters[a];
                            for (o = u.shift(); o;)
                                if (e.responseFields[o] && (n[e.responseFields[o]] = t), !l && i && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = o, o = u.shift())
                                    if ("*" === o) o = l;
                                    else if ("*" !== l && l !== o) {
                                        if (!(a = c[l + " " + o] || c["* " + o]))
                                            for (r in c)
                                                if ((s = r.split(" "))[1] === o && (a = c[l + " " + s[0]] || c["* " + s[0]])) {
                                                    !0 === a ? a = c[r] : !0 !== c[r] && (o = s[0], u.unshift(s[1]));
                                                    break
                                                }
                                        if (!0 !== a)
                                            if (a && e.throws) t = a(t);
                                            else try {
                                                t = a(t)
                                            } catch (e) {
                                                return {
                                                    state: "parsererror",
                                                    error: a ? e : "No conversion from " + l + " to " + o
                                                }
                                            }
                                    }
                            return {
                                state: "success",
                                data: t
                            }
                        }(p, w, M, h), h ? (p.ifModified && ((b = M.getResponseHeader("Last-Modified")) && (T.lastModified[r] = b), (b = M.getResponseHeader("etag")) && (T.etag[r] = b)), 204 === e || "HEAD" === p.type ? _ = "nocontent" : 304 === e ? _ = "notmodified" : (_ = w.state, d = w.data, h = !(x = w.error))) : (x = _, !e && _ || (_ = "error", e < 0 && (e = 0))), M.status = e, M.statusText = (t || _) + "", h ? g.resolveWith(f, [d, _, M]) : g.rejectWith(f, [M, _, x]), M.statusCode(y), y = void 0, u && m.trigger(h ? "ajaxSuccess" : "ajaxError", [M, p, h ? d : x]), v.fireWith(f, [M, _]), u && (m.trigger("ajaxComplete", [M, p]), --T.active || T.event.trigger("ajaxStop")))
                    }
                    return M
                },
                getJSON: function (e, t, n) {
                    return T.get(e, t, n, "json")
                },
                getScript: function (e, t) {
                    return T.get(e, void 0, t, "script")
                }
            }), T.each(["get", "post"], (function (e, t) {
                T[t] = function (e, n, i, r) {
                    return v(n) && (r = r || i, i = n, n = void 0), T.ajax(T.extend({
                        url: e,
                        type: t,
                        dataType: r,
                        data: n,
                        success: i
                    }, T.isPlainObject(e) && e))
                }
            })), T.ajaxPrefilter((function (e) {
                var t;
                for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "")
            })), T._evalUrl = function (e, t, n) {
                return T.ajax({
                    url: e,
                    type: "GET",
                    dataType: "script",
                    cache: !0,
                    async: !1,
                    global: !1,
                    converters: {
                        "text script": function () { }
                    },
                    dataFilter: function (e) {
                        T.globalEval(e, t, n)
                    }
                })
            }, T.fn.extend({
                wrapAll: function (e) {
                    var t;
                    return this[0] && (v(e) && (e = e.call(this[0])), t = T(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map((function () {
                        for (var e = this; e.firstElementChild;) e = e.firstElementChild;
                        return e
                    })).append(this)), this
                },
                wrapInner: function (e) {
                    return v(e) ? this.each((function (t) {
                        T(this).wrapInner(e.call(this, t))
                    })) : this.each((function () {
                        var t = T(this),
                            n = t.contents();
                        n.length ? n.wrapAll(e) : t.append(e)
                    }))
                },
                wrap: function (e) {
                    var t = v(e);
                    return this.each((function (n) {
                        T(this).wrapAll(t ? e.call(this, n) : e)
                    }))
                },
                unwrap: function (e) {
                    return this.parent(e).not("body").each((function () {
                        T(this).replaceWith(this.childNodes)
                    })), this
                }
            }), T.expr.pseudos.hidden = function (e) {
                return !T.expr.pseudos.visible(e)
            }, T.expr.pseudos.visible = function (e) {
                return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
            }, T.ajaxSettings.xhr = function () {
                try {
                    return new n.XMLHttpRequest
                } catch (e) { }
            };
            var Vt = {
                0: 200,
                1223: 204
            },
                Wt = T.ajaxSettings.xhr();
            g.cors = !!Wt && "withCredentials" in Wt, g.ajax = Wt = !!Wt, T.ajaxTransport((function (e) {
                var t, i;
                if (g.cors || Wt && !e.crossDomain) return {
                    send: function (r, o) {
                        var a, s = e.xhr();
                        if (s.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields)
                            for (a in e.xhrFields) s[a] = e.xhrFields[a];
                        for (a in e.mimeType && s.overrideMimeType && s.overrideMimeType(e.mimeType), e.crossDomain || r["X-Requested-With"] || (r["X-Requested-With"] = "XMLHttpRequest"), r) s.setRequestHeader(a, r[a]);
                        t = function (e) {
                            return function () {
                                t && (t = i = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === e ? s.abort() : "error" === e ? "number" != typeof s.status ? o(0, "error") : o(s.status, s.statusText) : o(Vt[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? {
                                    binary: s.response
                                } : {
                                    text: s.responseText
                                }, s.getAllResponseHeaders()))
                            }
                        }, s.onload = t(), i = s.onerror = s.ontimeout = t("error"), void 0 !== s.onabort ? s.onabort = i : s.onreadystatechange = function () {
                            4 === s.readyState && n.setTimeout((function () {
                                t && i()
                            }))
                        }, t = t("abort");
                        try {
                            s.send(e.hasContent && e.data || null)
                        } catch (e) {
                            if (t) throw e
                        }
                    },
                    abort: function () {
                        t && t()
                    }
                }
            })), T.ajaxPrefilter((function (e) {
                e.crossDomain && (e.contents.script = !1)
            })), T.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /\b(?:java|ecma)script\b/
                },
                converters: {
                    "text script": function (e) {
                        return T.globalEval(e), e
                    }
                }
            }), T.ajaxPrefilter("script", (function (e) {
                void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
            })), T.ajaxTransport("script", (function (e) {
                var t, n;
                if (e.crossDomain || e.scriptAttrs) return {
                    send: function (i, r) {
                        t = T("<script>").attr(e.scriptAttrs || {}).prop({
                            charset: e.scriptCharset,
                            src: e.url
                        }).on("load error", n = function (e) {
                            t.remove(), n = null, e && r("error" === e.type ? 404 : 200, e.type)
                        }), x.head.appendChild(t[0])
                    },
                    abort: function () {
                        n && n()
                    }
                }
            }));
            var qt, $t = [],
                Xt = /(=)\?(?=&|$)|\?\?/;
            T.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: function () {
                    var e = $t.pop() || T.expando + "_" + Tt.guid++;
                    return this[e] = !0, e
                }
            }), T.ajaxPrefilter("json jsonp", (function (e, t, i) {
                var r, o, a, s = !1 !== e.jsonp && (Xt.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Xt.test(e.data) && "data");
                if (s || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = v(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, s ? e[s] = e[s].replace(Xt, "$1" + r) : !1 !== e.jsonp && (e.url += (St.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () {
                    return a || T.error(r + " was not called"), a[0]
                }, e.dataTypes[0] = "json", o = n[r], n[r] = function () {
                    a = arguments
                }, i.always((function () {
                    void 0 === o ? T(n).removeProp(r) : n[r] = o, e[r] && (e.jsonpCallback = t.jsonpCallback, $t.push(r)), a && v(o) && o(a[0]), a = o = void 0
                })), "script"
            })), g.createHTMLDocument = ((qt = x.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === qt.childNodes.length), T.parseHTML = function (e, t, n) {
                return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (g.createHTMLDocument ? ((i = (t = x.implementation.createHTMLDocument("")).createElement("base")).href = x.location.href, t.head.appendChild(i)) : t = x), o = !n && [], (r = R.exec(e)) ? [t.createElement(r[1])] : (r = Me([e], t, o), o && o.length && T(o).remove(), T.merge([], r.childNodes)));
                var i, r, o
            }, T.fn.load = function (e, t, n) {
                var i, r, o, a = this,
                    s = e.indexOf(" ");
                return s > -1 && (i = vt(e.slice(s)), e = e.slice(0, s)), v(t) ? (n = t, t = void 0) : t && "object" == typeof t && (r = "POST"), a.length > 0 && T.ajax({
                    url: e,
                    type: r || "GET",
                    dataType: "html",
                    data: t
                }).done((function (e) {
                    o = arguments, a.html(i ? T("<div>").append(T.parseHTML(e)).find(i) : e)
                })).always(n && function (e, t) {
                    a.each((function () {
                        n.apply(this, o || [e.responseText, t, e])
                    }))
                }), this
            }, T.expr.pseudos.animated = function (e) {
                return T.grep(T.timers, (function (t) {
                    return e === t.elem
                })).length
            }, T.offset = {
                setOffset: function (e, t, n) {
                    var i, r, o, a, s, l, c = T.css(e, "position"),
                        u = T(e),
                        h = {};
                    "static" === c && (e.style.position = "relative"), s = u.offset(), o = T.css(e, "top"), l = T.css(e, "left"), ("absolute" === c || "fixed" === c) && (o + l).indexOf("auto") > -1 ? (a = (i = u.position()).top, r = i.left) : (a = parseFloat(o) || 0, r = parseFloat(l) || 0), v(t) && (t = t.call(e, n, T.extend({}, s))), null != t.top && (h.top = t.top - s.top + a), null != t.left && (h.left = t.left - s.left + r), "using" in t ? t.using.call(e, h) : u.css(h)
                }
            }, T.fn.extend({
                offset: function (e) {
                    if (arguments.length) return void 0 === e ? this : this.each((function (t) {
                        T.offset.setOffset(this, e, t)
                    }));
                    var t, n, i = this[0];
                    return i ? i.getClientRects().length ? (t = i.getBoundingClientRect(), n = i.ownerDocument.defaultView, {
                        top: t.top + n.pageYOffset,
                        left: t.left + n.pageXOffset
                    }) : {
                        top: 0,
                        left: 0
                    } : void 0
                },
                position: function () {
                    if (this[0]) {
                        var e, t, n, i = this[0],
                            r = {
                                top: 0,
                                left: 0
                            };
                        if ("fixed" === T.css(i, "position")) t = i.getBoundingClientRect();
                        else {
                            for (t = this.offset(), n = i.ownerDocument, e = i.offsetParent || n.documentElement; e && (e === n.body || e === n.documentElement) && "static" === T.css(e, "position");) e = e.parentNode;
                            e && e !== i && 1 === e.nodeType && ((r = T(e).offset()).top += T.css(e, "borderTopWidth", !0), r.left += T.css(e, "borderLeftWidth", !0))
                        }
                        return {
                            top: t.top - r.top - T.css(i, "marginTop", !0),
                            left: t.left - r.left - T.css(i, "marginLeft", !0)
                        }
                    }
                },
                offsetParent: function () {
                    return this.map((function () {
                        for (var e = this.offsetParent; e && "static" === T.css(e, "position");) e = e.offsetParent;
                        return e || ae
                    }))
                }
            }), T.each({
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset"
            }, (function (e, t) {
                var n = "pageYOffset" === t;
                T.fn[e] = function (i) {
                    return W(this, (function (e, i, r) {
                        var o;
                        if (y(e) ? o = e : 9 === e.nodeType && (o = e.defaultView), void 0 === r) return o ? o[t] : e[i];
                        o ? o.scrollTo(n ? o.pageXOffset : r, n ? r : o.pageYOffset) : e[i] = r
                    }), e, i, arguments.length)
                }
            })), T.each(["top", "left"], (function (e, t) {
                T.cssHooks[t] = We(g.pixelPosition, (function (e, n) {
                    if (n) return n = Ve(e, t), Be.test(n) ? T(e).position()[t] + "px" : n
                }))
            })), T.each({
                Height: "height",
                Width: "width"
            }, (function (e, t) {
                T.each({
                    padding: "inner" + e,
                    content: t,
                    "": "outer" + e
                }, (function (n, i) {
                    T.fn[i] = function (r, o) {
                        var a = arguments.length && (n || "boolean" != typeof r),
                            s = n || (!0 === r || !0 === o ? "margin" : "border");
                        return W(this, (function (t, n, r) {
                            var o;
                            return y(t) ? 0 === i.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (o = t.documentElement, Math.max(t.body["scroll" + e], o["scroll" + e], t.body["offset" + e], o["offset" + e], o["client" + e])) : void 0 === r ? T.css(t, n, s) : T.style(t, n, r, s)
                        }), t, a ? r : void 0, a)
                    }
                }))
            })), T.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], (function (e, t) {
                T.fn[t] = function (e) {
                    return this.on(t, e)
                }
            })), T.fn.extend({
                bind: function (e, t, n) {
                    return this.on(e, null, t, n)
                },
                unbind: function (e, t) {
                    return this.off(e, null, t)
                },
                delegate: function (e, t, n, i) {
                    return this.on(t, e, n, i)
                },
                undelegate: function (e, t, n) {
                    return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
                },
                hover: function (e, t) {
                    return this.mouseenter(e).mouseleave(t || e)
                }
            }), T.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function (e, t) {
                T.fn[t] = function (e, n) {
                    return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)
                }
            }));
            var Yt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
            T.proxy = function (e, t) {
                var n, i, r;
                if ("string" == typeof t && (n = e[t], t = e, e = n), v(e)) return i = s.call(arguments, 2), (r = function () {
                    return e.apply(t || this, i.concat(s.call(arguments)))
                }).guid = e.guid = e.guid || T.guid++, r
            }, T.holdReady = function (e) {
                e ? T.readyWait++ : T.ready(!0)
            }, T.isArray = Array.isArray, T.parseJSON = JSON.parse, T.nodeName = P, T.isFunction = v, T.isWindow = y, T.camelCase = Y, T.type = _, T.now = Date.now, T.isNumeric = function (e) {
                var t = T.type(e);
                return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e))
            }, T.trim = function (e) {
                return null == e ? "" : (e + "").replace(Yt, "")
            }, void 0 === (i = function () {
                return T
            }.apply(t, [])) || (e.exports = i);
            var Zt = n.jQuery,
                Jt = n.$;
            return T.noConflict = function (e) {
                return n.$ === T && (n.$ = Jt), e && n.jQuery === T && (n.jQuery = Zt), T
            }, void 0 === r && (n.jQuery = n.$ = T), T
        }))
    }, function (e, t, n) {
        var i, r;
        void 0 === (r = "function" == typeof (i = function () {
            "use strict";
            var e = function () {
                r.log(2, "(COMPATIBILITY NOTICE) -> As of ScrollMagic 2.0.0 you need to use 'new ScrollMagic.Controller()' to create a new controller instance. Use 'new ScrollMagic.Scene()' to instance a scene.")
            };
            e.version = "2.0.8", "undefined" != typeof window && window.addEventListener("mousewheel", void 0);
            var t = "data-scrollmagic-pin-spacer";
            e.Controller = function (i) {
                var o, a, s = "ScrollMagic.Controller",
                    l = "FORWARD",
                    c = "REVERSE",
                    u = "PAUSED",
                    h = n.defaults,
                    d = this,
                    p = r.extend({}, h, i),
                    f = [],
                    m = !1,
                    g = 0,
                    v = u,
                    y = !0,
                    x = 0,
                    w = !0,
                    b = function () {
                        for (var t in p) h.hasOwnProperty(t) || (P(2, 'WARNING: Unknown option "' + t + '"'), delete p[t]);
                        if (p.container = r.get.elements(p.container)[0], !p.container) throw P(1, "ERROR creating object " + s + ": No valid scroll container supplied"), s + " init failed.";
                        (y = p.container === window || p.container === document.body || !document.body.contains(p.container)) && (p.container = window), x = T(), p.container.addEventListener("resize", C), p.container.addEventListener("scroll", C);
                        var n = parseInt(p.refreshInterval, 10);
                        p.refreshInterval = r.type.Number(n) ? n : h.refreshInterval, _(), P(3, "added new " + s + " controller (v" + e.version + ")")
                    },
                    _ = function () {
                        p.refreshInterval > 0 && (a = window.setTimeout(L, p.refreshInterval))
                    },
                    M = function () {
                        return p.vertical ? r.get.scrollTop(p.container) : r.get.scrollLeft(p.container)
                    },
                    T = function () {
                        return p.vertical ? r.get.height(p.container) : r.get.width(p.container)
                    },
                    S = this._setScrollPos = function (e) {
                        p.vertical ? y ? window.scrollTo(r.get.scrollLeft(), e) : p.container.scrollTop = e : y ? window.scrollTo(e, r.get.scrollTop()) : p.container.scrollLeft = e
                    },
                    E = function () {
                        if (w && m) {
                            var e = r.type.Array(m) ? m : f.slice(0);
                            m = !1;
                            var t = g,
                                n = (g = d.scrollPos()) - t;
                            0 !== n && (v = n > 0 ? l : c), v === c && e.reverse(), e.forEach((function (t, n) {
                                P(3, "updating Scene " + (n + 1) + "/" + e.length + " (" + f.length + " total)"), t.update(!0)
                            })), 0 === e.length && p.loglevel >= 3 && P(3, "updating 0 Scenes (nothing added to controller)")
                        }
                    },
                    A = function () {
                        o = r.rAF(E)
                    },
                    C = function (e) {
                        P(3, "event fired causing an update:", e.type), "resize" == e.type && (x = T(), v = u), !0 !== m && (m = !0, A())
                    },
                    L = function () {
                        if (!y && x != T()) {
                            var e;
                            try {
                                e = new Event("resize", {
                                    bubbles: !1,
                                    cancelable: !1
                                })
                            } catch (t) {
                                (e = document.createEvent("Event")).initEvent("resize", !1, !1)
                            }
                            p.container.dispatchEvent(e)
                        }
                        f.forEach((function (e, t) {
                            e.refresh()
                        })), _()
                    },
                    P = this._log = function (e, t) {
                        p.loglevel >= e && (Array.prototype.splice.call(arguments, 1, 0, "(" + s + ") ->"), r.log.apply(window, arguments))
                    };
                this._options = p;
                var R = function (e) {
                    if (e.length <= 1) return e;
                    var t = e.slice(0);
                    return t.sort((function (e, t) {
                        return e.scrollOffset() > t.scrollOffset() ? 1 : -1
                    })), t
                };
                return this.addScene = function (t) {
                    if (r.type.Array(t)) t.forEach((function (e, t) {
                        d.addScene(e)
                    }));
                    else if (t instanceof e.Scene) {
                        if (t.controller() !== d) t.addTo(d);
                        else if (f.indexOf(t) < 0) {
                            for (var n in f.push(t), f = R(f), t.on("shift.controller_sort", (function () {
                                f = R(f)
                            })), p.globalSceneOptions) t[n] && t[n].call(t, p.globalSceneOptions[n]);
                            P(3, "adding Scene (now " + f.length + " total)")
                        }
                    } else P(1, "ERROR: invalid argument supplied for '.addScene()'");
                    return d
                }, this.removeScene = function (e) {
                    if (r.type.Array(e)) e.forEach((function (e, t) {
                        d.removeScene(e)
                    }));
                    else {
                        var t = f.indexOf(e);
                        t > -1 && (e.off("shift.controller_sort"), f.splice(t, 1), P(3, "removing Scene (now " + f.length + " left)"), e.remove())
                    }
                    return d
                }, this.updateScene = function (t, n) {
                    return r.type.Array(t) ? t.forEach((function (e, t) {
                        d.updateScene(e, n)
                    })) : n ? t.update(!0) : !0 !== m && t instanceof e.Scene && (-1 == (m = m || []).indexOf(t) && m.push(t), m = R(m), A()), d
                }, this.update = function (e) {
                    return C({
                        type: "resize"
                    }), e && E(), d
                }, this.scrollTo = function (n, i) {
                    if (r.type.Number(n)) S.call(p.container, n, i);
                    else if (n instanceof e.Scene) n.controller() === d ? d.scrollTo(n.scrollOffset(), i) : P(2, "scrollTo(): The supplied scene does not belong to this controller. Scroll cancelled.", n);
                    else if (r.type.Function(n)) S = n;
                    else {
                        var o = r.get.elements(n)[0];
                        if (o) {
                            for (; o.parentNode.hasAttribute(t);) o = o.parentNode;
                            var a = p.vertical ? "top" : "left",
                                s = r.get.offset(p.container),
                                l = r.get.offset(o);
                            y || (s[a] -= d.scrollPos()), d.scrollTo(l[a] - s[a], i)
                        } else P(2, "scrollTo(): The supplied argument is invalid. Scroll cancelled.", n)
                    }
                    return d
                }, this.scrollPos = function (e) {
                    return arguments.length ? (r.type.Function(e) ? M = e : P(2, "Provided value for method 'scrollPos' is not a function. To change the current scroll position use 'scrollTo()'."), d) : M.call(d)
                }, this.info = function (e) {
                    var t = {
                        size: x,
                        vertical: p.vertical,
                        scrollPos: g,
                        scrollDirection: v,
                        container: p.container,
                        isDocument: y
                    };
                    return arguments.length ? void 0 !== t[e] ? t[e] : void P(1, 'ERROR: option "' + e + '" is not available') : t
                }, this.loglevel = function (e) {
                    return arguments.length ? (p.loglevel != e && (p.loglevel = e), d) : p.loglevel
                }, this.enabled = function (e) {
                    return arguments.length ? (w != e && (w = !!e, d.updateScene(f, !0)), d) : w
                }, this.destroy = function (e) {
                    window.clearTimeout(a);
                    for (var t = f.length; t--;) f[t].destroy(e);
                    return p.container.removeEventListener("resize", C), p.container.removeEventListener("scroll", C), r.cAF(o), P(3, "destroyed " + s + " (reset: " + (e ? "true" : "false") + ")"), null
                }, b(), d
            };
            var n = {
                defaults: {
                    container: window,
                    vertical: !0,
                    globalSceneOptions: {},
                    loglevel: 2,
                    refreshInterval: 100
                }
            };
            e.Controller.addOption = function (e, t) {
                n.defaults[e] = t
            }, e.Controller.extend = function (t) {
                var n = this;
                e.Controller = function () {
                    return n.apply(this, arguments), this.$super = r.extend({}, this), t.apply(this, arguments) || this
                }, r.extend(e.Controller, n), e.Controller.prototype = n.prototype, e.Controller.prototype.constructor = e.Controller
            }, e.Scene = function (n) {
                var o, a, s = "ScrollMagic.Scene",
                    l = "BEFORE",
                    c = "DURING",
                    u = "AFTER",
                    h = i.defaults,
                    d = this,
                    p = r.extend({}, h, n),
                    f = l,
                    m = 0,
                    g = {
                        start: 0,
                        end: 0
                    },
                    v = 0,
                    y = !0,
                    x = function () {
                        for (var e in p) h.hasOwnProperty(e) || (b(2, 'WARNING: Unknown option "' + e + '"'), delete p[e]);
                        for (var t in h) R(t);
                        L()
                    },
                    w = {};
                this.on = function (e, t) {
                    return r.type.Function(t) ? (e = e.trim().split(" ")).forEach((function (e) {
                        var n = e.split("."),
                            i = n[0],
                            r = n[1];
                        "*" != i && (w[i] || (w[i] = []), w[i].push({
                            namespace: r || "",
                            callback: t
                        }))
                    })) : b(1, "ERROR when calling '.on()': Supplied callback for '" + e + "' is not a valid function!"), d
                }, this.off = function (e, t) {
                    return e ? ((e = e.trim().split(" ")).forEach((function (e, n) {
                        var i = e.split("."),
                            r = i[0],
                            o = i[1] || "";
                        ("*" === r ? Object.keys(w) : [r]).forEach((function (e) {
                            for (var n = w[e] || [], i = n.length; i--;) {
                                var r = n[i];
                                !r || o !== r.namespace && "*" !== o || t && t != r.callback || n.splice(i, 1)
                            }
                            n.length || delete w[e]
                        }))
                    })), d) : (b(1, "ERROR: Invalid event name supplied."), d)
                }, this.trigger = function (t, n) {
                    if (t) {
                        var i = t.trim().split("."),
                            r = i[0],
                            o = i[1],
                            a = w[r];
                        b(3, "event fired:", r, n ? "->" : "", n || ""), a && a.forEach((function (t, i) {
                            o && o !== t.namespace || t.callback.call(d, new e.Event(r, t.namespace, d, n))
                        }))
                    } else b(1, "ERROR: Invalid event name supplied.");
                    return d
                }, d.on("change.internal", (function (e) {
                    "loglevel" !== e.what && "tweenChanges" !== e.what && ("triggerElement" === e.what ? E() : "reverse" === e.what && d.update())
                })).on("shift.internal", (function (e) {
                    T(), d.update()
                }));
                var b = this._log = function (e, t) {
                    p.loglevel >= e && (Array.prototype.splice.call(arguments, 1, 0, "(" + s + ") ->"), r.log.apply(window, arguments))
                };
                this.addTo = function (t) {
                    return t instanceof e.Controller ? a != t && (a && a.removeScene(d), a = t, L(), S(!0), E(!0), T(), a.info("container").addEventListener("resize", A), t.addScene(d), d.trigger("add", {
                        controller: a
                    }), b(3, "added " + s + " to controller"), d.update()) : b(1, "ERROR: supplied argument of 'addTo()' is not a valid ScrollMagic Controller"), d
                }, this.enabled = function (e) {
                    return arguments.length ? (y != e && (y = !!e, d.update(!0)), d) : y
                }, this.remove = function () {
                    if (a) {
                        a.info("container").removeEventListener("resize", A);
                        var e = a;
                        a = void 0, e.removeScene(d), d.trigger("remove"), b(3, "removed " + s + " from controller")
                    }
                    return d
                }, this.destroy = function (e) {
                    return d.trigger("destroy", {
                        reset: e
                    }), d.remove(), d.off("*.*"), b(3, "destroyed " + s + " (reset: " + (e ? "true" : "false") + ")"), null
                }, this.update = function (e) {
                    if (a)
                        if (e)
                            if (a.enabled() && y) {
                                var t, n = a.info("scrollPos");
                                t = p.duration > 0 ? (n - g.start) / (g.end - g.start) : n >= g.start ? 1 : 0, d.trigger("update", {
                                    startPos: g.start,
                                    endPos: g.end,
                                    scrollPos: n
                                }), d.progress(t)
                            } else _ && f === c && O(!0);
                        else a.updateScene(d, !1);
                    return d
                }, this.refresh = function () {
                    return S(), E(), d
                }, this.progress = function (e) {
                    if (arguments.length) {
                        var t = !1,
                            n = f,
                            i = a ? a.info("scrollDirection") : "PAUSED",
                            r = p.reverse || e >= m;
                        if (0 === p.duration ? (t = m != e, f = 0 == (m = e < 1 && r ? 0 : 1) ? l : c) : e < 0 && f !== l && r ? (m = 0, f = l, t = !0) : e >= 0 && e < 1 && r ? (m = e, f = c, t = !0) : e >= 1 && f !== u ? (m = 1, f = u, t = !0) : f !== c || r || O(), t) {
                            var o = {
                                progress: m,
                                state: f,
                                scrollDirection: i
                            },
                                s = f != n,
                                h = function (e) {
                                    d.trigger(e, o)
                                };
                            s && n !== c && (h("enter"), h(n === l ? "start" : "end")), h("progress"), s && f !== c && (h(f === l ? "start" : "end"), h("leave"))
                        }
                        return d
                    }
                    return m
                };
                var _, M, T = function () {
                    g = {
                        start: v + p.offset
                    }, a && p.triggerElement && (g.start -= a.info("size") * p.triggerHook), g.end = g.start + p.duration
                },
                    S = function (e) {
                        if (o) {
                            var t = "duration";
                            P(t, o.call(d)) && !e && (d.trigger("change", {
                                what: t,
                                newval: p[t]
                            }), d.trigger("shift", {
                                reason: t
                            }))
                        }
                    },
                    E = function (e) {
                        var n = 0,
                            i = p.triggerElement;
                        if (a && (i || v > 0)) {
                            if (i)
                                if (i.parentNode) {
                                    for (var o = a.info(), s = r.get.offset(o.container), l = o.vertical ? "top" : "left"; i.parentNode.hasAttribute(t);) i = i.parentNode;
                                    var c = r.get.offset(i);
                                    o.isDocument || (s[l] -= a.scrollPos()), n = c[l] - s[l]
                                } else b(2, "WARNING: triggerElement was removed from DOM and will be reset to", void 0), d.triggerElement(void 0);
                            var u = n != v;
                            v = n, u && !e && d.trigger("shift", {
                                reason: "triggerElementPosition"
                            })
                        }
                    },
                    A = function (e) {
                        p.triggerHook > 0 && d.trigger("shift", {
                            reason: "containerResize"
                        })
                    },
                    C = r.extend(i.validate, {
                        duration: function (e) {
                            if (r.type.String(e) && e.match(/^(\.|\d)*\d+%$/)) {
                                var t = parseFloat(e) / 100;
                                e = function () {
                                    return a ? a.info("size") * t : 0
                                }
                            }
                            if (r.type.Function(e)) {
                                o = e;
                                try {
                                    e = parseFloat(o.call(d))
                                } catch (t) {
                                    e = -1
                                }
                            }
                            if (e = parseFloat(e), !r.type.Number(e) || e < 0) throw o ? (o = void 0, ['Invalid return value of supplied function for option "duration":', e]) : ['Invalid value for option "duration":', e];
                            return e
                        }
                    }),
                    L = function (e) {
                        (e = arguments.length ? [e] : Object.keys(C)).forEach((function (e, t) {
                            var n;
                            if (C[e]) try {
                                n = C[e](p[e])
                            } catch (t) {
                                n = h[e];
                                var i = r.type.String(t) ? [t] : t;
                                r.type.Array(i) ? (i[0] = "ERROR: " + i[0], i.unshift(1), b.apply(this, i)) : b(1, "ERROR: Problem executing validation callback for option '" + e + "':", t.message)
                            } finally {
                                    p[e] = n
                                }
                        }))
                    },
                    P = function (e, t) {
                        var n = !1,
                            i = p[e];
                        return p[e] != t && (p[e] = t, L(e), n = i != p[e]), n
                    },
                    R = function (e) {
                        d[e] || (d[e] = function (t) {
                            return arguments.length ? ("duration" === e && (o = void 0), P(e, t) && (d.trigger("change", {
                                what: e,
                                newval: p[e]
                            }), i.shifts.indexOf(e) > -1 && d.trigger("shift", {
                                reason: e
                            })), d) : p[e]
                        })
                    };
                this.controller = function () {
                    return a
                }, this.state = function () {
                    return f
                }, this.scrollOffset = function () {
                    return g.start
                }, this.triggerPosition = function () {
                    var e = p.offset;
                    return a && (p.triggerElement ? e += v : e += a.info("size") * d.triggerHook()), e
                }, d.on("shift.internal", (function (e) {
                    var t = "duration" === e.reason;
                    (f === u && t || f === c && 0 === p.duration) && O(), t && D()
                })).on("progress.internal", (function (e) {
                    O()
                })).on("add.internal", (function (e) {
                    D()
                })).on("destroy.internal", (function (e) {
                    d.removePin(e.reset)
                }));
                var O = function (e) {
                    if (_ && a) {
                        var t = a.info(),
                            n = M.spacer.firstChild;
                        if (e || f !== c) {
                            var i = {
                                position: M.inFlow ? "relative" : "absolute",
                                top: 0,
                                left: 0
                            },
                                o = r.css(n, "position") != i.position;
                            M.pushFollowers ? p.duration > 0 && (f === u && 0 === parseFloat(r.css(M.spacer, "padding-top")) || f === l && 0 === parseFloat(r.css(M.spacer, "padding-bottom"))) && (o = !0) : i[t.vertical ? "top" : "left"] = p.duration * m, r.css(n, i), o && D()
                        } else {
                            "fixed" != r.css(n, "position") && (r.css(n, {
                                position: "fixed"
                            }), D());
                            var s = r.get.offset(M.spacer, !0),
                                h = p.reverse || 0 === p.duration ? t.scrollPos - g.start : Math.round(m * p.duration * 10) / 10;
                            s[t.vertical ? "top" : "left"] += h, r.css(M.spacer.firstChild, {
                                top: s.top,
                                left: s.left
                            })
                        }
                    }
                },
                    D = function () {
                        if (_ && a && M.inFlow) {
                            var e = f === c,
                                t = a.info("vertical"),
                                n = M.spacer.firstChild,
                                i = r.isMarginCollapseType(r.css(M.spacer, "display")),
                                o = {};
                            M.relSize.width || M.relSize.autoFullWidth ? e ? r.css(_, {
                                width: r.get.width(M.spacer)
                            }) : r.css(_, {
                                width: "100%"
                            }) : (o["min-width"] = r.get.width(t ? _ : n, !0, !0), o.width = e ? o["min-width"] : "auto"), M.relSize.height ? e ? r.css(_, {
                                height: r.get.height(M.spacer) - (M.pushFollowers ? p.duration : 0)
                            }) : r.css(_, {
                                height: "100%"
                            }) : (o["min-height"] = r.get.height(t ? n : _, !0, !i), o.height = e ? o["min-height"] : "auto"), M.pushFollowers && (o["padding" + (t ? "Top" : "Left")] = p.duration * m, o["padding" + (t ? "Bottom" : "Right")] = p.duration * (1 - m)), r.css(M.spacer, o)
                        }
                    },
                    k = function () {
                        a && _ && f === c && !a.info("isDocument") && O()
                    },
                    N = function () {
                        a && _ && f === c && ((M.relSize.width || M.relSize.autoFullWidth) && r.get.width(window) != r.get.width(M.spacer.parentNode) || M.relSize.height && r.get.height(window) != r.get.height(M.spacer.parentNode)) && D()
                    },
                    I = function (e) {
                        a && _ && f === c && !a.info("isDocument") && (e.preventDefault(), a._setScrollPos(a.info("scrollPos") - ((e.wheelDelta || e[a.info("vertical") ? "wheelDeltaY" : "wheelDeltaX"]) / 3 || 30 * -e.detail)))
                    };
                this.setPin = function (e, n) {
                    var i = {
                        pushFollowers: !0,
                        spacerClass: "scrollmagic-pin-spacer"
                    },
                        o = n && n.hasOwnProperty("pushFollowers");
                    if (n = r.extend({}, i, n), !(e = r.get.elements(e)[0])) return b(1, "ERROR calling method 'setPin()': Invalid pin element supplied."), d;
                    if ("fixed" === r.css(e, "position")) return b(1, "ERROR calling method 'setPin()': Pin does not work with elements that are positioned 'fixed'."), d;
                    if (_) {
                        if (_ === e) return d;
                        d.removePin()
                    }
                    var a = (_ = e).parentNode.style.display,
                        s = ["top", "left", "bottom", "right", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];
                    _.parentNode.style.display = "none";
                    var l = "absolute" != r.css(_, "position"),
                        c = r.css(_, s.concat(["display"])),
                        u = r.css(_, ["width", "height"]);
                    _.parentNode.style.display = a, !l && n.pushFollowers && (b(2, "WARNING: If the pinned element is positioned absolutely pushFollowers will be disabled."), n.pushFollowers = !1), window.setTimeout((function () {
                        _ && 0 === p.duration && o && n.pushFollowers && b(2, "WARNING: pushFollowers =", !0, "has no effect, when scene duration is 0.")
                    }), 0);
                    var h = _.parentNode.insertBefore(document.createElement("div"), _),
                        f = r.extend(c, {
                            position: l ? "relative" : "absolute",
                            boxSizing: "content-box",
                            mozBoxSizing: "content-box",
                            webkitBoxSizing: "content-box"
                        });
                    if (l || r.extend(f, r.css(_, ["width", "height"])), r.css(h, f), h.setAttribute(t, ""), r.addClass(h, n.spacerClass), M = {
                        spacer: h,
                        relSize: {
                            width: "%" === u.width.slice(-1),
                            height: "%" === u.height.slice(-1),
                            autoFullWidth: "auto" === u.width && l && r.isMarginCollapseType(c.display)
                        },
                        pushFollowers: n.pushFollowers,
                        inFlow: l
                    }, !_.___origStyle) {
                        _.___origStyle = {};
                        var m = _.style;
                        s.concat(["width", "height", "position", "boxSizing", "mozBoxSizing", "webkitBoxSizing"]).forEach((function (e) {
                            _.___origStyle[e] = m[e] || ""
                        }))
                    }
                    return M.relSize.width && r.css(h, {
                        width: u.width
                    }), M.relSize.height && r.css(h, {
                        height: u.height
                    }), h.appendChild(_), r.css(_, {
                        position: l ? "relative" : "absolute",
                        margin: "auto",
                        top: "auto",
                        left: "auto",
                        bottom: "auto",
                        right: "auto"
                    }), (M.relSize.width || M.relSize.autoFullWidth) && r.css(_, {
                        boxSizing: "border-box",
                        mozBoxSizing: "border-box",
                        webkitBoxSizing: "border-box"
                    }), window.addEventListener("scroll", k), window.addEventListener("resize", k), window.addEventListener("resize", N), _.addEventListener("mousewheel", I), _.addEventListener("DOMMouseScroll", I), b(3, "added pin"), O(), d
                }, this.removePin = function (e) {
                    if (_) {
                        if (f === c && O(!0), e || !a) {
                            var n = M.spacer.firstChild;
                            if (n.hasAttribute(t)) {
                                var i = M.spacer.style,
                                    o = {};
                                ["margin", "marginLeft", "marginRight", "marginTop", "marginBottom"].forEach((function (e) {
                                    o[e] = i[e] || ""
                                })), r.css(n, o)
                            }
                            M.spacer.parentNode.insertBefore(n, M.spacer), M.spacer.parentNode.removeChild(M.spacer), _.parentNode.hasAttribute(t) || (r.css(_, _.___origStyle), delete _.___origStyle)
                        }
                        window.removeEventListener("scroll", k), window.removeEventListener("resize", k), window.removeEventListener("resize", N), _.removeEventListener("mousewheel", I), _.removeEventListener("DOMMouseScroll", I), _ = void 0, b(3, "removed pin (reset: " + (e ? "true" : "false") + ")")
                    }
                    return d
                };
                var z, F = [];
                return d.on("destroy.internal", (function (e) {
                    d.removeClassToggle(e.reset)
                })), this.setClassToggle = function (e, t) {
                    var n = r.get.elements(e);
                    return 0 !== n.length && r.type.String(t) ? (F.length > 0 && d.removeClassToggle(), z = t, F = n, d.on("enter.internal_class leave.internal_class", (function (e) {
                        var t = "enter" === e.type ? r.addClass : r.removeClass;
                        F.forEach((function (e, n) {
                            t(e, z)
                        }))
                    })), d) : (b(1, "ERROR calling method 'setClassToggle()': Invalid " + (0 === n.length ? "element" : "classes") + " supplied."), d)
                }, this.removeClassToggle = function (e) {
                    return e && F.forEach((function (e, t) {
                        r.removeClass(e, z)
                    })), d.off("start.internal_class end.internal_class"), z = void 0, F = [], d
                }, x(), d
            };
            var i = {
                defaults: {
                    duration: 0,
                    offset: 0,
                    triggerElement: void 0,
                    triggerHook: .5,
                    reverse: !0,
                    loglevel: 2
                },
                validate: {
                    offset: function (e) {
                        if (e = parseFloat(e), !r.type.Number(e)) throw ['Invalid value for option "offset":', e];
                        return e
                    },
                    triggerElement: function (e) {
                        if (e = e || void 0) {
                            var t = r.get.elements(e)[0];
                            if (!t || !t.parentNode) throw ['Element defined in option "triggerElement" was not found:', e];
                            e = t
                        }
                        return e
                    },
                    triggerHook: function (e) {
                        var t = {
                            onCenter: .5,
                            onEnter: 1,
                            onLeave: 0
                        };
                        if (r.type.Number(e)) e = Math.max(0, Math.min(parseFloat(e), 1));
                        else {
                            if (!(e in t)) throw ['Invalid value for option "triggerHook": ', e];
                            e = t[e]
                        }
                        return e
                    },
                    reverse: function (e) {
                        return !!e
                    },
                    loglevel: function (e) {
                        if (e = parseInt(e), !r.type.Number(e) || e < 0 || e > 3) throw ['Invalid value for option "loglevel":', e];
                        return e
                    }
                },
                shifts: ["duration", "offset", "triggerHook"]
            };
            e.Scene.addOption = function (t, n, r, o) {
                t in i.defaults ? e._util.log(1, "[static] ScrollMagic.Scene -> Cannot add Scene option '" + t + "', because it already exists.") : (i.defaults[t] = n, i.validate[t] = r, o && i.shifts.push(t))
            }, e.Scene.extend = function (t) {
                var n = this;
                e.Scene = function () {
                    return n.apply(this, arguments), this.$super = r.extend({}, this), t.apply(this, arguments) || this
                }, r.extend(e.Scene, n), e.Scene.prototype = n.prototype, e.Scene.prototype.constructor = e.Scene
            }, e.Event = function (e, t, n, i) {
                for (var r in i = i || {}) this[r] = i[r];
                return this.type = e, this.target = this.currentTarget = n, this.namespace = t || "", this.timeStamp = this.timestamp = Date.now(), this
            };
            var r = e._util = function (e) {
                var t, n = {},
                    i = function (e) {
                        return parseFloat(e) || 0
                    },
                    r = function (t) {
                        return t.currentStyle ? t.currentStyle : e.getComputedStyle(t)
                    },
                    o = function (t, n, o, a) {
                        if ((n = n === document ? e : n) === e) a = !1;
                        else if (!f.DomElement(n)) return 0;
                        t = t.charAt(0).toUpperCase() + t.substr(1).toLowerCase();
                        var s = (o ? n["offset" + t] || n["outer" + t] : n["client" + t] || n["inner" + t]) || 0;
                        if (o && a) {
                            var l = r(n);
                            s += "Height" === t ? i(l.marginTop) + i(l.marginBottom) : i(l.marginLeft) + i(l.marginRight)
                        }
                        return s
                    },
                    a = function (e) {
                        return e.replace(/^[^a-z]+([a-z])/g, "$1").replace(/-([a-z])/g, (function (e) {
                            return e[1].toUpperCase()
                        }))
                    };
                n.extend = function (e) {
                    for (e = e || {}, t = 1; t < arguments.length; t++)
                        if (arguments[t])
                            for (var n in arguments[t]) arguments[t].hasOwnProperty(n) && (e[n] = arguments[t][n]);
                    return e
                }, n.isMarginCollapseType = function (e) {
                    return ["block", "flex", "list-item", "table", "-webkit-box"].indexOf(e) > -1
                };
                var s = 0,
                    l = ["ms", "moz", "webkit", "o"],
                    c = e.requestAnimationFrame,
                    u = e.cancelAnimationFrame;
                for (t = 0; !c && t < l.length; ++t) c = e[l[t] + "RequestAnimationFrame"], u = e[l[t] + "CancelAnimationFrame"] || e[l[t] + "CancelRequestAnimationFrame"];
                c || (c = function (t) {
                    var n = (new Date).getTime(),
                        i = Math.max(0, 16 - (n - s)),
                        r = e.setTimeout((function () {
                            t(n + i)
                        }), i);
                    return s = n + i, r
                }), u || (u = function (t) {
                    e.clearTimeout(t)
                }), n.rAF = c.bind(e), n.cAF = u.bind(e);
                var h = ["error", "warn", "log"],
                    d = e.console || {};
                for (d.log = d.log || function () { }, t = 0; t < h.length; t++) {
                    var p = h[t];
                    d[p] || (d[p] = d.log)
                }
                n.log = function (e) {
                    (e > h.length || e <= 0) && (e = h.length);
                    var t = new Date,
                        n = ("0" + t.getHours()).slice(-2) + ":" + ("0" + t.getMinutes()).slice(-2) + ":" + ("0" + t.getSeconds()).slice(-2) + ":" + ("00" + t.getMilliseconds()).slice(-3),
                        i = h[e - 1],
                        r = Array.prototype.splice.call(arguments, 1),
                        o = Function.prototype.bind.call(d[i], d);
                    r.unshift(n), o.apply(d, r)
                };
                var f = n.type = function (e) {
                    return Object.prototype.toString.call(e).replace(/^\[object (.+)\]$/, "$1").toLowerCase()
                };
                f.String = function (e) {
                    return "string" === f(e)
                }, f.Function = function (e) {
                    return "function" === f(e)
                }, f.Array = function (e) {
                    return Array.isArray(e)
                }, f.Number = function (e) {
                    return !f.Array(e) && e - parseFloat(e) + 1 >= 0
                }, f.DomElement = function (e) {
                    return "object" == typeof HTMLElement || "function" == typeof HTMLElement ? e instanceof HTMLElement || e instanceof SVGElement : e && "object" == typeof e && null !== e && 1 === e.nodeType && "string" == typeof e.nodeName
                };
                var m = n.get = {};
                return m.elements = function (t) {
                    var n = [];
                    if (f.String(t)) try {
                        t = document.querySelectorAll(t)
                    } catch (e) {
                        return n
                    }
                    if ("nodelist" === f(t) || f.Array(t) || t instanceof NodeList)
                        for (var i = 0, r = n.length = t.length; i < r; i++) {
                            var o = t[i];
                            n[i] = f.DomElement(o) ? o : m.elements(o)
                        } else (f.DomElement(t) || t === document || t === e) && (n = [t]);
                    return n
                }, m.scrollTop = function (t) {
                    return t && "number" == typeof t.scrollTop ? t.scrollTop : e.pageYOffset || 0
                }, m.scrollLeft = function (t) {
                    return t && "number" == typeof t.scrollLeft ? t.scrollLeft : e.pageXOffset || 0
                }, m.width = function (e, t, n) {
                    return o("width", e, t, n)
                }, m.height = function (e, t, n) {
                    return o("height", e, t, n)
                }, m.offset = function (e, t) {
                    var n = {
                        top: 0,
                        left: 0
                    };
                    if (e && e.getBoundingClientRect) {
                        var i = e.getBoundingClientRect();
                        n.top = i.top, n.left = i.left, t || (n.top += m.scrollTop(), n.left += m.scrollLeft())
                    }
                    return n
                }, n.addClass = function (e, t) {
                    t && (e.classList ? e.classList.add(t) : e.className += " " + t)
                }, n.removeClass = function (e, t) {
                    t && (e.classList ? e.classList.remove(t) : e.className = e.className.replace(new RegExp("(^|\\b)" + t.split(" ").join("|") + "(\\b|$)", "gi"), " "))
                }, n.css = function (e, t) {
                    if (f.String(t)) return r(e)[a(t)];
                    if (f.Array(t)) {
                        var n = {},
                            i = r(e);
                        return t.forEach((function (e, t) {
                            n[e] = i[a(e)]
                        })), n
                    }
                    for (var o in t) {
                        var s = t[o];
                        s == parseFloat(s) && (s += "px"), e.style[a(o)] = s
                    }
                }, n
            }(window || {});
            return e.Scene.prototype.addIndicators = function () {
                return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling addIndicators() due to missing Plugin 'debug.addIndicators'. Please make sure to include plugins/debug.addIndicators.js"), this
            }, e.Scene.prototype.removeIndicators = function () {
                return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeIndicators() due to missing Plugin 'debug.addIndicators'. Please make sure to include plugins/debug.addIndicators.js"), this
            }, e.Scene.prototype.setTween = function () {
                return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling setTween() due to missing Plugin 'animation.gsap'. Please make sure to include plugins/animation.gsap.js"), this
            }, e.Scene.prototype.removeTween = function () {
                return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeTween() due to missing Plugin 'animation.gsap'. Please make sure to include plugins/animation.gsap.js"), this
            }, e.Scene.prototype.setVelocity = function () {
                return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling setVelocity() due to missing Plugin 'animation.velocity'. Please make sure to include plugins/animation.velocity.js"), this
            }, e.Scene.prototype.removeVelocity = function () {
                return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeVelocity() due to missing Plugin 'animation.velocity'. Please make sure to include plugins/animation.velocity.js"), this
            }, e
        }) ? i.call(t, n, t, e) : i) || (e.exports = r)
    }, function (e, t, n) {
        ! function (e) {
            "use strict";
            var t, n, i, r, o, a, s, l = function () {
                return "undefined" != typeof window
            },
                c = function () {
                    return t || l() && (t = window.gsap) && t.registerPlugin && t
                },
                u = function (e) {
                    return "string" == typeof e
                },
                h = function (e) {
                    return "function" == typeof e
                },
                d = function (e, t) {
                    var n = "x" === t ? "Width" : "Height",
                        a = "scroll" + n,
                        s = "client" + n;
                    return e === i || e === r || e === o ? Math.max(r[a], o[a]) - (i["inner" + n] || r[s] || o[s]) : e[a] - e["offset" + n]
                },
                p = function (e, t) {
                    var n = "scroll" + ("x" === t ? "Left" : "Top");
                    return e === i && (null != e.pageXOffset ? n = "page" + t.toUpperCase() + "Offset" : e = null != r[n] ? r : o),
                        function () {
                            return e[n]
                        }
                },
                f = function (e, t, n, i) {
                    if (h(e) && (e = e(t, n, i)), "object" != typeof e) return u(e) && "max" !== e && "=" !== e.charAt(1) ? {
                        x: e,
                        y: e
                    } : {
                        y: e
                    };
                    if (e.nodeType) return {
                        y: e,
                        x: e
                    };
                    var r, o = {};
                    for (r in e) o[r] = "onAutoKill" !== r && h(e[r]) ? e[r](t, n, i) : e[r];
                    return o
                },
                m = function (e, t) {
                    if (!(e = a(e)[0]) || !e.getBoundingClientRect) return console.warn("scrollTo target doesn't exist. Using 0") || {
                        x: 0,
                        y: 0
                    };
                    var n = e.getBoundingClientRect(),
                        s = !t || t === i || t === o,
                        l = s ? {
                            top: r.clientTop - (i.pageYOffset || r.scrollTop || o.scrollTop || 0),
                            left: r.clientLeft - (i.pageXOffset || r.scrollLeft || o.scrollLeft || 0)
                        } : t.getBoundingClientRect(),
                        c = {
                            x: n.left - l.left,
                            y: n.top - l.top
                        };
                    return !s && t && (c.x += p(t, "x")(), c.y += p(t, "y")()), c
                },
                g = function (e, t, n, i, r) {
                    return isNaN(e) || "object" == typeof e ? u(e) && "=" === e.charAt(1) ? parseFloat(e.substr(2)) * ("-" === e.charAt(0) ? -1 : 1) + i - r : "max" === e ? d(t, n) - r : Math.min(d(t, n), m(e, t)[n] - r) : parseFloat(e) - r
                },
                v = function () {
                    t = c(), l() && t && document.body && (i = window, o = document.body, r = document.documentElement, a = t.utils.toArray, t.config({
                        autoKillThreshold: 7
                    }), s = t.config(), n = 1)
                },
                y = {
                    version: "3.6.1",
                    name: "scrollTo",
                    rawVars: 1,
                    register: function (e) {
                        t = e, v()
                    },
                    init: function (e, t, r, o, a) {
                        n || v();
                        var s = this;
                        s.isWin = e === i, s.target = e, s.tween = r, t = f(t, o, e, a), s.vars = t, s.autoKill = !!t.autoKill, s.getX = p(e, "x"), s.getY = p(e, "y"), s.x = s.xPrev = s.getX(), s.y = s.yPrev = s.getY(), null != t.x ? (s.add(s, "x", s.x, g(t.x, e, "x", s.x, t.offsetX || 0), o, a), s._props.push("scrollTo_x")) : s.skipX = 1, null != t.y ? (s.add(s, "y", s.y, g(t.y, e, "y", s.y, t.offsetY || 0), o, a), s._props.push("scrollTo_y")) : s.skipY = 1
                    },
                    render: function (e, t) {
                        for (var n, r, o, a, l, c = t._pt, u = t.target, h = t.tween, p = t.autoKill, f = t.xPrev, m = t.yPrev, g = t.isWin; c;) c.r(e, c.d), c = c._next;
                        n = g || !t.skipX ? t.getX() : f, o = (r = g || !t.skipY ? t.getY() : m) - m, a = n - f, l = s.autoKillThreshold, t.x < 0 && (t.x = 0), t.y < 0 && (t.y = 0), p && (!t.skipX && (a > l || a < -l) && n < d(u, "x") && (t.skipX = 1), !t.skipY && (o > l || o < -l) && r < d(u, "y") && (t.skipY = 1), t.skipX && t.skipY && (h.kill(), t.vars.onAutoKill && t.vars.onAutoKill.apply(h, t.vars.onAutoKillParams || []))), g ? i.scrollTo(t.skipX ? n : t.x, t.skipY ? r : t.y) : (t.skipY || (u.scrollTop = t.y), t.skipX || (u.scrollLeft = t.x)), t.xPrev = t.x, t.yPrev = t.y
                    },
                    kill: function (e) {
                        var t = "scrollTo" === e;
                        (t || "scrollTo_x" === e) && (this.skipX = 1), (t || "scrollTo_y" === e) && (this.skipY = 1)
                    }
                };
            y.max = d, y.getOffset = m, y.buildGetter = p, c() && t.registerPlugin(y), e.ScrollToPlugin = y, e.default = y, Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }(t)
    }, function (e, t, n) {
        var i, r, o;
        ! function (a) {
            "use strict";
            r = [n(0)], void 0 === (o = "function" == typeof (i = function (e) {
                var t = window.Slick || {};
                (t = function () {
                    var t = 0;

                    function n(n, i) {
                        var r, o = this;
                        o.defaults = {
                            accessibility: !0,
                            adaptiveHeight: !1,
                            appendArrows: e(n),
                            appendDots: e(n),
                            arrows: !0,
                            asNavFor: null,
                            prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
                            nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
                            autoplay: !1,
                            autoplaySpeed: 3e3,
                            centerMode: !1,
                            centerPadding: "50px",
                            cssEase: "ease",
                            customPaging: function (t, n) {
                                return e('<button type="button" />').text(n + 1)
                            },
                            dots: !1,
                            dotsClass: "slick-dots",
                            draggable: !0,
                            easing: "linear",
                            edgeFriction: .35,
                            fade: !1,
                            focusOnSelect: !1,
                            focusOnChange: !1,
                            infinite: !0,
                            initialSlide: 0,
                            lazyLoad: "ondemand",
                            mobileFirst: !1,
                            pauseOnHover: !0,
                            pauseOnFocus: !0,
                            pauseOnDotsHover: !1,
                            respondTo: "window",
                            responsive: null,
                            rows: 1,
                            rtl: !1,
                            slide: "",
                            slidesPerRow: 1,
                            slidesToShow: 1,
                            slidesToScroll: 1,
                            speed: 500,
                            swipe: !0,
                            swipeToSlide: !1,
                            touchMove: !0,
                            touchThreshold: 5,
                            useCSS: !0,
                            useTransform: !0,
                            variableWidth: !1,
                            vertical: !1,
                            verticalSwiping: !1,
                            waitForAnimate: !0,
                            zIndex: 1e3
                        }, o.initials = {
                            animating: !1,
                            dragging: !1,
                            autoPlayTimer: null,
                            currentDirection: 0,
                            currentLeft: null,
                            currentSlide: 0,
                            direction: 1,
                            $dots: null,
                            listWidth: null,
                            listHeight: null,
                            loadIndex: 0,
                            $nextArrow: null,
                            $prevArrow: null,
                            scrolling: !1,
                            slideCount: null,
                            slideWidth: null,
                            $slideTrack: null,
                            $slides: null,
                            sliding: !1,
                            slideOffset: 0,
                            swipeLeft: null,
                            swiping: !1,
                            $list: null,
                            touchObject: {},
                            transformsEnabled: !1,
                            unslicked: !1
                        }, e.extend(o, o.initials), o.activeBreakpoint = null, o.animType = null, o.animProp = null, o.breakpoints = [], o.breakpointSettings = [], o.cssTransitions = !1, o.focussed = !1, o.interrupted = !1, o.hidden = "hidden", o.paused = !0, o.positionProp = null, o.respondTo = null, o.rowCount = 1, o.shouldClick = !0, o.$slider = e(n), o.$slidesCache = null, o.transformType = null, o.transitionType = null, o.visibilityChange = "visibilitychange", o.windowWidth = 0, o.windowTimer = null, r = e(n).data("slick") || {}, o.options = e.extend({}, o.defaults, i, r), o.currentSlide = o.options.initialSlide, o.originalSettings = o.options, void 0 !== document.mozHidden ? (o.hidden = "mozHidden", o.visibilityChange = "mozvisibilitychange") : void 0 !== document.webkitHidden && (o.hidden = "webkitHidden", o.visibilityChange = "webkitvisibilitychange"), o.autoPlay = e.proxy(o.autoPlay, o), o.autoPlayClear = e.proxy(o.autoPlayClear, o), o.autoPlayIterator = e.proxy(o.autoPlayIterator, o), o.changeSlide = e.proxy(o.changeSlide, o), o.clickHandler = e.proxy(o.clickHandler, o), o.selectHandler = e.proxy(o.selectHandler, o), o.setPosition = e.proxy(o.setPosition, o), o.swipeHandler = e.proxy(o.swipeHandler, o), o.dragHandler = e.proxy(o.dragHandler, o), o.keyHandler = e.proxy(o.keyHandler, o), o.instanceUid = t++, o.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/, o.registerBreakpoints(), o.init(!0)
                    }
                    return n
                }()).prototype.activateADA = function () {
                    this.$slideTrack.find(".slick-active").attr({
                        "aria-hidden": "false"
                    }).find("a, input, button, select").attr({
                        tabindex: "0"
                    })
                }, t.prototype.addSlide = t.prototype.slickAdd = function (t, n, i) {
                    var r = this;
                    if ("boolean" == typeof n) i = n, n = null;
                    else if (n < 0 || n >= r.slideCount) return !1;
                    r.unload(), "number" == typeof n ? 0 === n && 0 === r.$slides.length ? e(t).appendTo(r.$slideTrack) : i ? e(t).insertBefore(r.$slides.eq(n)) : e(t).insertAfter(r.$slides.eq(n)) : !0 === i ? e(t).prependTo(r.$slideTrack) : e(t).appendTo(r.$slideTrack), r.$slides = r.$slideTrack.children(this.options.slide), r.$slideTrack.children(this.options.slide).detach(), r.$slideTrack.append(r.$slides), r.$slides.each((function (t, n) {
                        e(n).attr("data-slick-index", t)
                    })), r.$slidesCache = r.$slides, r.reinit()
                }, t.prototype.animateHeight = function () {
                    var e = this;
                    if (1 === e.options.slidesToShow && !0 === e.options.adaptiveHeight && !1 === e.options.vertical) {
                        var t = e.$slides.eq(e.currentSlide).outerHeight(!0);
                        e.$list.animate({
                            height: t
                        }, e.options.speed)
                    }
                }, t.prototype.animateSlide = function (t, n) {
                    var i = {},
                        r = this;
                    r.animateHeight(), !0 === r.options.rtl && !1 === r.options.vertical && (t = -t), !1 === r.transformsEnabled ? !1 === r.options.vertical ? r.$slideTrack.animate({
                        left: t
                    }, r.options.speed, r.options.easing, n) : r.$slideTrack.animate({
                        top: t
                    }, r.options.speed, r.options.easing, n) : !1 === r.cssTransitions ? (!0 === r.options.rtl && (r.currentLeft = -r.currentLeft), e({
                        animStart: r.currentLeft
                    }).animate({
                        animStart: t
                    }, {
                        duration: r.options.speed,
                        easing: r.options.easing,
                        step: function (e) {
                            e = Math.ceil(e), !1 === r.options.vertical ? (i[r.animType] = "translate(" + e + "px, 0px)", r.$slideTrack.css(i)) : (i[r.animType] = "translate(0px," + e + "px)", r.$slideTrack.css(i))
                        },
                        complete: function () {
                            n && n.call()
                        }
                    })) : (r.applyTransition(), t = Math.ceil(t), !1 === r.options.vertical ? i[r.animType] = "translate3d(" + t + "px, 0px, 0px)" : i[r.animType] = "translate3d(0px," + t + "px, 0px)", r.$slideTrack.css(i), n && setTimeout((function () {
                        r.disableTransition(), n.call()
                    }), r.options.speed))
                }, t.prototype.getNavTarget = function () {
                    var t = this,
                        n = t.options.asNavFor;
                    return n && null !== n && (n = e(n).not(t.$slider)), n
                }, t.prototype.asNavFor = function (t) {
                    var n = this.getNavTarget();
                    null !== n && "object" == typeof n && n.each((function () {
                        var n = e(this).slick("getSlick");
                        n.unslicked || n.slideHandler(t, !0)
                    }))
                }, t.prototype.applyTransition = function (e) {
                    var t = this,
                        n = {};
                    !1 === t.options.fade ? n[t.transitionType] = t.transformType + " " + t.options.speed + "ms " + t.options.cssEase : n[t.transitionType] = "opacity " + t.options.speed + "ms " + t.options.cssEase, !1 === t.options.fade ? t.$slideTrack.css(n) : t.$slides.eq(e).css(n)
                }, t.prototype.autoPlay = function () {
                    var e = this;
                    e.autoPlayClear(), e.slideCount > e.options.slidesToShow && (e.autoPlayTimer = setInterval(e.autoPlayIterator, e.options.autoplaySpeed))
                }, t.prototype.autoPlayClear = function () {
                    var e = this;
                    e.autoPlayTimer && clearInterval(e.autoPlayTimer)
                }, t.prototype.autoPlayIterator = function () {
                    var e = this,
                        t = e.currentSlide + e.options.slidesToScroll;
                    e.paused || e.interrupted || e.focussed || (!1 === e.options.infinite && (1 === e.direction && e.currentSlide + 1 === e.slideCount - 1 ? e.direction = 0 : 0 === e.direction && (t = e.currentSlide - e.options.slidesToScroll, e.currentSlide - 1 == 0 && (e.direction = 1))), e.slideHandler(t))
                }, t.prototype.buildArrows = function () {
                    var t = this;
                    !0 === t.options.arrows && (t.$prevArrow = e(t.options.prevArrow).addClass("slick-arrow"), t.$nextArrow = e(t.options.nextArrow).addClass("slick-arrow"), t.slideCount > t.options.slidesToShow ? (t.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), t.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), t.htmlExpr.test(t.options.prevArrow) && t.$prevArrow.prependTo(t.options.appendArrows), t.htmlExpr.test(t.options.nextArrow) && t.$nextArrow.appendTo(t.options.appendArrows), !0 !== t.options.infinite && t.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true")) : t.$prevArrow.add(t.$nextArrow).addClass("slick-hidden").attr({
                        "aria-disabled": "true",
                        tabindex: "-1"
                    }))
                }, t.prototype.buildDots = function () {
                    var t, n, i = this;
                    if (!0 === i.options.dots && i.slideCount > i.options.slidesToShow) {
                        for (i.$slider.addClass("slick-dotted"), n = e("<ul />").addClass(i.options.dotsClass), t = 0; t <= i.getDotCount(); t += 1) n.append(e("<li />").append(i.options.customPaging.call(this, i, t)));
                        i.$dots = n.appendTo(i.options.appendDots), i.$dots.find("li").first().addClass("slick-active")
                    }
                }, t.prototype.buildOut = function () {
                    var t = this;
                    t.$slides = t.$slider.children(t.options.slide + ":not(.slick-cloned)").addClass("slick-slide"), t.slideCount = t.$slides.length, t.$slides.each((function (t, n) {
                        e(n).attr("data-slick-index", t).data("originalStyling", e(n).attr("style") || "")
                    })), t.$slider.addClass("slick-slider"), t.$slideTrack = 0 === t.slideCount ? e('<div class="slick-track"/>').appendTo(t.$slider) : t.$slides.wrapAll('<div class="slick-track"/>').parent(), t.$list = t.$slideTrack.wrap('<div class="slick-list"/>').parent(), t.$slideTrack.css("opacity", 0), !0 !== t.options.centerMode && !0 !== t.options.swipeToSlide || (t.options.slidesToScroll = 1), e("img[data-lazy]", t.$slider).not("[src]").addClass("slick-loading"), t.setupInfinite(), t.buildArrows(), t.buildDots(), t.updateDots(), t.setSlideClasses("number" == typeof t.currentSlide ? t.currentSlide : 0), !0 === t.options.draggable && t.$list.addClass("draggable")
                }, t.prototype.buildRows = function () {
                    var e, t, n, i, r, o, a, s = this;
                    if (i = document.createDocumentFragment(), o = s.$slider.children(), s.options.rows > 0) {
                        for (a = s.options.slidesPerRow * s.options.rows, r = Math.ceil(o.length / a), e = 0; e < r; e++) {
                            var l = document.createElement("div");
                            for (t = 0; t < s.options.rows; t++) {
                                var c = document.createElement("div");
                                for (n = 0; n < s.options.slidesPerRow; n++) {
                                    var u = e * a + (t * s.options.slidesPerRow + n);
                                    o.get(u) && c.appendChild(o.get(u))
                                }
                                l.appendChild(c)
                            }
                            i.appendChild(l)
                        }
                        s.$slider.empty().append(i), s.$slider.children().children().children().css({
                            width: 100 / s.options.slidesPerRow + "%",
                            display: "inline-block"
                        })
                    }
                }, t.prototype.checkResponsive = function (t, n) {
                    var i, r, o, a = this,
                        s = !1,
                        l = a.$slider.width(),
                        c = window.innerWidth || e(window).width();
                    if ("window" === a.respondTo ? o = c : "slider" === a.respondTo ? o = l : "min" === a.respondTo && (o = Math.min(c, l)), a.options.responsive && a.options.responsive.length && null !== a.options.responsive) {
                        for (i in r = null, a.breakpoints) a.breakpoints.hasOwnProperty(i) && (!1 === a.originalSettings.mobileFirst ? o < a.breakpoints[i] && (r = a.breakpoints[i]) : o > a.breakpoints[i] && (r = a.breakpoints[i]));
                        null !== r ? null !== a.activeBreakpoint ? (r !== a.activeBreakpoint || n) && (a.activeBreakpoint = r, "unslick" === a.breakpointSettings[r] ? a.unslick(r) : (a.options = e.extend({}, a.originalSettings, a.breakpointSettings[r]), !0 === t && (a.currentSlide = a.options.initialSlide), a.refresh(t)), s = r) : (a.activeBreakpoint = r, "unslick" === a.breakpointSettings[r] ? a.unslick(r) : (a.options = e.extend({}, a.originalSettings, a.breakpointSettings[r]), !0 === t && (a.currentSlide = a.options.initialSlide), a.refresh(t)), s = r) : null !== a.activeBreakpoint && (a.activeBreakpoint = null, a.options = a.originalSettings, !0 === t && (a.currentSlide = a.options.initialSlide), a.refresh(t), s = r), t || !1 === s || a.$slider.trigger("breakpoint", [a, s])
                    }
                }, t.prototype.changeSlide = function (t, n) {
                    var i, r, o = this,
                        a = e(t.currentTarget);
                    switch (a.is("a") && t.preventDefault(), a.is("li") || (a = a.closest("li")), i = o.slideCount % o.options.slidesToScroll != 0 ? 0 : (o.slideCount - o.currentSlide) % o.options.slidesToScroll, t.data.message) {
                        case "previous":
                            r = 0 === i ? o.options.slidesToScroll : o.options.slidesToShow - i, o.slideCount > o.options.slidesToShow && o.slideHandler(o.currentSlide - r, !1, n);
                            break;
                        case "next":
                            r = 0 === i ? o.options.slidesToScroll : i, o.slideCount > o.options.slidesToShow && o.slideHandler(o.currentSlide + r, !1, n);
                            break;
                        case "index":
                            var s = 0 === t.data.index ? 0 : t.data.index || a.index() * o.options.slidesToScroll;
                            o.slideHandler(o.checkNavigable(s), !1, n), a.children().trigger("focus");
                            break;
                        default:
                            return
                    }
                }, t.prototype.checkNavigable = function (e) {
                    var t, n;
                    if (n = 0, e > (t = this.getNavigableIndexes())[t.length - 1]) e = t[t.length - 1];
                    else
                        for (var i in t) {
                            if (e < t[i]) {
                                e = n;
                                break
                            }
                            n = t[i]
                        }
                    return e
                }, t.prototype.cleanUpEvents = function () {
                    var t = this;
                    t.options.dots && null !== t.$dots && (e("li", t.$dots).off("click.slick", t.changeSlide).off("mouseenter.slick", e.proxy(t.interrupt, t, !0)).off("mouseleave.slick", e.proxy(t.interrupt, t, !1)), !0 === t.options.accessibility && t.$dots.off("keydown.slick", t.keyHandler)), t.$slider.off("focus.slick blur.slick"), !0 === t.options.arrows && t.slideCount > t.options.slidesToShow && (t.$prevArrow && t.$prevArrow.off("click.slick", t.changeSlide), t.$nextArrow && t.$nextArrow.off("click.slick", t.changeSlide), !0 === t.options.accessibility && (t.$prevArrow && t.$prevArrow.off("keydown.slick", t.keyHandler), t.$nextArrow && t.$nextArrow.off("keydown.slick", t.keyHandler))), t.$list.off("touchstart.slick mousedown.slick", t.swipeHandler), t.$list.off("touchmove.slick mousemove.slick", t.swipeHandler), t.$list.off("touchend.slick mouseup.slick", t.swipeHandler), t.$list.off("touchcancel.slick mouseleave.slick", t.swipeHandler), t.$list.off("click.slick", t.clickHandler), e(document).off(t.visibilityChange, t.visibility), t.cleanUpSlideEvents(), !0 === t.options.accessibility && t.$list.off("keydown.slick", t.keyHandler), !0 === t.options.focusOnSelect && e(t.$slideTrack).children().off("click.slick", t.selectHandler), e(window).off("orientationchange.slick.slick-" + t.instanceUid, t.orientationChange), e(window).off("resize.slick.slick-" + t.instanceUid, t.resize), e("[draggable!=true]", t.$slideTrack).off("dragstart", t.preventDefault), e(window).off("load.slick.slick-" + t.instanceUid, t.setPosition)
                }, t.prototype.cleanUpSlideEvents = function () {
                    var t = this;
                    t.$list.off("mouseenter.slick", e.proxy(t.interrupt, t, !0)), t.$list.off("mouseleave.slick", e.proxy(t.interrupt, t, !1))
                }, t.prototype.cleanUpRows = function () {
                    var e, t = this;
                    t.options.rows > 0 && ((e = t.$slides.children().children()).removeAttr("style"), t.$slider.empty().append(e))
                }, t.prototype.clickHandler = function (e) {
                    !1 === this.shouldClick && (e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault())
                }, t.prototype.destroy = function (t) {
                    var n = this;
                    n.autoPlayClear(), n.touchObject = {}, n.cleanUpEvents(), e(".slick-cloned", n.$slider).detach(), n.$dots && n.$dots.remove(), n.$prevArrow && n.$prevArrow.length && (n.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), n.htmlExpr.test(n.options.prevArrow) && n.$prevArrow.remove()), n.$nextArrow && n.$nextArrow.length && (n.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), n.htmlExpr.test(n.options.nextArrow) && n.$nextArrow.remove()), n.$slides && (n.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each((function () {
                        e(this).attr("style", e(this).data("originalStyling"))
                    })), n.$slideTrack.children(this.options.slide).detach(), n.$slideTrack.detach(), n.$list.detach(), n.$slider.append(n.$slides)), n.cleanUpRows(), n.$slider.removeClass("slick-slider"), n.$slider.removeClass("slick-initialized"), n.$slider.removeClass("slick-dotted"), n.unslicked = !0, t || n.$slider.trigger("destroy", [n])
                }, t.prototype.disableTransition = function (e) {
                    var t = this,
                        n = {};
                    n[t.transitionType] = "", !1 === t.options.fade ? t.$slideTrack.css(n) : t.$slides.eq(e).css(n)
                }, t.prototype.fadeSlide = function (e, t) {
                    var n = this;
                    !1 === n.cssTransitions ? (n.$slides.eq(e).css({
                        zIndex: n.options.zIndex
                    }), n.$slides.eq(e).animate({
                        opacity: 1
                    }, n.options.speed, n.options.easing, t)) : (n.applyTransition(e), n.$slides.eq(e).css({
                        opacity: 1,
                        zIndex: n.options.zIndex
                    }), t && setTimeout((function () {
                        n.disableTransition(e), t.call()
                    }), n.options.speed))
                }, t.prototype.fadeSlideOut = function (e) {
                    var t = this;
                    !1 === t.cssTransitions ? t.$slides.eq(e).animate({
                        opacity: 0,
                        zIndex: t.options.zIndex - 2
                    }, t.options.speed, t.options.easing) : (t.applyTransition(e), t.$slides.eq(e).css({
                        opacity: 0,
                        zIndex: t.options.zIndex - 2
                    }))
                }, t.prototype.filterSlides = t.prototype.slickFilter = function (e) {
                    var t = this;
                    null !== e && (t.$slidesCache = t.$slides, t.unload(), t.$slideTrack.children(this.options.slide).detach(), t.$slidesCache.filter(e).appendTo(t.$slideTrack), t.reinit())
                }, t.prototype.focusHandler = function () {
                    var t = this;
                    t.$slider.off("focus.slick blur.slick").on("focus.slick blur.slick", "*", (function (n) {
                        n.stopImmediatePropagation();
                        var i = e(this);
                        setTimeout((function () {
                            t.options.pauseOnFocus && (t.focussed = i.is(":focus"), t.autoPlay())
                        }), 0)
                    }))
                }, t.prototype.getCurrent = t.prototype.slickCurrentSlide = function () {
                    return this.currentSlide
                }, t.prototype.getDotCount = function () {
                    var e = this,
                        t = 0,
                        n = 0,
                        i = 0;
                    if (!0 === e.options.infinite)
                        if (e.slideCount <= e.options.slidesToShow) ++i;
                        else
                            for (; t < e.slideCount;) ++i, t = n + e.options.slidesToScroll, n += e.options.slidesToScroll <= e.options.slidesToShow ? e.options.slidesToScroll : e.options.slidesToShow;
                    else if (!0 === e.options.centerMode) i = e.slideCount;
                    else if (e.options.asNavFor)
                        for (; t < e.slideCount;) ++i, t = n + e.options.slidesToScroll, n += e.options.slidesToScroll <= e.options.slidesToShow ? e.options.slidesToScroll : e.options.slidesToShow;
                    else i = 1 + Math.ceil((e.slideCount - e.options.slidesToShow) / e.options.slidesToScroll);
                    return i - 1
                }, t.prototype.getLeft = function (e) {
                    var t, n, i, r, o = this,
                        a = 0;
                    return o.slideOffset = 0, n = o.$slides.first().outerHeight(!0), !0 === o.options.infinite ? (o.slideCount > o.options.slidesToShow && (o.slideOffset = o.slideWidth * o.options.slidesToShow * -1, r = -1, !0 === o.options.vertical && !0 === o.options.centerMode && (2 === o.options.slidesToShow ? r = -1.5 : 1 === o.options.slidesToShow && (r = -2)), a = n * o.options.slidesToShow * r), o.slideCount % o.options.slidesToScroll != 0 && e + o.options.slidesToScroll > o.slideCount && o.slideCount > o.options.slidesToShow && (e > o.slideCount ? (o.slideOffset = (o.options.slidesToShow - (e - o.slideCount)) * o.slideWidth * -1, a = (o.options.slidesToShow - (e - o.slideCount)) * n * -1) : (o.slideOffset = o.slideCount % o.options.slidesToScroll * o.slideWidth * -1, a = o.slideCount % o.options.slidesToScroll * n * -1))) : e + o.options.slidesToShow > o.slideCount && (o.slideOffset = (e + o.options.slidesToShow - o.slideCount) * o.slideWidth, a = (e + o.options.slidesToShow - o.slideCount) * n), o.slideCount <= o.options.slidesToShow && (o.slideOffset = 0, a = 0), !0 === o.options.centerMode && o.slideCount <= o.options.slidesToShow ? o.slideOffset = o.slideWidth * Math.floor(o.options.slidesToShow) / 2 - o.slideWidth * o.slideCount / 2 : !0 === o.options.centerMode && !0 === o.options.infinite ? o.slideOffset += o.slideWidth * Math.floor(o.options.slidesToShow / 2) - o.slideWidth : !0 === o.options.centerMode && (o.slideOffset = 0, o.slideOffset += o.slideWidth * Math.floor(o.options.slidesToShow / 2)), t = !1 === o.options.vertical ? e * o.slideWidth * -1 + o.slideOffset : e * n * -1 + a, !0 === o.options.variableWidth && (i = o.slideCount <= o.options.slidesToShow || !1 === o.options.infinite ? o.$slideTrack.children(".slick-slide").eq(e) : o.$slideTrack.children(".slick-slide").eq(e + o.options.slidesToShow), t = !0 === o.options.rtl ? i[0] ? -1 * (o.$slideTrack.width() - i[0].offsetLeft - i.width()) : 0 : i[0] ? -1 * i[0].offsetLeft : 0, !0 === o.options.centerMode && (i = o.slideCount <= o.options.slidesToShow || !1 === o.options.infinite ? o.$slideTrack.children(".slick-slide").eq(e) : o.$slideTrack.children(".slick-slide").eq(e + o.options.slidesToShow + 1), t = !0 === o.options.rtl ? i[0] ? -1 * (o.$slideTrack.width() - i[0].offsetLeft - i.width()) : 0 : i[0] ? -1 * i[0].offsetLeft : 0, t += (o.$list.width() - i.outerWidth()) / 2)), t
                }, t.prototype.getOption = t.prototype.slickGetOption = function (e) {
                    return this.options[e]
                }, t.prototype.getNavigableIndexes = function () {
                    var e, t = this,
                        n = 0,
                        i = 0,
                        r = [];
                    for (!1 === t.options.infinite ? e = t.slideCount : (n = -1 * t.options.slidesToScroll, i = -1 * t.options.slidesToScroll, e = 2 * t.slideCount); n < e;) r.push(n), n = i + t.options.slidesToScroll, i += t.options.slidesToScroll <= t.options.slidesToShow ? t.options.slidesToScroll : t.options.slidesToShow;
                    return r
                }, t.prototype.getSlick = function () {
                    return this
                }, t.prototype.getSlideCount = function () {
                    var t, n, i = this;
                    return n = !0 === i.options.centerMode ? i.slideWidth * Math.floor(i.options.slidesToShow / 2) : 0, !0 === i.options.swipeToSlide ? (i.$slideTrack.find(".slick-slide").each((function (r, o) {
                        if (o.offsetLeft - n + e(o).outerWidth() / 2 > -1 * i.swipeLeft) return t = o, !1
                    })), Math.abs(e(t).attr("data-slick-index") - i.currentSlide) || 1) : i.options.slidesToScroll
                }, t.prototype.goTo = t.prototype.slickGoTo = function (e, t) {
                    this.changeSlide({
                        data: {
                            message: "index",
                            index: parseInt(e)
                        }
                    }, t)
                }, t.prototype.init = function (t) {
                    var n = this;
                    e(n.$slider).hasClass("slick-initialized") || (e(n.$slider).addClass("slick-initialized"), n.buildRows(), n.buildOut(), n.setProps(), n.startLoad(), n.loadSlider(), n.initializeEvents(), n.updateArrows(), n.updateDots(), n.checkResponsive(!0), n.focusHandler()), t && n.$slider.trigger("init", [n]), !0 === n.options.accessibility && n.initADA(), n.options.autoplay && (n.paused = !1, n.autoPlay())
                }, t.prototype.initADA = function () {
                    var t = this,
                        n = Math.ceil(t.slideCount / t.options.slidesToShow),
                        i = t.getNavigableIndexes().filter((function (e) {
                            return e >= 0 && e < t.slideCount
                        }));
                    t.$slides.add(t.$slideTrack.find(".slick-cloned")).attr({
                        "aria-hidden": "true",
                        tabindex: "-1"
                    }).find("a, input, button, select").attr({
                        tabindex: "-1"
                    }), null !== t.$dots && (t.$slides.not(t.$slideTrack.find(".slick-cloned")).each((function (n) {
                        var r = i.indexOf(n);
                        if (e(this).attr({
                            role: "tabpanel",
                            id: "slick-slide" + t.instanceUid + n,
                            tabindex: -1
                        }), -1 !== r) {
                            var o = "slick-slide-control" + t.instanceUid + r;
                            e("#" + o).length && e(this).attr({
                                "aria-describedby": o
                            })
                        }
                    })), t.$dots.attr("role", "tablist").find("li").each((function (r) {
                        var o = i[r];
                        e(this).attr({
                            role: "presentation"
                        }), e(this).find("button").first().attr({
                            role: "tab",
                            id: "slick-slide-control" + t.instanceUid + r,
                            "aria-controls": "slick-slide" + t.instanceUid + o,
                            "aria-label": r + 1 + " of " + n,
                            "aria-selected": null,
                            tabindex: "-1"
                        })
                    })).eq(t.currentSlide).find("button").attr({
                        "aria-selected": "true",
                        tabindex: "0"
                    }).end());
                    for (var r = t.currentSlide, o = r + t.options.slidesToShow; r < o; r++) t.options.focusOnChange ? t.$slides.eq(r).attr({
                        tabindex: "0"
                    }) : t.$slides.eq(r).removeAttr("tabindex");
                    t.activateADA()
                }, t.prototype.initArrowEvents = function () {
                    var e = this;
                    !0 === e.options.arrows && e.slideCount > e.options.slidesToShow && (e.$prevArrow.off("click.slick").on("click.slick", {
                        message: "previous"
                    }, e.changeSlide), e.$nextArrow.off("click.slick").on("click.slick", {
                        message: "next"
                    }, e.changeSlide), !0 === e.options.accessibility && (e.$prevArrow.on("keydown.slick", e.keyHandler), e.$nextArrow.on("keydown.slick", e.keyHandler)))
                }, t.prototype.initDotEvents = function () {
                    var t = this;
                    !0 === t.options.dots && t.slideCount > t.options.slidesToShow && (e("li", t.$dots).on("click.slick", {
                        message: "index"
                    }, t.changeSlide), !0 === t.options.accessibility && t.$dots.on("keydown.slick", t.keyHandler)), !0 === t.options.dots && !0 === t.options.pauseOnDotsHover && t.slideCount > t.options.slidesToShow && e("li", t.$dots).on("mouseenter.slick", e.proxy(t.interrupt, t, !0)).on("mouseleave.slick", e.proxy(t.interrupt, t, !1))
                }, t.prototype.initSlideEvents = function () {
                    var t = this;
                    t.options.pauseOnHover && (t.$list.on("mouseenter.slick", e.proxy(t.interrupt, t, !0)), t.$list.on("mouseleave.slick", e.proxy(t.interrupt, t, !1)))
                }, t.prototype.initializeEvents = function () {
                    var t = this;
                    t.initArrowEvents(), t.initDotEvents(), t.initSlideEvents(), t.$list.on("touchstart.slick mousedown.slick", {
                        action: "start"
                    }, t.swipeHandler), t.$list.on("touchmove.slick mousemove.slick", {
                        action: "move"
                    }, t.swipeHandler), t.$list.on("touchend.slick mouseup.slick", {
                        action: "end"
                    }, t.swipeHandler), t.$list.on("touchcancel.slick mouseleave.slick", {
                        action: "end"
                    }, t.swipeHandler), t.$list.on("click.slick", t.clickHandler), e(document).on(t.visibilityChange, e.proxy(t.visibility, t)), !0 === t.options.accessibility && t.$list.on("keydown.slick", t.keyHandler), !0 === t.options.focusOnSelect && e(t.$slideTrack).children().on("click.slick", t.selectHandler), e(window).on("orientationchange.slick.slick-" + t.instanceUid, e.proxy(t.orientationChange, t)), e(window).on("resize.slick.slick-" + t.instanceUid, e.proxy(t.resize, t)), e("[draggable!=true]", t.$slideTrack).on("dragstart", t.preventDefault), e(window).on("load.slick.slick-" + t.instanceUid, t.setPosition), e(t.setPosition)
                }, t.prototype.initUI = function () {
                    var e = this;
                    !0 === e.options.arrows && e.slideCount > e.options.slidesToShow && (e.$prevArrow.show(), e.$nextArrow.show()), !0 === e.options.dots && e.slideCount > e.options.slidesToShow && e.$dots.show()
                }, t.prototype.keyHandler = function (e) {
                    var t = this;
                    e.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === e.keyCode && !0 === t.options.accessibility ? t.changeSlide({
                        data: {
                            message: !0 === t.options.rtl ? "next" : "previous"
                        }
                    }) : 39 === e.keyCode && !0 === t.options.accessibility && t.changeSlide({
                        data: {
                            message: !0 === t.options.rtl ? "previous" : "next"
                        }
                    }))
                }, t.prototype.lazyLoad = function () {
                    var t, n, i, r = this;

                    function o(t) {
                        e("img[data-lazy]", t).each((function () {
                            var t = e(this),
                                n = e(this).attr("data-lazy"),
                                i = e(this).attr("data-srcset"),
                                o = e(this).attr("data-sizes") || r.$slider.attr("data-sizes"),
                                a = document.createElement("img");
                            a.onload = function () {
                                t.animate({
                                    opacity: 0
                                }, 100, (function () {
                                    i && (t.attr("srcset", i), o && t.attr("sizes", o)), t.attr("src", n).animate({
                                        opacity: 1
                                    }, 200, (function () {
                                        t.removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading")
                                    })), r.$slider.trigger("lazyLoaded", [r, t, n])
                                }))
                            }, a.onerror = function () {
                                t.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), r.$slider.trigger("lazyLoadError", [r, t, n])
                            }, a.src = n
                        }))
                    }
                    if (!0 === r.options.centerMode ? !0 === r.options.infinite ? i = (n = r.currentSlide + (r.options.slidesToShow / 2 + 1)) + r.options.slidesToShow + 2 : (n = Math.max(0, r.currentSlide - (r.options.slidesToShow / 2 + 1)), i = r.options.slidesToShow / 2 + 1 + 2 + r.currentSlide) : (n = r.options.infinite ? r.options.slidesToShow + r.currentSlide : r.currentSlide, i = Math.ceil(n + r.options.slidesToShow), !0 === r.options.fade && (n > 0 && n--, i <= r.slideCount && i++)), t = r.$slider.find(".slick-slide").slice(n, i), "anticipated" === r.options.lazyLoad)
                        for (var a = n - 1, s = i, l = r.$slider.find(".slick-slide"), c = 0; c < r.options.slidesToScroll; c++) a < 0 && (a = r.slideCount - 1), t = (t = t.add(l.eq(a))).add(l.eq(s)), a--, s++;
                    o(t), r.slideCount <= r.options.slidesToShow ? o(r.$slider.find(".slick-slide")) : r.currentSlide >= r.slideCount - r.options.slidesToShow ? o(r.$slider.find(".slick-cloned").slice(0, r.options.slidesToShow)) : 0 === r.currentSlide && o(r.$slider.find(".slick-cloned").slice(-1 * r.options.slidesToShow))
                }, t.prototype.loadSlider = function () {
                    var e = this;
                    e.setPosition(), e.$slideTrack.css({
                        opacity: 1
                    }), e.$slider.removeClass("slick-loading"), e.initUI(), "progressive" === e.options.lazyLoad && e.progressiveLazyLoad()
                }, t.prototype.next = t.prototype.slickNext = function () {
                    this.changeSlide({
                        data: {
                            message: "next"
                        }
                    })
                }, t.prototype.orientationChange = function () {
                    var e = this;
                    e.checkResponsive(), e.setPosition()
                }, t.prototype.pause = t.prototype.slickPause = function () {
                    var e = this;
                    e.autoPlayClear(), e.paused = !0
                }, t.prototype.play = t.prototype.slickPlay = function () {
                    var e = this;
                    e.autoPlay(), e.options.autoplay = !0, e.paused = !1, e.focussed = !1, e.interrupted = !1
                }, t.prototype.postSlide = function (t) {
                    var n = this;
                    n.unslicked || (n.$slider.trigger("afterChange", [n, t]), n.animating = !1, n.slideCount > n.options.slidesToShow && n.setPosition(), n.swipeLeft = null, n.options.autoplay && n.autoPlay(), !0 === n.options.accessibility && (n.initADA(), n.options.focusOnChange && e(n.$slides.get(n.currentSlide)).attr("tabindex", 0).focus()))
                }, t.prototype.prev = t.prototype.slickPrev = function () {
                    this.changeSlide({
                        data: {
                            message: "previous"
                        }
                    })
                }, t.prototype.preventDefault = function (e) {
                    e.preventDefault()
                }, t.prototype.progressiveLazyLoad = function (t) {
                    t = t || 1;
                    var n, i, r, o, a, s = this,
                        l = e("img[data-lazy]", s.$slider);
                    l.length ? (n = l.first(), i = n.attr("data-lazy"), r = n.attr("data-srcset"), o = n.attr("data-sizes") || s.$slider.attr("data-sizes"), (a = document.createElement("img")).onload = function () {
                        r && (n.attr("srcset", r), o && n.attr("sizes", o)), n.attr("src", i).removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading"), !0 === s.options.adaptiveHeight && s.setPosition(), s.$slider.trigger("lazyLoaded", [s, n, i]), s.progressiveLazyLoad()
                    }, a.onerror = function () {
                        t < 3 ? setTimeout((function () {
                            s.progressiveLazyLoad(t + 1)
                        }), 500) : (n.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), s.$slider.trigger("lazyLoadError", [s, n, i]), s.progressiveLazyLoad())
                    }, a.src = i) : s.$slider.trigger("allImagesLoaded", [s])
                }, t.prototype.refresh = function (t) {
                    var n, i, r = this;
                    i = r.slideCount - r.options.slidesToShow, !r.options.infinite && r.currentSlide > i && (r.currentSlide = i), r.slideCount <= r.options.slidesToShow && (r.currentSlide = 0), n = r.currentSlide, r.destroy(!0), e.extend(r, r.initials, {
                        currentSlide: n
                    }), r.init(), t || r.changeSlide({
                        data: {
                            message: "index",
                            index: n
                        }
                    }, !1)
                }, t.prototype.registerBreakpoints = function () {
                    var t, n, i, r = this,
                        o = r.options.responsive || null;
                    if ("array" === e.type(o) && o.length) {
                        for (t in r.respondTo = r.options.respondTo || "window", o)
                            if (i = r.breakpoints.length - 1, o.hasOwnProperty(t)) {
                                for (n = o[t].breakpoint; i >= 0;) r.breakpoints[i] && r.breakpoints[i] === n && r.breakpoints.splice(i, 1), i--;
                                r.breakpoints.push(n), r.breakpointSettings[n] = o[t].settings
                            }
                        r.breakpoints.sort((function (e, t) {
                            return r.options.mobileFirst ? e - t : t - e
                        }))
                    }
                }, t.prototype.reinit = function () {
                    var t = this;
                    t.$slides = t.$slideTrack.children(t.options.slide).addClass("slick-slide"), t.slideCount = t.$slides.length, t.currentSlide >= t.slideCount && 0 !== t.currentSlide && (t.currentSlide = t.currentSlide - t.options.slidesToScroll), t.slideCount <= t.options.slidesToShow && (t.currentSlide = 0), t.registerBreakpoints(), t.setProps(), t.setupInfinite(), t.buildArrows(), t.updateArrows(), t.initArrowEvents(), t.buildDots(), t.updateDots(), t.initDotEvents(), t.cleanUpSlideEvents(), t.initSlideEvents(), t.checkResponsive(!1, !0), !0 === t.options.focusOnSelect && e(t.$slideTrack).children().on("click.slick", t.selectHandler), t.setSlideClasses("number" == typeof t.currentSlide ? t.currentSlide : 0), t.setPosition(), t.focusHandler(), t.paused = !t.options.autoplay, t.autoPlay(), t.$slider.trigger("reInit", [t])
                }, t.prototype.resize = function () {
                    var t = this;
                    e(window).width() !== t.windowWidth && (clearTimeout(t.windowDelay), t.windowDelay = window.setTimeout((function () {
                        t.windowWidth = e(window).width(), t.checkResponsive(), t.unslicked || t.setPosition()
                    }), 50))
                }, t.prototype.removeSlide = t.prototype.slickRemove = function (e, t, n) {
                    var i = this;
                    if (e = "boolean" == typeof e ? !0 === (t = e) ? 0 : i.slideCount - 1 : !0 === t ? --e : e, i.slideCount < 1 || e < 0 || e > i.slideCount - 1) return !1;
                    i.unload(), !0 === n ? i.$slideTrack.children().remove() : i.$slideTrack.children(this.options.slide).eq(e).remove(), i.$slides = i.$slideTrack.children(this.options.slide), i.$slideTrack.children(this.options.slide).detach(), i.$slideTrack.append(i.$slides), i.$slidesCache = i.$slides, i.reinit()
                }, t.prototype.setCSS = function (e) {
                    var t, n, i = this,
                        r = {};
                    !0 === i.options.rtl && (e = -e), t = "left" == i.positionProp ? Math.ceil(e) + "px" : "0px", n = "top" == i.positionProp ? Math.ceil(e) + "px" : "0px", r[i.positionProp] = e, !1 === i.transformsEnabled ? i.$slideTrack.css(r) : (r = {}, !1 === i.cssTransitions ? (r[i.animType] = "translate(" + t + ", " + n + ")", i.$slideTrack.css(r)) : (r[i.animType] = "translate3d(" + t + ", " + n + ", 0px)", i.$slideTrack.css(r)))
                }, t.prototype.setDimensions = function () {
                    var e = this;
                    !1 === e.options.vertical ? !0 === e.options.centerMode && e.$list.css({
                        padding: "0px " + e.options.centerPadding
                    }) : (e.$list.height(e.$slides.first().outerHeight(!0) * e.options.slidesToShow), !0 === e.options.centerMode && e.$list.css({
                        padding: e.options.centerPadding + " 0px"
                    })), e.listWidth = e.$list.width(), e.listHeight = e.$list.height(), !1 === e.options.vertical && !1 === e.options.variableWidth ? (e.slideWidth = Math.ceil(e.listWidth / e.options.slidesToShow), e.$slideTrack.width(Math.ceil(e.slideWidth * e.$slideTrack.children(".slick-slide").length))) : !0 === e.options.variableWidth ? e.$slideTrack.width(5e3 * e.slideCount) : (e.slideWidth = Math.ceil(e.listWidth), e.$slideTrack.height(Math.ceil(e.$slides.first().outerHeight(!0) * e.$slideTrack.children(".slick-slide").length)));
                    var t = e.$slides.first().outerWidth(!0) - e.$slides.first().width();
                    !1 === e.options.variableWidth && e.$slideTrack.children(".slick-slide").width(e.slideWidth - t)
                }, t.prototype.setFade = function () {
                    var t, n = this;
                    n.$slides.each((function (i, r) {
                        t = n.slideWidth * i * -1, !0 === n.options.rtl ? e(r).css({
                            position: "relative",
                            right: t,
                            top: 0,
                            zIndex: n.options.zIndex - 2,
                            opacity: 0
                        }) : e(r).css({
                            position: "relative",
                            left: t,
                            top: 0,
                            zIndex: n.options.zIndex - 2,
                            opacity: 0
                        })
                    })), n.$slides.eq(n.currentSlide).css({
                        zIndex: n.options.zIndex - 1,
                        opacity: 1
                    })
                }, t.prototype.setHeight = function () {
                    var e = this;
                    if (1 === e.options.slidesToShow && !0 === e.options.adaptiveHeight && !1 === e.options.vertical) {
                        var t = e.$slides.eq(e.currentSlide).outerHeight(!0);
                        e.$list.css("height", t)
                    }
                }, t.prototype.setOption = t.prototype.slickSetOption = function () {
                    var t, n, i, r, o, a = this,
                        s = !1;
                    if ("object" === e.type(arguments[0]) ? (i = arguments[0], s = arguments[1], o = "multiple") : "string" === e.type(arguments[0]) && (i = arguments[0], r = arguments[1], s = arguments[2], "responsive" === arguments[0] && "array" === e.type(arguments[1]) ? o = "responsive" : void 0 !== arguments[1] && (o = "single")), "single" === o) a.options[i] = r;
                    else if ("multiple" === o) e.each(i, (function (e, t) {
                        a.options[e] = t
                    }));
                    else if ("responsive" === o)
                        for (n in r)
                            if ("array" !== e.type(a.options.responsive)) a.options.responsive = [r[n]];
                            else {
                                for (t = a.options.responsive.length - 1; t >= 0;) a.options.responsive[t].breakpoint === r[n].breakpoint && a.options.responsive.splice(t, 1), t--;
                                a.options.responsive.push(r[n])
                            }
                    s && (a.unload(), a.reinit())
                }, t.prototype.setPosition = function () {
                    var e = this;
                    e.setDimensions(), e.setHeight(), !1 === e.options.fade ? e.setCSS(e.getLeft(e.currentSlide)) : e.setFade(), e.$slider.trigger("setPosition", [e])
                }, t.prototype.setProps = function () {
                    var e = this,
                        t = document.body.style;
                    e.positionProp = !0 === e.options.vertical ? "top" : "left", "top" === e.positionProp ? e.$slider.addClass("slick-vertical") : e.$slider.removeClass("slick-vertical"), void 0 === t.WebkitTransition && void 0 === t.MozTransition && void 0 === t.msTransition || !0 === e.options.useCSS && (e.cssTransitions = !0), e.options.fade && ("number" == typeof e.options.zIndex ? e.options.zIndex < 3 && (e.options.zIndex = 3) : e.options.zIndex = e.defaults.zIndex), void 0 !== t.OTransform && (e.animType = "OTransform", e.transformType = "-o-transform", e.transitionType = "OTransition", void 0 === t.perspectiveProperty && void 0 === t.webkitPerspective && (e.animType = !1)), void 0 !== t.MozTransform && (e.animType = "MozTransform", e.transformType = "-moz-transform", e.transitionType = "MozTransition", void 0 === t.perspectiveProperty && void 0 === t.MozPerspective && (e.animType = !1)), void 0 !== t.webkitTransform && (e.animType = "webkitTransform", e.transformType = "-webkit-transform", e.transitionType = "webkitTransition", void 0 === t.perspectiveProperty && void 0 === t.webkitPerspective && (e.animType = !1)), void 0 !== t.msTransform && (e.animType = "msTransform", e.transformType = "-ms-transform", e.transitionType = "msTransition", void 0 === t.msTransform && (e.animType = !1)), void 0 !== t.transform && !1 !== e.animType && (e.animType = "transform", e.transformType = "transform", e.transitionType = "transition"), e.transformsEnabled = e.options.useTransform && null !== e.animType && !1 !== e.animType
                }, t.prototype.setSlideClasses = function (e) {
                    var t, n, i, r, o = this;
                    if (n = o.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true"), o.$slides.eq(e).addClass("slick-current"), !0 === o.options.centerMode) {
                        var a = o.options.slidesToShow % 2 == 0 ? 1 : 0;
                        t = Math.floor(o.options.slidesToShow / 2), !0 === o.options.infinite && (e >= t && e <= o.slideCount - 1 - t ? o.$slides.slice(e - t + a, e + t + 1).addClass("slick-active").attr("aria-hidden", "false") : (i = o.options.slidesToShow + e, n.slice(i - t + 1 + a, i + t + 2).addClass("slick-active").attr("aria-hidden", "false")), 0 === e ? n.eq(n.length - 1 - o.options.slidesToShow).addClass("slick-center") : e === o.slideCount - 1 && n.eq(o.options.slidesToShow).addClass("slick-center")), o.$slides.eq(e).addClass("slick-center")
                    } else e >= 0 && e <= o.slideCount - o.options.slidesToShow ? o.$slides.slice(e, e + o.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false") : n.length <= o.options.slidesToShow ? n.addClass("slick-active").attr("aria-hidden", "false") : (r = o.slideCount % o.options.slidesToShow, i = !0 === o.options.infinite ? o.options.slidesToShow + e : e, o.options.slidesToShow == o.options.slidesToScroll && o.slideCount - e < o.options.slidesToShow ? n.slice(i - (o.options.slidesToShow - r), i + r).addClass("slick-active").attr("aria-hidden", "false") : n.slice(i, i + o.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false"));
                    "ondemand" !== o.options.lazyLoad && "anticipated" !== o.options.lazyLoad || o.lazyLoad()
                }, t.prototype.setupInfinite = function () {
                    var t, n, i, r = this;
                    if (!0 === r.options.fade && (r.options.centerMode = !1), !0 === r.options.infinite && !1 === r.options.fade && (n = null, r.slideCount > r.options.slidesToShow)) {
                        for (i = !0 === r.options.centerMode ? r.options.slidesToShow + 1 : r.options.slidesToShow, t = r.slideCount; t > r.slideCount - i; t -= 1) n = t - 1, e(r.$slides[n]).clone(!0).attr("id", "").attr("data-slick-index", n - r.slideCount).prependTo(r.$slideTrack).addClass("slick-cloned");
                        for (t = 0; t < i + r.slideCount; t += 1) n = t, e(r.$slides[n]).clone(!0).attr("id", "").attr("data-slick-index", n + r.slideCount).appendTo(r.$slideTrack).addClass("slick-cloned");
                        r.$slideTrack.find(".slick-cloned").find("[id]").each((function () {
                            e(this).attr("id", "")
                        }))
                    }
                }, t.prototype.interrupt = function (e) {
                    var t = this;
                    e || t.autoPlay(), t.interrupted = e
                }, t.prototype.selectHandler = function (t) {
                    var n = this,
                        i = e(t.target).is(".slick-slide") ? e(t.target) : e(t.target).parents(".slick-slide"),
                        r = parseInt(i.attr("data-slick-index"));
                    r || (r = 0), n.slideCount <= n.options.slidesToShow ? n.slideHandler(r, !1, !0) : n.slideHandler(r)
                }, t.prototype.slideHandler = function (e, t, n) {
                    var i, r, o, a, s, l = null,
                        c = this;
                    if (t = t || !1, !(!0 === c.animating && !0 === c.options.waitForAnimate || !0 === c.options.fade && c.currentSlide === e))
                        if (!1 === t && c.asNavFor(e), i = e, l = c.getLeft(i), a = c.getLeft(c.currentSlide), c.currentLeft = null === c.swipeLeft ? a : c.swipeLeft, !1 === c.options.infinite && !1 === c.options.centerMode && (e < 0 || e > c.getDotCount() * c.options.slidesToScroll)) !1 === c.options.fade && (i = c.currentSlide, !0 !== n && c.slideCount > c.options.slidesToShow ? c.animateSlide(a, (function () {
                            c.postSlide(i)
                        })) : c.postSlide(i));
                        else if (!1 === c.options.infinite && !0 === c.options.centerMode && (e < 0 || e > c.slideCount - c.options.slidesToScroll)) !1 === c.options.fade && (i = c.currentSlide, !0 !== n && c.slideCount > c.options.slidesToShow ? c.animateSlide(a, (function () {
                            c.postSlide(i)
                        })) : c.postSlide(i));
                        else {
                            if (c.options.autoplay && clearInterval(c.autoPlayTimer), r = i < 0 ? c.slideCount % c.options.slidesToScroll != 0 ? c.slideCount - c.slideCount % c.options.slidesToScroll : c.slideCount + i : i >= c.slideCount ? c.slideCount % c.options.slidesToScroll != 0 ? 0 : i - c.slideCount : i, c.animating = !0, c.$slider.trigger("beforeChange", [c, c.currentSlide, r]), o = c.currentSlide, c.currentSlide = r, c.setSlideClasses(c.currentSlide), c.options.asNavFor && (s = (s = c.getNavTarget()).slick("getSlick")).slideCount <= s.options.slidesToShow && s.setSlideClasses(c.currentSlide), c.updateDots(), c.updateArrows(), !0 === c.options.fade) return !0 !== n ? (c.fadeSlideOut(o), c.fadeSlide(r, (function () {
                                c.postSlide(r)
                            }))) : c.postSlide(r), void c.animateHeight();
                            !0 !== n && c.slideCount > c.options.slidesToShow ? c.animateSlide(l, (function () {
                                c.postSlide(r)
                            })) : c.postSlide(r)
                        }
                }, t.prototype.startLoad = function () {
                    var e = this;
                    !0 === e.options.arrows && e.slideCount > e.options.slidesToShow && (e.$prevArrow.hide(), e.$nextArrow.hide()), !0 === e.options.dots && e.slideCount > e.options.slidesToShow && e.$dots.hide(), e.$slider.addClass("slick-loading")
                }, t.prototype.swipeDirection = function () {
                    var e, t, n, i, r = this;
                    return e = r.touchObject.startX - r.touchObject.curX, t = r.touchObject.startY - r.touchObject.curY, n = Math.atan2(t, e), (i = Math.round(180 * n / Math.PI)) < 0 && (i = 360 - Math.abs(i)), i <= 45 && i >= 0 || i <= 360 && i >= 315 ? !1 === r.options.rtl ? "left" : "right" : i >= 135 && i <= 225 ? !1 === r.options.rtl ? "right" : "left" : !0 === r.options.verticalSwiping ? i >= 35 && i <= 135 ? "down" : "up" : "vertical"
                }, t.prototype.swipeEnd = function (e) {
                    var t, n, i = this;
                    if (i.dragging = !1, i.swiping = !1, i.scrolling) return i.scrolling = !1, !1;
                    if (i.interrupted = !1, i.shouldClick = !(i.touchObject.swipeLength > 10), void 0 === i.touchObject.curX) return !1;
                    if (!0 === i.touchObject.edgeHit && i.$slider.trigger("edge", [i, i.swipeDirection()]), i.touchObject.swipeLength >= i.touchObject.minSwipe) {
                        switch (n = i.swipeDirection()) {
                            case "left":
                            case "down":
                                t = i.options.swipeToSlide ? i.checkNavigable(i.currentSlide + i.getSlideCount()) : i.currentSlide + i.getSlideCount(), i.currentDirection = 0;
                                break;
                            case "right":
                            case "up":
                                t = i.options.swipeToSlide ? i.checkNavigable(i.currentSlide - i.getSlideCount()) : i.currentSlide - i.getSlideCount(), i.currentDirection = 1
                        }
                        "vertical" != n && (i.slideHandler(t), i.touchObject = {}, i.$slider.trigger("swipe", [i, n]))
                    } else i.touchObject.startX !== i.touchObject.curX && (i.slideHandler(i.currentSlide), i.touchObject = {})
                }, t.prototype.swipeHandler = function (e) {
                    var t = this;
                    if (!(!1 === t.options.swipe || "ontouchend" in document && !1 === t.options.swipe || !1 === t.options.draggable && -1 !== e.type.indexOf("mouse"))) switch (t.touchObject.fingerCount = e.originalEvent && void 0 !== e.originalEvent.touches ? e.originalEvent.touches.length : 1, t.touchObject.minSwipe = t.listWidth / t.options.touchThreshold, !0 === t.options.verticalSwiping && (t.touchObject.minSwipe = t.listHeight / t.options.touchThreshold), e.data.action) {
                        case "start":
                            t.swipeStart(e);
                            break;
                        case "move":
                            t.swipeMove(e);
                            break;
                        case "end":
                            t.swipeEnd(e)
                    }
                }, t.prototype.swipeMove = function (e) {
                    var t, n, i, r, o, a, s = this;
                    return o = void 0 !== e.originalEvent ? e.originalEvent.touches : null, !(!s.dragging || s.scrolling || o && 1 !== o.length) && (t = s.getLeft(s.currentSlide), s.touchObject.curX = void 0 !== o ? o[0].pageX : e.clientX, s.touchObject.curY = void 0 !== o ? o[0].pageY : e.clientY, s.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(s.touchObject.curX - s.touchObject.startX, 2))), a = Math.round(Math.sqrt(Math.pow(s.touchObject.curY - s.touchObject.startY, 2))), !s.options.verticalSwiping && !s.swiping && a > 4 ? (s.scrolling = !0, !1) : (!0 === s.options.verticalSwiping && (s.touchObject.swipeLength = a), n = s.swipeDirection(), void 0 !== e.originalEvent && s.touchObject.swipeLength > 4 && (s.swiping = !0, e.preventDefault()), r = (!1 === s.options.rtl ? 1 : -1) * (s.touchObject.curX > s.touchObject.startX ? 1 : -1), !0 === s.options.verticalSwiping && (r = s.touchObject.curY > s.touchObject.startY ? 1 : -1), i = s.touchObject.swipeLength, s.touchObject.edgeHit = !1, !1 === s.options.infinite && (0 === s.currentSlide && "right" === n || s.currentSlide >= s.getDotCount() && "left" === n) && (i = s.touchObject.swipeLength * s.options.edgeFriction, s.touchObject.edgeHit = !0), !1 === s.options.vertical ? s.swipeLeft = t + i * r : s.swipeLeft = t + i * (s.$list.height() / s.listWidth) * r, !0 === s.options.verticalSwiping && (s.swipeLeft = t + i * r), !0 !== s.options.fade && !1 !== s.options.touchMove && (!0 === s.animating ? (s.swipeLeft = null, !1) : void s.setCSS(s.swipeLeft))))
                }, t.prototype.swipeStart = function (e) {
                    var t, n = this;
                    if (n.interrupted = !0, 1 !== n.touchObject.fingerCount || n.slideCount <= n.options.slidesToShow) return n.touchObject = {}, !1;
                    void 0 !== e.originalEvent && void 0 !== e.originalEvent.touches && (t = e.originalEvent.touches[0]), n.touchObject.startX = n.touchObject.curX = void 0 !== t ? t.pageX : e.clientX, n.touchObject.startY = n.touchObject.curY = void 0 !== t ? t.pageY : e.clientY, n.dragging = !0
                }, t.prototype.unfilterSlides = t.prototype.slickUnfilter = function () {
                    var e = this;
                    null !== e.$slidesCache && (e.unload(), e.$slideTrack.children(this.options.slide).detach(), e.$slidesCache.appendTo(e.$slideTrack), e.reinit())
                }, t.prototype.unload = function () {
                    var t = this;
                    e(".slick-cloned", t.$slider).remove(), t.$dots && t.$dots.remove(), t.$prevArrow && t.htmlExpr.test(t.options.prevArrow) && t.$prevArrow.remove(), t.$nextArrow && t.htmlExpr.test(t.options.nextArrow) && t.$nextArrow.remove(), t.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "")
                }, t.prototype.unslick = function (e) {
                    var t = this;
                    t.$slider.trigger("unslick", [t, e]), t.destroy()
                }, t.prototype.updateArrows = function () {
                    var e = this;
                    Math.floor(e.options.slidesToShow / 2), !0 === e.options.arrows && e.slideCount > e.options.slidesToShow && !e.options.infinite && (e.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), e.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), 0 === e.currentSlide ? (e.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true"), e.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : (e.currentSlide >= e.slideCount - e.options.slidesToShow && !1 === e.options.centerMode || e.currentSlide >= e.slideCount - 1 && !0 === e.options.centerMode) && (e.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), e.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")))
                }, t.prototype.updateDots = function () {
                    var e = this;
                    null !== e.$dots && (e.$dots.find("li").removeClass("slick-active").end(), e.$dots.find("li").eq(Math.floor(e.currentSlide / e.options.slidesToScroll)).addClass("slick-active"))
                }, t.prototype.visibility = function () {
                    var e = this;
                    e.options.autoplay && (document[e.hidden] ? e.interrupted = !0 : e.interrupted = !1)
                }, e.fn.slick = function () {
                    var e, n, i = this,
                        r = arguments[0],
                        o = Array.prototype.slice.call(arguments, 1),
                        a = i.length;
                    for (e = 0; e < a; e++)
                        if ("object" == typeof r || void 0 === r ? i[e].slick = new t(i[e], r) : n = i[e].slick[r].apply(i[e].slick, o), void 0 !== n) return n;
                    return i
                }
            }) ? i.apply(t, r) : i) || (e.exports = o)
        }()
    }, function (e, t) {
        e.exports = {
            ScrollMagicPluginGsap: function (e, t, n) {
                var i = t,
                    r = "animation.gsap",
                    o = window.console || {},
                    a = Function.prototype.bind.call(o.error || o.log || function () { }, o);
                e || a("(" + r + ") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs."), i || a("(" + r + ") -> ERROR: TweenLite or TweenMax could not be found. Please make sure GSAP is loaded before ScrollMagic or use an asynchronous loader like requirejs."), e.Scene.addOption("tweenChanges", !1, (function (e) {
                    return !!e
                })), e.Scene.extend((function () {
                    var e, t = this,
                        o = function () {
                            t._log && (Array.prototype.splice.call(arguments, 1, 0, "(" + r + ")", "->"), t._log.apply(this, arguments))
                        };
                    t.on("progress.plugin_gsap", (function () {
                        a()
                    })), t.on("destroy.plugin_gsap", (function (e) {
                        t.removeTween(e.reset)
                    }));
                    var a = function () {
                        if (e) {
                            var n = t.progress(),
                                i = t.state();
                            e.repeat && -1 === e.repeat() ? "DURING" === i && e.paused() ? e.play() : "DURING" === i || e.paused() || e.pause() : n != e.progress() && (0 === t.duration() ? n > 0 ? e.play() : e.reverse() : t.tweenChanges() && e.tweenTo ? e.tweenTo(n * e.duration()) : e.progress(n).pause())
                        }
                    };
                    t.setTween = function (r, s, l) {
                        var c;
                        arguments.length > 1 && (arguments.length < 3 && (l = s, s = 1), r = i.to(r, s, l));
                        try {
                            (c = n ? new n({
                                smoothChildTiming: !0
                            }).add(r) : r).pause()
                        } catch (e) {
                            return o(1, "ERROR calling method 'setTween()': Supplied argument is not a valid TweenObject"), t
                        }
                        if (e && t.removeTween(), e = c, r.repeat && -1 === r.repeat() && (e.repeat(-1), e.yoyo(r.yoyo())), t.tweenChanges() && !e.tweenTo && o(2, "WARNING: tweenChanges will only work if the TimelineMax object is available for ScrollMagic."), e && t.controller() && t.triggerElement() && t.loglevel() >= 2) {
                            var u = i.getTweensOf(t.triggerElement()),
                                h = t.controller().info("vertical");
                            u.forEach((function (e, t) {
                                var n = e.vars.css || e.vars;
                                if (h ? void 0 !== n.top || void 0 !== n.bottom : void 0 !== n.left || void 0 !== n.right) return o(2, "WARNING: Tweening the position of the trigger element affects the scene timing and should be avoided!"), !1
                            }))
                        }
                        if (parseFloat(i.version) >= 1.14)
                            for (var d, p, f = e.getChildren ? e.getChildren(!0, !0, !1) : [e], m = function () {
                                o(2, "WARNING: tween was overwritten by another. To learn how to avoid this issue see here: https://github.com/janpaepke/ScrollMagic/wiki/WARNING:-tween-was-overwritten-by-another")
                            }, g = 0; g < f.length; g++) d = f[g], p !== m && (p = d.vars.onOverwrite, d.vars.onOverwrite = function () {
                                p && p.apply(this, arguments), m.apply(this, arguments)
                            });
                        return o(3, "added tween"), a(), t
                    }, t.removeTween = function (n) {
                        return e && (n && e.progress(0).pause(), e.kill(), e = void 0, o(3, "removed tween (reset: " + (n ? "true" : "false") + ")")), t
                    }
                }))
            }
        }
    }, function (e, t, n) { }, function (e, t, n) {
        "use strict";
        n.r(t);
        var i = n(0),
            r = n.n(i);
        var o = r()(".loader");

        function a(e) {
            var t = Math.round(e / 20);
            t < 1 ? o.find(".background").addClass("b-blue") : t >= 1 && t < 2 ? o.find(".background").addClass("b-green") : t >= 2 && t < 3 ? o.find(".background").addClass("b-purple") : t >= 3 && t < 4 ? o.find(".background").addClass("b-orange") : t > 4 && o.find(".background").addClass("b-yellow")
        }

        function s(e) {
            "1" == e ? o.addClass("motion-out-1") : o.addClass("motion-out-2")
        }
        var l = r()(".menu"),
            c = r()(".header"),
            u = r()(".main-content"),
            h = r()("main"),
            d = h.data("page");

        function p() {
            s("1"), setTimeout((function () {
                s("2"), setTimeout((function () {
                    var e;
                    o.css({
                        display: "none"
                    }), o.removeClass("motion-out-1").removeClass("motion-out-2").removeClass("motion-in"), o.find(".background").removeClass("b-blue").removeClass("b-green").removeClass("b-purple").removeClass("b-orange").removeClass("b-yellow"), l.trigger("enter").addClass("motion-in"), c.addClass("motion-in"), u.find("> *").trigger("enter").addClass("motion-in").attr("data-url", location.href), e = d, l.find(".item").removeClass("active"), l.find(".item").filter('[data-target="' + e + '"]').addClass("active"), console.log("data-page " + e)
                }), 1e3)
            }), 1e3)
        }
        var f = n(1);

        function m(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }

        function g(e, t) {
            e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t
        }
        var v, y, x, w, b, _, M, T, S, E, A, C, L, P, R, O, D, k, N, I, z, F, H, B, U, j, G, V, W = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        },
            q = {
                duration: .5,
                overwrite: !1,
                delay: 0
            },
            $ = 1e8,
            X = 1e-8,
            Y = 2 * Math.PI,
            Z = Y / 4,
            J = 0,
            Q = Math.sqrt,
            K = Math.cos,
            ee = Math.sin,
            te = function (e) {
                return "string" == typeof e
            },
            ne = function (e) {
                return "function" == typeof e
            },
            ie = function (e) {
                return "number" == typeof e
            },
            re = function (e) {
                return void 0 === e
            },
            oe = function (e) {
                return "object" == typeof e
            },
            ae = function (e) {
                return !1 !== e
            },
            se = function () {
                return "undefined" != typeof window
            },
            le = function (e) {
                return ne(e) || te(e)
            },
            ce = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () { },
            ue = Array.isArray,
            he = /(?:-?\.?\d|\.)+/gi,
            de = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
            pe = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
            fe = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
            me = /[+-]=-?[.\d]+/,
            ge = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
            ve = /[\d.+\-=]+(?:e[-+]\d*)*/i,
            ye = {},
            xe = {},
            we = function (e) {
                return (xe = qe(e, ye)) && On
            },
            be = function (e, t) {
                return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
            },
            _e = function (e, t) {
                return !t && console.warn(e)
            },
            Me = function (e, t) {
                return e && (ye[e] = t) && xe && (xe[e] = t) || ye
            },
            Te = function () {
                return 0
            },
            Se = {},
            Ee = [],
            Ae = {},
            Ce = {},
            Le = {},
            Pe = 30,
            Re = [],
            Oe = "",
            De = function (e) {
                var t, n, i = e[0];
                if (oe(i) || ne(i) || (e = [e]), !(t = (i._gsap || {}).harness)) {
                    for (n = Re.length; n-- && !Re[n].targetTest(i););
                    t = Re[n]
                }
                for (n = e.length; n--;) e[n] && (e[n]._gsap || (e[n]._gsap = new nn(e[n], t))) || e.splice(n, 1);
                return e
            },
            ke = function (e) {
                return e._gsap || De(bt(e))[0]._gsap
            },
            Ne = function (e, t, n) {
                return (n = e[t]) && ne(n) ? e[t]() : re(n) && e.getAttribute && e.getAttribute(t) || n
            },
            Ie = function (e, t) {
                return (e = e.split(",")).forEach(t) || e
            },
            ze = function (e) {
                return Math.round(1e5 * e) / 1e5 || 0
            },
            Fe = function (e, t) {
                for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n;);
                return i < n
            },
            He = function (e, t, n) {
                var i, r = ie(e[1]),
                    o = (r ? 2 : 1) + (t < 2 ? 0 : 1),
                    a = e[o];
                if (r && (a.duration = e[1]), a.parent = n, t) {
                    for (i = a; n && !("immediateRender" in i);) i = n.vars.defaults || {}, n = ae(n.vars.inherit) && n.parent;
                    a.immediateRender = ae(i.immediateRender), t < 2 ? a.runBackwards = 1 : a.startAt = e[o - 1]
                }
                return a
            },
            Be = function () {
                var e, t, n = Ee.length,
                    i = Ee.slice(0);
                for (Ae = {}, Ee.length = 0, e = 0; e < n; e++)(t = i[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
            },
            Ue = function (e, t, n, i) {
                Ee.length && Be(), e.render(t, n, i), Ee.length && Be()
            },
            je = function (e) {
                var t = parseFloat(e);
                return (t || 0 === t) && (e + "").match(ge).length < 2 ? t : te(e) ? e.trim() : e
            },
            Ge = function (e) {
                return e
            },
            Ve = function (e, t) {
                for (var n in t) n in e || (e[n] = t[n]);
                return e
            },
            We = function (e, t) {
                for (var n in t) n in e || "duration" === n || "ease" === n || (e[n] = t[n])
            },
            qe = function (e, t) {
                for (var n in t) e[n] = t[n];
                return e
            },
            $e = function e(t, n) {
                for (var i in n) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (t[i] = oe(n[i]) ? e(t[i] || (t[i] = {}), n[i]) : n[i]);
                return t
            },
            Xe = function (e, t) {
                var n, i = {};
                for (n in e) n in t || (i[n] = e[n]);
                return i
            },
            Ye = function (e) {
                var t = e.parent || y,
                    n = e.keyframes ? We : Ve;
                if (ae(e.inherit))
                    for (; t;) n(e, t.vars.defaults), t = t.parent || t._dp;
                return e
            },
            Ze = function (e, t, n, i) {
                void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                var r = t._prev,
                    o = t._next;
                r ? r._next = o : e[n] === t && (e[n] = o), o ? o._prev = r : e[i] === t && (e[i] = r), t._next = t._prev = t.parent = null
            },
            Je = function (e, t) {
                e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove(e), e._act = 0
            },
            Qe = function (e, t) {
                if (e && (!t || t._end > e._dur || t._start < 0))
                    for (var n = e; n;) n._dirty = 1, n = n.parent;
                return e
            },
            Ke = function (e) {
                for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
                return e
            },
            et = function e(t) {
                return !t || t._ts && e(t.parent)
            },
            tt = function (e) {
                return e._repeat ? nt(e._tTime, e = e.duration() + e._rDelay) * e : 0
            },
            nt = function (e, t) {
                var n = Math.floor(e /= t);
                return e && n === e ? n - 1 : n
            },
            it = function (e, t) {
                return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
            },
            rt = function (e) {
                return e._end = ze(e._start + (e._tDur / Math.abs(e._ts || e._rts || X) || 0))
            },
            ot = function (e, t) {
                var n = e._dp;
                return n && n.smoothChildTiming && e._ts && (e._start = ze(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), rt(e), n._dirty || Qe(n, e)), e
            },
            at = function (e, t) {
                var n;
                if ((t._time || t._initted && !t._dur) && (n = it(e.rawTime(), t), (!t._dur || gt(0, t.totalDuration(), n) - t._tTime > X) && t.render(n, !0)), Qe(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
                    if (e._dur < e.duration())
                        for (n = e; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                    e._zTime = -1e-8
                }
            },
            st = function (e, t, n, i) {
                return t.parent && Je(t), t._start = ze(n + t._delay), t._end = ze(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)),
                    function (e, t, n, i, r) {
                        void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                        var o, a = e[i];
                        if (r)
                            for (o = t[r]; a && a[r] > o;) a = a._prev;
                        a ? (t._next = a._next, a._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = a, t.parent = t._dp = e
                    }(e, t, "_first", "_last", e._sort ? "_start" : 0), e._recent = t, i || at(e, t), e
            },
            lt = function (e, t) {
                return (ye.ScrollTrigger || be("scrollTrigger", t)) && ye.ScrollTrigger.create(t, e)
            },
            ct = function (e, t, n, i) {
                return un(e, t), e._initted ? !n && e._pt && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && M !== Gt.frame ? (Ee.push(e), e._lazy = [t, i], 1) : void 0 : 1
            },
            ut = function e(t) {
                var n = t.parent;
                return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e(n))
            },
            ht = function (e, t, n, i) {
                var r = e._repeat,
                    o = ze(t) || 0,
                    a = e._tTime / e._tDur;
                return a && !i && (e._time *= o / e._dur), e._dur = o, e._tDur = r ? r < 0 ? 1e10 : ze(o * (r + 1) + e._rDelay * r) : o, a && !i ? ot(e, e._tTime = e._tDur * a) : e.parent && rt(e), n || Qe(e.parent, e), e
            },
            dt = function (e) {
                return e instanceof on ? Qe(e) : ht(e, e._dur)
            },
            pt = {
                _start: 0,
                endTime: Te
            },
            ft = function e(t, n) {
                var i, r, o = t.labels,
                    a = t._recent || pt,
                    s = t.duration() >= $ ? a.endTime(!1) : t._dur;
                return te(n) && (isNaN(n) || n in o) ? "<" === (i = n.charAt(0)) || ">" === i ? ("<" === i ? a._start : a.endTime(a._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) : (i = n.indexOf("=")) < 0 ? (n in o || (o[n] = s), o[n]) : (r = +(n.charAt(i - 1) + n.substr(i + 1)), i > 1 ? e(t, n.substr(0, i - 1)) + r : s + r) : null == n ? s : +n
            },
            mt = function (e, t) {
                return e || 0 === e ? t(e) : t
            },
            gt = function (e, t, n) {
                return n < e ? e : n > t ? t : n
            },
            vt = function (e) {
                if ("string" != typeof e) return "";
                var t = ve.exec(e);
                return t ? e.substr(t.index + t[0].length) : ""
            },
            yt = [].slice,
            xt = function (e, t) {
                return e && oe(e) && "length" in e && (!t && !e.length || e.length - 1 in e && oe(e[0])) && !e.nodeType && e !== x
            },
            wt = function (e, t, n) {
                return void 0 === n && (n = []), e.forEach((function (e) {
                    var i;
                    return te(e) && !t || xt(e, 1) ? (i = n).push.apply(i, bt(e)) : n.push(e)
                })) || n
            },
            bt = function (e, t) {
                return !te(e) || t || !w && Vt() ? ue(e) ? wt(e, t) : xt(e) ? yt.call(e, 0) : e ? [e] : [] : yt.call(b.querySelectorAll(e), 0)
            },
            _t = function (e) {
                return e.sort((function () {
                    return .5 - Math.random()
                }))
            },
            Mt = function (e) {
                if (ne(e)) return e;
                var t = oe(e) ? e : {
                    each: e
                },
                    n = Jt(t.ease),
                    i = t.from || 0,
                    r = parseFloat(t.base) || 0,
                    o = {},
                    a = i > 0 && i < 1,
                    s = isNaN(i) || a,
                    l = t.axis,
                    c = i,
                    u = i;
                return te(i) ? c = u = {
                    center: .5,
                    edges: .5,
                    end: 1
                }[i] || 0 : !a && s && (c = i[0], u = i[1]),
                    function (e, a, h) {
                        var d, p, f, m, g, v, y, x, w, b = (h || t).length,
                            _ = o[b];
                        if (!_) {
                            if (!(w = "auto" === t.grid ? 0 : (t.grid || [1, $])[1])) {
                                for (y = -$; y < (y = h[w++].getBoundingClientRect().left) && w < b;);
                                w--
                            }
                            for (_ = o[b] = [], d = s ? Math.min(w, b) * c - .5 : i % w, p = s ? b * u / w - .5 : i / w | 0, y = 0, x = $, v = 0; v < b; v++) f = v % w - d, m = p - (v / w | 0), _[v] = g = l ? Math.abs("y" === l ? m : f) : Q(f * f + m * m), g > y && (y = g), g < x && (x = g);
                            "random" === i && _t(_), _.max = y - x, _.min = x, _.v = b = (parseFloat(t.amount) || parseFloat(t.each) * (w > b ? b - 1 : l ? "y" === l ? b / w : w : Math.max(w, b / w)) || 0) * ("edges" === i ? -1 : 1), _.b = b < 0 ? r - b : r, _.u = vt(t.amount || t.each) || 0, n = n && b < 0 ? Yt(n) : n
                        }
                        return b = (_[e] - _.min) / _.max || 0, ze(_.b + (n ? n(b) : b) * _.v) + _.u
                    }
            },
            Tt = function (e) {
                var t = e < 1 ? Math.pow(10, (e + "").length - 2) : 1;
                return function (n) {
                    var i = Math.round(parseFloat(n) / e) * e * t;
                    return (i - i % 1) / t + (ie(n) ? 0 : vt(n))
                }
            },
            St = function (e, t) {
                var n, i, r = ue(e);
                return !r && oe(e) && (n = r = e.radius || $, e.values ? (e = bt(e.values), (i = !ie(e[0])) && (n *= n)) : e = Tt(e.increment)), mt(t, r ? ne(e) ? function (t) {
                    return i = e(t), Math.abs(i - t) <= n ? i : t
                } : function (t) {
                    for (var r, o, a = parseFloat(i ? t.x : t), s = parseFloat(i ? t.y : 0), l = $, c = 0, u = e.length; u--;)(r = i ? (r = e[u].x - a) * r + (o = e[u].y - s) * o : Math.abs(e[u] - a)) < l && (l = r, c = u);
                    return c = !n || l <= n ? e[c] : t, i || c === t || ie(t) ? c : c + vt(t)
                } : Tt(e))
            },
            Et = function (e, t, n, i) {
                return mt(ue(e) ? !t : !0 === n ? !!(n = 0) : !i, (function () {
                    return ue(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + .99 * n)) / n) * n * i) / i
                }))
            },
            At = function (e, t, n) {
                return mt(n, (function (n) {
                    return e[~~t(n)]
                }))
            },
            Ct = function (e) {
                for (var t, n, i, r, o = 0, a = ""; ~(t = e.indexOf("random(", o));) i = e.indexOf(")", t), r = "[" === e.charAt(t + 7), n = e.substr(t + 7, i - t - 7).match(r ? ge : he), a += e.substr(o, t - o) + Et(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), o = i + 1;
                return a + e.substr(o, e.length - o)
            },
            Lt = function (e, t, n, i, r) {
                var o = t - e,
                    a = i - n;
                return mt(r, (function (t) {
                    return n + ((t - e) / o * a || 0)
                }))
            },
            Pt = function (e, t, n) {
                var i, r, o, a = e.labels,
                    s = $;
                for (i in a) (r = a[i] - t) < 0 == !!n && r && s > (r = Math.abs(r)) && (o = i, s = r);
                return o
            },
            Rt = function (e, t, n) {
                var i, r, o = e.vars,
                    a = o[t];
                if (a) return i = o[t + "Params"], r = o.callbackScope || e, n && Ee.length && Be(), i ? a.apply(r, i) : a.call(r)
            },
            Ot = function (e) {
                return Je(e), e.scrollTrigger && e.scrollTrigger.kill(!1), e.progress() < 1 && Rt(e, "onInterrupt"), e
            },
            Dt = function (e) {
                var t = (e = !e.name && e.default || e).name,
                    n = ne(e),
                    i = t && !n && e.init ? function () {
                        this._props = []
                    } : e,
                    r = {
                        init: Te,
                        render: Mn,
                        add: ln,
                        kill: Sn,
                        modifier: Tn,
                        rawVars: 0
                    },
                    o = {
                        targetTest: 0,
                        get: 0,
                        getSetter: xn,
                        aliases: {},
                        register: 0
                    };
                if (Vt(), e !== i) {
                    if (Ce[t]) return;
                    Ve(i, Ve(Xe(e, r), o)), qe(i.prototype, qe(r, Xe(e, o))), Ce[i.prop = t] = i, e.targetTest && (Re.push(i), Se[t] = 1), t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                }
                Me(t, i), e.register && e.register(On, i, Cn)
            },
            kt = 255,
            Nt = {
                aqua: [0, kt, kt],
                lime: [0, kt, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, kt],
                navy: [0, 0, 128],
                white: [kt, kt, kt],
                olive: [128, 128, 0],
                yellow: [kt, kt, 0],
                orange: [kt, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [kt, 0, 0],
                pink: [kt, 192, 203],
                cyan: [0, kt, kt],
                transparent: [kt, kt, kt, 0]
            },
            It = function (e, t, n) {
                return (6 * (e = e < 0 ? e + 1 : e > 1 ? e - 1 : e) < 1 ? t + (n - t) * e * 6 : e < .5 ? n : 3 * e < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * kt + .5 | 0
            },
            zt = function (e, t, n) {
                var i, r, o, a, s, l, c, u, h, d, p = e ? ie(e) ? [e >> 16, e >> 8 & kt, e & kt] : 0 : Nt.black;
                if (!p) {
                    if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), Nt[e]) p = Nt[e];
                    else if ("#" === e.charAt(0)) {
                        if (e.length < 6 && (i = e.charAt(1), r = e.charAt(2), o = e.charAt(3), e = "#" + i + i + r + r + o + o + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")), 9 === e.length) return [(p = parseInt(e.substr(1, 6), 16)) >> 16, p >> 8 & kt, p & kt, parseInt(e.substr(7), 16) / 255];
                        p = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & kt, e & kt]
                    } else if ("hsl" === e.substr(0, 3))
                        if (p = d = e.match(he), t) {
                            if (~e.indexOf("=")) return p = e.match(de), n && p.length < 4 && (p[3] = 1), p
                        } else a = +p[0] % 360 / 360, s = +p[1] / 100, i = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (s + 1) : l + s - l * s), p.length > 3 && (p[3] *= 1), p[0] = It(a + 1 / 3, i, r), p[1] = It(a, i, r), p[2] = It(a - 1 / 3, i, r);
                    else p = e.match(he) || Nt.transparent;
                    p = p.map(Number)
                }
                return t && !d && (i = p[0] / kt, r = p[1] / kt, o = p[2] / kt, l = ((c = Math.max(i, r, o)) + (u = Math.min(i, r, o))) / 2, c === u ? a = s = 0 : (h = c - u, s = l > .5 ? h / (2 - c - u) : h / (c + u), a = c === i ? (r - o) / h + (r < o ? 6 : 0) : c === r ? (o - i) / h + 2 : (i - r) / h + 4, a *= 60), p[0] = ~~(a + .5), p[1] = ~~(100 * s + .5), p[2] = ~~(100 * l + .5)), n && p.length < 4 && (p[3] = 1), p
            },
            Ft = function (e) {
                var t = [],
                    n = [],
                    i = -1;
                return e.split(Bt).forEach((function (e) {
                    var r = e.match(pe) || [];
                    t.push.apply(t, r), n.push(i += r.length + 1)
                })), t.c = n, t
            },
            Ht = function (e, t, n) {
                var i, r, o, a, s = "",
                    l = (e + s).match(Bt),
                    c = t ? "hsla(" : "rgba(",
                    u = 0;
                if (!l) return e;
                if (l = l.map((function (e) {
                    return (e = zt(e, t, 1)) && c + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")"
                })), n && (o = Ft(e), (i = n.c).join(s) !== o.c.join(s)))
                    for (a = (r = e.replace(Bt, "1").split(pe)).length - 1; u < a; u++) s += r[u] + (~i.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (o.length ? o : l.length ? l : n).shift());
                if (!r)
                    for (a = (r = e.split(Bt)).length - 1; u < a; u++) s += r[u] + l[u];
                return s + r[a]
            },
            Bt = function () {
                var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                for (e in Nt) t += "|" + e + "\\b";
                return new RegExp(t + ")", "gi")
            }(),
            Ut = /hsl[a]?\(/,
            jt = function (e) {
                var t, n = e.join(" ");
                if (Bt.lastIndex = 0, Bt.test(n)) return t = Ut.test(n), e[1] = Ht(e[1], t), e[0] = Ht(e[0], t, Ft(e[1])), !0
            },
            Gt = (O = Date.now, D = 500, k = 33, N = O(), I = N, F = z = 1e3 / 240, B = function e(t) {
                var n, i, r, o, a = O() - I,
                    s = !0 === t;
                if (a > D && (N += a - k), ((n = (r = (I += a) - N) - F) > 0 || s) && (o = ++L.frame, P = r - 1e3 * L.time, L.time = r /= 1e3, F += n + (n >= z ? 4 : z - n), i = 1), s || (E = A(e)), i)
                    for (R = 0; R < H.length; R++) H[R](r, P, o, t)
            }, L = {
                time: 0,
                frame: 0,
                tick: function () {
                    B(!0)
                },
                deltaRatio: function (e) {
                    return P / (1e3 / (e || 60))
                },
                wake: function () {
                    _ && (!w && se() && (x = w = window, b = x.document || {}, ye.gsap = On, (x.gsapVersions || (x.gsapVersions = [])).push(On.version), we(xe || x.GreenSockGlobals || !x.gsap && x || {}), C = x.requestAnimationFrame), E && L.sleep(), A = C || function (e) {
                        return setTimeout(e, F - 1e3 * L.time + 1 | 0)
                    }, S = 1, B(2))
                },
                sleep: function () {
                    (C ? x.cancelAnimationFrame : clearTimeout)(E), S = 0, A = Te
                },
                lagSmoothing: function (e, t) {
                    D = e || 1e8, k = Math.min(t, D, 0)
                },
                fps: function (e) {
                    z = 1e3 / (e || 240), F = 1e3 * L.time + z
                },
                add: function (e) {
                    H.indexOf(e) < 0 && H.push(e), Vt()
                },
                remove: function (e) {
                    var t;
                    ~(t = H.indexOf(e)) && H.splice(t, 1) && R >= t && R--
                },
                _listeners: H = []
            }),
            Vt = function () {
                return !S && Gt.wake()
            },
            Wt = {},
            qt = /^[\d.\-M][\d.\-,\s]/,
            $t = /["']/g,
            Xt = function (e) {
                for (var t, n, i, r = {}, o = e.substr(1, e.length - 3).split(":"), a = o[0], s = 1, l = o.length; s < l; s++) n = o[s], t = s !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, t), r[a] = isNaN(i) ? i.replace($t, "").trim() : +i, a = n.substr(t + 1).trim();
                return r
            },
            Yt = function (e) {
                return function (t) {
                    return 1 - e(1 - t)
                }
            },
            Zt = function e(t, n) {
                for (var i, r = t._first; r;) r instanceof on ? e(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? e(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next
            },
            Jt = function (e, t) {
                return e && (ne(e) ? e : Wt[e] || function (e) {
                    var t, n, i, r, o = (e + "").split("("),
                        a = Wt[o[0]];
                    return a && o.length > 1 && a.config ? a.config.apply(null, ~e.indexOf("{") ? [Xt(o[1])] : (t = e, n = t.indexOf("(") + 1, i = t.indexOf(")"), r = t.indexOf("(", n), t.substring(n, ~r && r < i ? t.indexOf(")", i + 1) : i)).split(",").map(je)) : Wt._CE && qt.test(e) ? Wt._CE("", e) : a
                }(e)) || t
            },
            Qt = function (e, t, n, i) {
                void 0 === n && (n = function (e) {
                    return 1 - t(1 - e)
                }), void 0 === i && (i = function (e) {
                    return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2
                });
                var r, o = {
                    easeIn: t,
                    easeOut: n,
                    easeInOut: i
                };
                return Ie(e, (function (e) {
                    for (var t in Wt[e] = ye[e] = o, Wt[r = e.toLowerCase()] = n, o) Wt[r + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = Wt[e + "." + t] = o[t]
                })), o
            },
            Kt = function (e) {
                return function (t) {
                    return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2
                }
            },
            en = function e(t, n, i) {
                var r = n >= 1 ? n : 1,
                    o = (i || (t ? .3 : .45)) / (n < 1 ? n : 1),
                    a = o / Y * (Math.asin(1 / r) || 0),
                    s = function (e) {
                        return 1 === e ? 1 : r * Math.pow(2, -10 * e) * ee((e - a) * o) + 1
                    },
                    l = "out" === t ? s : "in" === t ? function (e) {
                        return 1 - s(1 - e)
                    } : Kt(s);
                return o = Y / o, l.config = function (n, i) {
                    return e(t, n, i)
                }, l
            },
            tn = function e(t, n) {
                void 0 === n && (n = 1.70158);
                var i = function (e) {
                    return e ? --e * e * ((n + 1) * e + n) + 1 : 0
                },
                    r = "out" === t ? i : "in" === t ? function (e) {
                        return 1 - i(1 - e)
                    } : Kt(i);
                return r.config = function (n) {
                    return e(t, n)
                }, r
            };
        Ie("Linear,Quad,Cubic,Quart,Quint,Strong", (function (e, t) {
            var n = t < 5 ? t + 1 : t;
            Qt(e + ",Power" + (n - 1), t ? function (e) {
                return Math.pow(e, n)
            } : function (e) {
                return e
            }, (function (e) {
                return 1 - Math.pow(1 - e, n)
            }), (function (e) {
                return e < .5 ? Math.pow(2 * e, n) / 2 : 1 - Math.pow(2 * (1 - e), n) / 2
            }))
        })), Wt.Linear.easeNone = Wt.none = Wt.Linear.easeIn, Qt("Elastic", en("in"), en("out"), en()), U = 7.5625, G = 1 / (j = 2.75), Qt("Bounce", (function (e) {
            return 1 - V(1 - e)
        }), V = function (e) {
            return e < G ? U * e * e : e < .7272727272727273 ? U * Math.pow(e - 1.5 / j, 2) + .75 : e < .9090909090909092 ? U * (e -= 2.25 / j) * e + .9375 : U * Math.pow(e - 2.625 / j, 2) + .984375
        }), Qt("Expo", (function (e) {
            return e ? Math.pow(2, 10 * (e - 1)) : 0
        })), Qt("Circ", (function (e) {
            return -(Q(1 - e * e) - 1)
        })), Qt("Sine", (function (e) {
            return 1 === e ? 1 : 1 - K(e * Z)
        })), Qt("Back", tn("in"), tn("out"), tn()), Wt.SteppedEase = Wt.steps = ye.SteppedEase = {
            config: function (e, t) {
                void 0 === e && (e = 1);
                var n = 1 / e,
                    i = e + (t ? 0 : 1),
                    r = t ? 1 : 0;
                return function (e) {
                    return ((i * gt(0, .99999999, e) | 0) + r) * n
                }
            }
        }, q.ease = Wt["quad.out"], Ie("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (e) {
            return Oe += e + "," + e + "Params,"
        }));
        var nn = function (e, t) {
            this.id = J++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : Ne, this.set = t ? t.getSetter : xn
        },
            rn = function () {
                function e(e, t) {
                    var n = e.parent || y;
                    this.vars = e, this._delay = +e.delay || 0, (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase), this._ts = 1, ht(this, +e.duration, 1, 1), this.data = e.data, S || Gt.wake(), n && st(n, this, t || 0 === t ? t : n._time, 1), e.reversed && this.reverse(), e.paused && this.paused(!0)
                }
                var t = e.prototype;
                return t.delay = function (e) {
                    return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay), this._delay = e, this) : this._delay
                }, t.duration = function (e) {
                    return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur
                }, t.totalDuration = function (e) {
                    return arguments.length ? (this._dirty = 0, ht(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                }, t.totalTime = function (e, t) {
                    if (Vt(), !arguments.length) return this._tTime;
                    var n = this._dp;
                    if (n && n.smoothChildTiming && this._ts) {
                        for (ot(this, e), !n._dp || n.parent || at(n, this); n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                        !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && st(this._dp, this, this._start - this._delay)
                    }
                    return (this._tTime !== e || !this._dur && !t || this._initted && Math.abs(this._zTime) === X || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e), Ue(this, e, t)), this
                }, t.time = function (e, t) {
                    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + tt(this)) % this._dur || (e ? this._dur : 0), t) : this._time
                }, t.totalProgress = function (e, t) {
                    return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
                }, t.progress = function (e, t) {
                    return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + tt(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
                }, t.iteration = function (e, t) {
                    var n = this.duration() + this._rDelay;
                    return arguments.length ? this.totalTime(this._time + (e - 1) * n, t) : this._repeat ? nt(this._tTime, n) + 1 : 1
                }, t.timeScale = function (e) {
                    if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                    if (this._rts === e) return this;
                    var t = this.parent && this._ts ? it(this.parent._time, this) : this._tTime;
                    return this._rts = +e || 0, this._ts = this._ps || -1e-8 === e ? 0 : this._rts, Ke(this.totalTime(gt(-this._delay, this._tDur, t), !0))
                }, t.paused = function (e) {
                    return arguments.length ? (this._ps !== e && (this._ps = e, e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Vt(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= X) && Math.abs(this._zTime) !== X))), this) : this._ps
                }, t.startTime = function (e) {
                    if (arguments.length) {
                        this._start = e;
                        var t = this.parent || this._dp;
                        return t && (t._sort || !this.parent) && st(t, this, e - this._delay), this
                    }
                    return this._start
                }, t.endTime = function (e) {
                    return this._start + (ae(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
                }, t.rawTime = function (e) {
                    var t = this.parent || this._dp;
                    return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? it(t.rawTime(e), this) : this._tTime : this._tTime
                }, t.globalTime = function (e) {
                    for (var t = this, n = arguments.length ? e : t.rawTime(); t;) n = t._start + n / (t._ts || 1), t = t._dp;
                    return n
                }, t.repeat = function (e) {
                    return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e, dt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
                }, t.repeatDelay = function (e) {
                    return arguments.length ? (this._rDelay = e, dt(this)) : this._rDelay
                }, t.yoyo = function (e) {
                    return arguments.length ? (this._yoyo = e, this) : this._yoyo
                }, t.seek = function (e, t) {
                    return this.totalTime(ft(this, e), ae(t))
                }, t.restart = function (e, t) {
                    return this.play().totalTime(e ? -this._delay : 0, ae(t))
                }, t.play = function (e, t) {
                    return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
                }, t.reverse = function (e, t) {
                    return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
                }, t.pause = function (e, t) {
                    return null != e && this.seek(e, t), this.paused(!0)
                }, t.resume = function () {
                    return this.paused(!1)
                }, t.reversed = function (e) {
                    return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -1e-8 : 0)), this) : this._rts < 0
                }, t.invalidate = function () {
                    return this._initted = this._act = 0, this._zTime = -1e-8, this
                }, t.isActive = function () {
                    var e, t = this.parent || this._dp,
                        n = this._start;
                    return !(t && !(this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= n && e < this.endTime(!0) - X))
                }, t.eventCallback = function (e, t, n) {
                    var i = this.vars;
                    return arguments.length > 1 ? (t ? (i[e] = t, n && (i[e + "Params"] = n), "onUpdate" === e && (this._onUpdate = t)) : delete i[e], this) : i[e]
                }, t.then = function (e) {
                    var t = this;
                    return new Promise((function (n) {
                        var i = ne(e) ? e : Ge,
                            r = function () {
                                var e = t.then;
                                t.then = null, ne(i) && (i = i(t)) && (i.then || i === t) && (t.then = e), n(i), t.then = e
                            };
                        t._initted && 1 === t.totalProgress() && t._ts >= 0 || !t._tTime && t._ts < 0 ? r() : t._prom = r
                    }))
                }, t.kill = function () {
                    Ot(this)
                }, e
            }();
        Ve(rn.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -1e-8,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var on = function (e) {
            function t(t, n) {
                var i;
                return void 0 === t && (t = {}), (i = e.call(this, t, n) || this).labels = {}, i.smoothChildTiming = !!t.smoothChildTiming, i.autoRemoveChildren = !!t.autoRemoveChildren, i._sort = ae(t.sortChildren), i.parent && at(i.parent, m(i)), t.scrollTrigger && lt(m(i), t.scrollTrigger), i
            }
            g(t, e);
            var n = t.prototype;
            return n.to = function (e, t, n) {
                return new fn(e, He(arguments, 0, this), ft(this, ie(t) ? arguments[3] : n)), this
            }, n.from = function (e, t, n) {
                return new fn(e, He(arguments, 1, this), ft(this, ie(t) ? arguments[3] : n)), this
            }, n.fromTo = function (e, t, n, i) {
                return new fn(e, He(arguments, 2, this), ft(this, ie(t) ? arguments[4] : i)), this
            }, n.set = function (e, t, n) {
                return t.duration = 0, t.parent = this, Ye(t).repeatDelay || (t.repeat = 0), t.immediateRender = !!t.immediateRender, new fn(e, t, ft(this, n), 1), this
            }, n.call = function (e, t, n) {
                return st(this, fn.delayedCall(0, e, t), ft(this, n))
            }, n.staggerTo = function (e, t, n, i, r, o, a) {
                return n.duration = t, n.stagger = n.stagger || i, n.onComplete = o, n.onCompleteParams = a, n.parent = this, new fn(e, n, ft(this, r)), this
            }, n.staggerFrom = function (e, t, n, i, r, o, a) {
                return n.runBackwards = 1, Ye(n).immediateRender = ae(n.immediateRender), this.staggerTo(e, t, n, i, r, o, a)
            }, n.staggerFromTo = function (e, t, n, i, r, o, a, s) {
                return i.startAt = n, Ye(i).immediateRender = ae(i.immediateRender), this.staggerTo(e, t, i, r, o, a, s)
            }, n.render = function (e, t, n) {
                var i, r, o, a, s, l, c, u, h, d, p, f, m = this._time,
                    g = this._dirty ? this.totalDuration() : this._tDur,
                    v = this._dur,
                    x = this !== y && e > g - X && e >= 0 ? g : e < X ? 0 : e,
                    w = this._zTime < 0 != e < 0 && (this._initted || !v);
                if (x !== this._tTime || n || w) {
                    if (m !== this._time && v && (x += this._time - m, e += this._time - m), i = x, h = this._start, l = !(u = this._ts), w && (v || (m = this._zTime), (e || !t) && (this._zTime = e)), this._repeat) {
                        if (p = this._yoyo, s = v + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * s + e, t, n);
                        if (i = ze(x % s), x === g ? (a = this._repeat, i = v) : ((a = ~~(x / s)) && a === x / s && (i = v, a--), i > v && (i = v)), d = nt(this._tTime, s), !m && this._tTime && d !== a && (d = a), p && 1 & a && (i = v - i, f = 1), a !== d && !this._lock) {
                            var b = p && 1 & d,
                                _ = b === (p && 1 & a);
                            if (a < d && (b = !b), m = b ? 0 : v, this._lock = 1, this.render(m || (f ? 0 : ze(a * s)), t, !v)._lock = 0, !t && this.parent && Rt(this, "onRepeat"), this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1), m && m !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                            if (v = this._dur, g = this._tDur, _ && (this._lock = 2, m = b ? v : -1e-4, this.render(m, !0)), this._lock = 0, !this._ts && !l) return this;
                            Zt(this, f)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (c = function (e, t, n) {
                        var i;
                        if (n > t)
                            for (i = e._first; i && i._start <= n;) {
                                if (!i._dur && "isPause" === i.data && i._start > t) return i;
                                i = i._next
                            } else
                            for (i = e._last; i && i._start >= n;) {
                                if (!i._dur && "isPause" === i.data && i._start < t) return i;
                                i = i._prev
                            }
                    }(this, ze(m), ze(i))) && (x -= i - (i = c._start)), this._tTime = x, this._time = i, this._act = !u, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = e, m = 0), !m && i && !t && Rt(this, "onStart"), i >= m && e >= 0)
                        for (r = this._first; r;) {
                            if (o = r._next, (r._act || i >= r._start) && r._ts && c !== r) {
                                if (r.parent !== this) return this.render(e, t, n);
                                if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, t, n), i !== this._time || !this._ts && !l) {
                                    c = 0, o && (x += this._zTime = -1e-8);
                                    break
                                }
                            }
                            r = o
                        } else {
                        r = this._last;
                        for (var M = e < 0 ? e : i; r;) {
                            if (o = r._prev, (r._act || M <= r._end) && r._ts && c !== r) {
                                if (r.parent !== this) return this.render(e, t, n);
                                if (r.render(r._ts > 0 ? (M - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (M - r._start) * r._ts, t, n), i !== this._time || !this._ts && !l) {
                                    c = 0, o && (x += this._zTime = M ? -1e-8 : X);
                                    break
                                }
                            }
                            r = o
                        }
                    }
                    if (c && !t && (this.pause(), c.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1, this._ts)) return this._start = h, rt(this), this.render(e, t, n);
                    this._onUpdate && !t && Rt(this, "onUpdate", !0), (x === g && g >= this.totalDuration() || !x && m) && (h !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((e || !v) && (x === g && this._ts > 0 || !x && this._ts < 0) && Je(this, 1), t || e < 0 && !m || !x && !m || (Rt(this, x === g ? "onComplete" : "onReverseComplete", !0), this._prom && !(x < g && this.timeScale() > 0) && this._prom())))
                }
                return this
            }, n.add = function (e, t) {
                var n = this;
                if (ie(t) || (t = ft(this, t)), !(e instanceof rn)) {
                    if (ue(e)) return e.forEach((function (e) {
                        return n.add(e, t)
                    })), this;
                    if (te(e)) return this.addLabel(e, t);
                    if (!ne(e)) return this;
                    e = fn.delayedCall(0, e)
                }
                return this !== e ? st(this, e, t) : this
            }, n.getChildren = function (e, t, n, i) {
                void 0 === e && (e = !0), void 0 === t && (t = !0), void 0 === n && (n = !0), void 0 === i && (i = -$);
                for (var r = [], o = this._first; o;) o._start >= i && (o instanceof fn ? t && r.push(o) : (n && r.push(o), e && r.push.apply(r, o.getChildren(!0, t, n)))), o = o._next;
                return r
            }, n.getById = function (e) {
                for (var t = this.getChildren(1, 1, 1), n = t.length; n--;)
                    if (t[n].vars.id === e) return t[n]
            }, n.remove = function (e) {
                return te(e) ? this.removeLabel(e) : ne(e) ? this.killTweensOf(e) : (Ze(this, e), e === this._recent && (this._recent = this._last), Qe(this))
            }, n.totalTime = function (t, n) {
                return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = ze(Gt.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))), e.prototype.totalTime.call(this, t, n), this._forcing = 0, this) : this._tTime
            }, n.addLabel = function (e, t) {
                return this.labels[e] = ft(this, t), this
            }, n.removeLabel = function (e) {
                return delete this.labels[e], this
            }, n.addPause = function (e, t, n) {
                var i = fn.delayedCall(0, t || Te, n);
                return i.data = "isPause", this._hasPause = 1, st(this, i, ft(this, e))
            }, n.removePause = function (e) {
                var t = this._first;
                for (e = ft(this, e); t;) t._start === e && "isPause" === t.data && Je(t), t = t._next
            }, n.killTweensOf = function (e, t, n) {
                for (var i = this.getTweensOf(e, n), r = i.length; r--;) an !== i[r] && i[r].kill(e, t);
                return this
            }, n.getTweensOf = function (e, t) {
                for (var n, i = [], r = bt(e), o = this._first, a = ie(t); o;) o instanceof fn ? Fe(o._targets, r) && (a ? (!an || o._initted && o._ts) && o.globalTime(0) <= t && o.globalTime(o.totalDuration()) > t : !t || o.isActive()) && i.push(o) : (n = o.getTweensOf(r, t)).length && i.push.apply(i, n), o = o._next;
                return i
            }, n.tweenTo = function (e, t) {
                t = t || {};
                var n = this,
                    i = ft(n, e),
                    r = t,
                    o = r.startAt,
                    a = r.onStart,
                    s = r.onStartParams,
                    l = r.immediateRender,
                    c = fn.to(n, Ve({
                        ease: t.ease || "none",
                        lazy: !1,
                        immediateRender: !1,
                        time: i,
                        overwrite: "auto",
                        duration: t.duration || Math.abs((i - (o && "time" in o ? o.time : n._time)) / n.timeScale()) || X,
                        onStart: function () {
                            n.pause();
                            var e = t.duration || Math.abs((i - n._time) / n.timeScale());
                            c._dur !== e && ht(c, e, 0, 1).render(c._time, !0, !0), a && a.apply(c, s || [])
                        }
                    }, t));
                return l ? c.render(0) : c
            }, n.tweenFromTo = function (e, t, n) {
                return this.tweenTo(t, Ve({
                    startAt: {
                        time: ft(this, e)
                    }
                }, n))
            }, n.recent = function () {
                return this._recent
            }, n.nextLabel = function (e) {
                return void 0 === e && (e = this._time), Pt(this, ft(this, e))
            }, n.previousLabel = function (e) {
                return void 0 === e && (e = this._time), Pt(this, ft(this, e), 1)
            }, n.currentLabel = function (e) {
                return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + X)
            }, n.shiftChildren = function (e, t, n) {
                void 0 === n && (n = 0);
                for (var i, r = this._first, o = this.labels; r;) r._start >= n && (r._start += e, r._end += e), r = r._next;
                if (t)
                    for (i in o) o[i] >= n && (o[i] += e);
                return Qe(this)
            }, n.invalidate = function () {
                var t = this._first;
                for (this._lock = 0; t;) t.invalidate(), t = t._next;
                return e.prototype.invalidate.call(this)
            }, n.clear = function (e) {
                void 0 === e && (e = !0);
                for (var t, n = this._first; n;) t = n._next, this.remove(n), n = t;
                return this._dp && (this._time = this._tTime = this._pTime = 0), e && (this.labels = {}), Qe(this)
            }, n.totalDuration = function (e) {
                var t, n, i, r = 0,
                    o = this,
                    a = o._last,
                    s = $;
                if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -e : e));
                if (o._dirty) {
                    for (i = o.parent; a;) t = a._prev, a._dirty && a.totalDuration(), (n = a._start) > s && o._sort && a._ts && !o._lock ? (o._lock = 1, st(o, a, n - a._delay, 1)._lock = 0) : s = n, n < 0 && a._ts && (r -= n, (!i && !o._dp || i && i.smoothChildTiming) && (o._start += n / o._ts, o._time -= n, o._tTime -= n), o.shiftChildren(-n, !1, -Infinity), s = 0), a._end > r && a._ts && (r = a._end), a = t;
                    ht(o, o === y && o._time > r ? o._time : r, 1, 1), o._dirty = 0
                }
                return o._tDur
            }, t.updateRoot = function (e) {
                if (y._ts && (Ue(y, it(e, y)), M = Gt.frame), Gt.frame >= Pe) {
                    Pe += W.autoSleep || 120;
                    var t = y._first;
                    if ((!t || !t._ts) && W.autoSleep && Gt._listeners.length < 2) {
                        for (; t && !t._ts;) t = t._next;
                        t || Gt.sleep()
                    }
                }
            }, t
        }(rn);
        Ve(on.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var an, sn = function (e, t, n, i, r, o, a) {
            var s, l, c, u, h, d, p, f, m = new Cn(this._pt, e, t, 0, 1, _n, null, r),
                g = 0,
                v = 0;
            for (m.b = n, m.e = i, n += "", (p = ~(i += "").indexOf("random(")) && (i = Ct(i)), o && (o(f = [n, i], e, t), n = f[0], i = f[1]), l = n.match(fe) || []; s = fe.exec(i);) u = s[0], h = i.substring(g, s.index), c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1), u !== l[v++] && (d = parseFloat(l[v - 1]) || 0, m._pt = {
                _next: m._pt,
                p: h || 1 === v ? h : ",",
                s: d,
                c: "=" === u.charAt(1) ? parseFloat(u.substr(2)) * ("-" === u.charAt(0) ? -1 : 1) : parseFloat(u) - d,
                m: c && c < 4 ? Math.round : 0
            }, g = fe.lastIndex);
            return m.c = g < i.length ? i.substring(g, i.length) : "", m.fp = a, (me.test(i) || p) && (m.e = 0), this._pt = m, m
        },
            ln = function (e, t, n, i, r, o, a, s, l) {
                ne(i) && (i = i(r || 0, e, o));
                var c, u = e[t],
                    h = "get" !== n ? n : ne(u) ? l ? e[t.indexOf("set") || !ne(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : u,
                    d = ne(u) ? l ? vn : gn : mn;
                if (te(i) && (~i.indexOf("random(") && (i = Ct(i)), "=" === i.charAt(1) && (i = parseFloat(h) + parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) + (vt(h) || 0))), h !== i) return isNaN(h * i) ? (!u && !(t in e) && be(t, i), sn.call(this, e, t, h, i, d, s || W.stringFilter, l)) : (c = new Cn(this._pt, e, t, +h || 0, i - (h || 0), "boolean" == typeof u ? bn : wn, 0, d), l && (c.fp = l), a && c.modifier(a, this, e), this._pt = c)
            },
            cn = function (e, t, n, i, r, o) {
                var a, s, l, c;
                if (Ce[e] && !1 !== (a = new Ce[e]).init(r, a.rawVars ? t[e] : function (e, t, n, i, r) {
                    if (ne(e) && (e = hn(e, r, t, n, i)), !oe(e) || e.style && e.nodeType || ue(e) || ce(e)) return te(e) ? hn(e, r, t, n, i) : e;
                    var o, a = {};
                    for (o in e) a[o] = hn(e[o], r, t, n, i);
                    return a
                }(t[e], i, r, o, n), n, i, o) && (n._pt = s = new Cn(n._pt, r, e, 0, 1, a.render, a, 0, a.priority), n !== T))
                    for (l = n._ptLookup[n._targets.indexOf(r)], c = a._props.length; c--;) l[a._props[c]] = s;
                return a
            },
            un = function e(t, n) {
                var i, r, o, a, s, l, c, u, h, d, p, f, m, g = t.vars,
                    x = g.ease,
                    w = g.startAt,
                    b = g.immediateRender,
                    _ = g.lazy,
                    M = g.onUpdate,
                    T = g.onUpdateParams,
                    S = g.callbackScope,
                    E = g.runBackwards,
                    A = g.yoyoEase,
                    C = g.keyframes,
                    L = g.autoRevert,
                    P = t._dur,
                    R = t._startAt,
                    O = t._targets,
                    D = t.parent,
                    k = D && "nested" === D.data ? D.parent._targets : O,
                    N = "auto" === t._overwrite && !v,
                    I = t.timeline;
                if (I && (!C || !x) && (x = "none"), t._ease = Jt(x, q.ease), t._yEase = A ? Yt(Jt(!0 === A ? x : A, q.ease)) : 0, A && t._yoyo && !t._repeat && (A = t._yEase, t._yEase = t._ease, t._ease = A), !I) {
                    if (f = (u = O[0] ? ke(O[0]).harness : 0) && g[u.prop], i = Xe(g, Se), R && R.render(-1, !0).kill(), w)
                        if (Je(t._startAt = fn.set(O, Ve({
                            data: "isStart",
                            overwrite: !1,
                            parent: D,
                            immediateRender: !0,
                            lazy: ae(_),
                            startAt: null,
                            delay: 0,
                            onUpdate: M,
                            onUpdateParams: T,
                            callbackScope: S,
                            stagger: 0
                        }, w))), b) {
                            if (n > 0) L || (t._startAt = 0);
                            else if (P && !(n < 0 && R)) return void (n && (t._zTime = n))
                        } else !1 === L && (t._startAt = 0);
                    else if (E && P)
                        if (R) !L && (t._startAt = 0);
                        else if (n && (b = !1), o = Ve({
                            overwrite: !1,
                            data: "isFromStart",
                            lazy: b && ae(_),
                            immediateRender: b,
                            stagger: 0,
                            parent: D
                        }, i), f && (o[u.prop] = f), Je(t._startAt = fn.set(O, o)), b) {
                            if (!n) return
                        } else e(t._startAt, X);
                    for (t._pt = 0, _ = P && ae(_) || _ && !P, r = 0; r < O.length; r++) {
                        if (c = (s = O[r])._gsap || De(O)[r]._gsap, t._ptLookup[r] = d = {}, Ae[c.id] && Ee.length && Be(), p = k === O ? r : k.indexOf(s), u && !1 !== (h = new u).init(s, f || i, t, p, k) && (t._pt = a = new Cn(t._pt, s, h.name, 0, 1, h.render, h, 0, h.priority), h._props.forEach((function (e) {
                            d[e] = a
                        })), h.priority && (l = 1)), !u || f)
                            for (o in i) Ce[o] && (h = cn(o, i, t, p, s, k)) ? h.priority && (l = 1) : d[o] = a = ln.call(t, s, o, "get", i[o], p, k, 0, g.stringFilter);
                        t._op && t._op[r] && t.kill(s, t._op[r]), N && t._pt && (an = t, y.killTweensOf(s, d, t.globalTime(0)), m = !t.parent, an = 0), t._pt && _ && (Ae[c.id] = 1)
                    }
                    l && An(t), t._onInit && t._onInit(t)
                }
                t._from = !I && !!g.runBackwards, t._onUpdate = M, t._initted = (!t._op || t._pt) && !m
            },
            hn = function (e, t, n, i, r) {
                return ne(e) ? e.call(t, n, i, r) : te(e) && ~e.indexOf("random(") ? Ct(e) : e
            },
            dn = Oe + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
            pn = (dn + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
            fn = function (e) {
                function t(t, n, i, r) {
                    var o;
                    "number" == typeof n && (i.duration = n, n = i, i = null);
                    var a, s, l, c, u, h, d, p, f = (o = e.call(this, r ? n : Ye(n), i) || this).vars,
                        g = f.duration,
                        x = f.delay,
                        w = f.immediateRender,
                        b = f.stagger,
                        _ = f.overwrite,
                        M = f.keyframes,
                        T = f.defaults,
                        S = f.scrollTrigger,
                        E = f.yoyoEase,
                        A = o.parent,
                        C = (ue(t) || ce(t) ? ie(t[0]) : "length" in n) ? [t] : bt(t);
                    if (o._targets = C.length ? De(C) : _e("GSAP target " + t + " not found. https://greensock.com", !W.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = _, M || b || le(g) || le(x)) {
                        if (n = o.vars, (a = o.timeline = new on({
                            data: "nested",
                            defaults: T || {}
                        })).kill(), a.parent = a._dp = m(o), a._start = 0, M) Ve(a.vars.defaults, {
                            ease: "none"
                        }), M.forEach((function (e) {
                            return a.to(C, e, ">")
                        }));
                        else {
                            if (c = C.length, d = b ? Mt(b) : Te, oe(b))
                                for (u in b) ~dn.indexOf(u) && (p || (p = {}), p[u] = b[u]);
                            for (s = 0; s < c; s++) {
                                for (u in l = {}, n) pn.indexOf(u) < 0 && (l[u] = n[u]);
                                l.stagger = 0, E && (l.yoyoEase = E), p && qe(l, p), h = C[s], l.duration = +hn(g, m(o), s, h, C), l.delay = (+hn(x, m(o), s, h, C) || 0) - o._delay, !b && 1 === c && l.delay && (o._delay = x = l.delay, o._start += x, l.delay = 0), a.to(h, l, d(s, h, C))
                            }
                            a.duration() ? g = x = 0 : o.timeline = 0
                        }
                        g || o.duration(g = a.duration())
                    } else o.timeline = 0;
                    return !0 !== _ || v || (an = m(o), y.killTweensOf(C), an = 0), A && at(A, m(o)), (w || !g && !M && o._start === ze(A._time) && ae(w) && et(m(o)) && "nested" !== A.data) && (o._tTime = -1e-8, o.render(Math.max(0, -x))), S && lt(m(o), S), o
                }
                g(t, e);
                var n = t.prototype;
                return n.render = function (e, t, n) {
                    var i, r, o, a, s, l, c, u, h, d = this._time,
                        p = this._tDur,
                        f = this._dur,
                        m = e > p - X && e >= 0 ? p : e < X ? 0 : e;
                    if (f) {
                        if (m !== this._tTime || !e || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 != e < 0) {
                            if (i = m, u = this.timeline, this._repeat) {
                                if (a = f + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * a + e, t, n);
                                if (i = ze(m % a), m === p ? (o = this._repeat, i = f) : ((o = ~~(m / a)) && o === m / a && (i = f, o--), i > f && (i = f)), (l = this._yoyo && 1 & o) && (h = this._yEase, i = f - i), s = nt(this._tTime, a), i === d && !n && this._initted) return this;
                                o !== s && (u && this._yEase && Zt(u, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1, this.render(ze(a * o), !0).invalidate()._lock = 0))
                            }
                            if (!this._initted) {
                                if (ct(this, e < 0 ? e : i, n, t)) return this._tTime = 0, this;
                                if (f !== this._dur) return this.render(e, t, n)
                            }
                            for (this._tTime = m, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (h || this._ease)(i / f), this._from && (this.ratio = c = 1 - c), i && !d && !t && Rt(this, "onStart"), r = this._pt; r;) r.r(c, r.d), r = r._next;
                            u && u.render(e < 0 ? e : !i && l ? -1e-8 : u._dur * c, t, n) || this._startAt && (this._zTime = e), this._onUpdate && !t && (e < 0 && this._startAt && this._startAt.render(e, !0, n), Rt(this, "onUpdate")), this._repeat && o !== s && this.vars.onRepeat && !t && this.parent && Rt(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (e < 0 && this._startAt && !this._onUpdate && this._startAt.render(e, !0, !0), (e || !f) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && Je(this, 1), t || e < 0 && !d || !m && !d || (Rt(this, m === p ? "onComplete" : "onReverseComplete", !0), this._prom && !(m < p && this.timeScale() > 0) && this._prom()))
                        }
                    } else ! function (e, t, n, i) {
                        var r, o, a, s = e.ratio,
                            l = t < 0 || !t && (!e._start && ut(e) || (e._ts < 0 || e._dp._ts < 0) && "isFromStart" !== e.data && "isStart" !== e.data) ? 0 : 1,
                            c = e._rDelay,
                            u = 0;
                        if (c && e._repeat && (u = gt(0, e._tDur, t), o = nt(u, c), a = nt(e._tTime, c), e._yoyo && 1 & o && (l = 1 - l), o !== a && (s = 1 - l, e.vars.repeatRefresh && e._initted && e.invalidate())), l !== s || i || e._zTime === X || !t && e._zTime) {
                            if (!e._initted && ct(e, t, i, n)) return;
                            for (a = e._zTime, e._zTime = t || (n ? X : 0), n || (n = t && !a), e.ratio = l, e._from && (l = 1 - l), e._time = 0, e._tTime = u, r = e._pt; r;) r.r(l, r.d), r = r._next;
                            e._startAt && t < 0 && e._startAt.render(t, !0, !0), e._onUpdate && !n && Rt(e, "onUpdate"), u && e._repeat && !n && e.parent && Rt(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === l && (l && Je(e, 1), n || (Rt(e, l ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
                        } else e._zTime || (e._zTime = t)
                    }(this, e, t, n);
                    return this
                }, n.targets = function () {
                    return this._targets
                }, n.invalidate = function () {
                    return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), e.prototype.invalidate.call(this)
                }, n.kill = function (e, t) {
                    if (void 0 === t && (t = "all"), !(e || t && "all" !== t)) return this._lazy = this._pt = 0, this.parent ? Ot(this) : this;
                    if (this.timeline) {
                        var n = this.timeline.totalDuration();
                        return this.timeline.killTweensOf(e, t, an && !0 !== an.vars.overwrite)._first || Ot(this), this.parent && n !== this.timeline.totalDuration() && ht(this, this._dur * this.timeline._tDur / n, 0, 1), this
                    }
                    var i, r, o, a, s, l, c, u = this._targets,
                        h = e ? bt(e) : u,
                        d = this._ptLookup,
                        p = this._pt;
                    if ((!t || "all" === t) && function (e, t) {
                        for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n];);
                        return n < 0
                    }(u, h)) return "all" === t && (this._pt = 0), Ot(this);
                    for (i = this._op = this._op || [], "all" !== t && (te(t) && (s = {}, Ie(t, (function (e) {
                        return s[e] = 1
                    })), t = s), t = function (e, t) {
                        var n, i, r, o, a = e[0] ? ke(e[0]).harness : 0,
                            s = a && a.aliases;
                        if (!s) return t;
                        for (i in n = qe({}, t), s)
                            if (i in n)
                                for (r = (o = s[i].split(",")).length; r--;) n[o[r]] = n[i];
                        return n
                    }(u, t)), c = u.length; c--;)
                        if (~h.indexOf(u[c]))
                            for (s in r = d[c], "all" === t ? (i[c] = t, a = r, o = {}) : (o = i[c] = i[c] || {}, a = t), a) (l = r && r[s]) && ("kill" in l.d && !0 !== l.d.kill(s) || Ze(this, l, "_pt"), delete r[s]), "all" !== o && (o[s] = 1);
                    return this._initted && !this._pt && p && Ot(this), this
                }, t.to = function (e, n) {
                    return new t(e, n, arguments[2])
                }, t.from = function (e, n) {
                    return new t(e, He(arguments, 1))
                }, t.delayedCall = function (e, n, i, r) {
                    return new t(n, 0, {
                        immediateRender: !1,
                        lazy: !1,
                        overwrite: !1,
                        delay: e,
                        onComplete: n,
                        onReverseComplete: n,
                        onCompleteParams: i,
                        onReverseCompleteParams: i,
                        callbackScope: r
                    })
                }, t.fromTo = function (e, n, i) {
                    return new t(e, He(arguments, 2))
                }, t.set = function (e, n) {
                    return n.duration = 0, n.repeatDelay || (n.repeat = 0), new t(e, n)
                }, t.killTweensOf = function (e, t, n) {
                    return y.killTweensOf(e, t, n)
                }, t
            }(rn);
        Ve(fn.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }), Ie("staggerTo,staggerFrom,staggerFromTo", (function (e) {
            fn[e] = function () {
                var t = new on,
                    n = yt.call(arguments, 0);
                return n.splice("staggerFromTo" === e ? 5 : 4, 0, 0), t[e].apply(t, n)
            }
        }));
        var mn = function (e, t, n) {
            return e[t] = n
        },
            gn = function (e, t, n) {
                return e[t](n)
            },
            vn = function (e, t, n, i) {
                return e[t](i.fp, n)
            },
            yn = function (e, t, n) {
                return e.setAttribute(t, n)
            },
            xn = function (e, t) {
                return ne(e[t]) ? gn : re(e[t]) && e.setAttribute ? yn : mn
            },
            wn = function (e, t) {
                return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4, t)
            },
            bn = function (e, t) {
                return t.set(t.t, t.p, !!(t.s + t.c * e), t)
            },
            _n = function (e, t) {
                var n = t._pt,
                    i = "";
                if (!e && t.b) i = t.b;
                else if (1 === e && t.e) i = t.e;
                else {
                    for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round(1e4 * (n.s + n.c * e)) / 1e4) + i, n = n._next;
                    i += t.c
                }
                t.set(t.t, t.p, i, t)
            },
            Mn = function (e, t) {
                for (var n = t._pt; n;) n.r(e, n.d), n = n._next
            },
            Tn = function (e, t, n, i) {
                for (var r, o = this._pt; o;) r = o._next, o.p === i && o.modifier(e, t, n), o = r
            },
            Sn = function (e) {
                for (var t, n, i = this._pt; i;) n = i._next, i.p === e && !i.op || i.op === e ? Ze(this, i, "_pt") : i.dep || (t = 1), i = n;
                return !t
            },
            En = function (e, t, n, i) {
                i.mSet(e, t, i.m.call(i.tween, n, i.mt), i)
            },
            An = function (e) {
                for (var t, n, i, r, o = e._pt; o;) {
                    for (t = o._next, n = i; n && n.pr > o.pr;) n = n._next;
                    (o._prev = n ? n._prev : r) ? o._prev._next = o : i = o, (o._next = n) ? n._prev = o : r = o, o = t
                }
                e._pt = i
            },
            Cn = function () {
                function e(e, t, n, i, r, o, a, s, l) {
                    this.t = t, this.s = i, this.c = r, this.p = n, this.r = o || wn, this.d = a || this, this.set = s || mn, this.pr = l || 0, this._next = e, e && (e._prev = this)
                }
                return e.prototype.modifier = function (e, t, n) {
                    this.mSet = this.mSet || this.set, this.set = En, this.m = e, this.mt = n, this.tween = t
                }, e
            }();
        Ie(Oe + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (e) {
            return Se[e] = 1
        })), ye.TweenMax = ye.TweenLite = fn, ye.TimelineLite = ye.TimelineMax = on, y = new on({
            sortChildren: !1,
            defaults: q,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }), W.stringFilter = jt;
        var Ln = {
            registerPlugin: function () {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                t.forEach((function (e) {
                    return Dt(e)
                }))
            },
            timeline: function (e) {
                return new on(e)
            },
            getTweensOf: function (e, t) {
                return y.getTweensOf(e, t)
            },
            getProperty: function (e, t, n, i) {
                te(e) && (e = bt(e)[0]);
                var r = ke(e || {}).get,
                    o = n ? Ge : je;
                return "native" === n && (n = ""), e ? t ? o((Ce[t] && Ce[t].get || r)(e, t, n, i)) : function (t, n, i) {
                    return o((Ce[t] && Ce[t].get || r)(e, t, n, i))
                } : e
            },
            quickSetter: function (e, t, n) {
                if ((e = bt(e)).length > 1) {
                    var i = e.map((function (e) {
                        return On.quickSetter(e, t, n)
                    })),
                        r = i.length;
                    return function (e) {
                        for (var t = r; t--;) i[t](e)
                    }
                }
                e = e[0] || {};
                var o = Ce[t],
                    a = ke(e),
                    s = a.harness && (a.harness.aliases || {})[t] || t,
                    l = o ? function (t) {
                        var i = new o;
                        T._pt = 0, i.init(e, n ? t + n : t, T, 0, [e]), i.render(1, i), T._pt && Mn(1, T)
                    } : a.set(e, s);
                return o ? l : function (t) {
                    return l(e, s, n ? t + n : t, a, 1)
                }
            },
            isTweening: function (e) {
                return y.getTweensOf(e, !0).length > 0
            },
            defaults: function (e) {
                return e && e.ease && (e.ease = Jt(e.ease, q.ease)), $e(q, e || {})
            },
            config: function (e) {
                return $e(W, e || {})
            },
            registerEffect: function (e) {
                var t = e.name,
                    n = e.effect,
                    i = e.plugins,
                    r = e.defaults,
                    o = e.extendTimeline;
                (i || "").split(",").forEach((function (e) {
                    return e && !Ce[e] && !ye[e] && _e(t + " effect requires " + e + " plugin.")
                })), Le[t] = function (e, t, i) {
                    return n(bt(e), Ve(t || {}, r), i)
                }, o && (on.prototype[t] = function (e, n, i) {
                    return this.add(Le[t](e, oe(n) ? n : (i = n) && {}, this), i)
                })
            },
            registerEase: function (e, t) {
                Wt[e] = Jt(t)
            },
            parseEase: function (e, t) {
                return arguments.length ? Jt(e, t) : Wt
            },
            getById: function (e) {
                return y.getById(e)
            },
            exportRoot: function (e, t) {
                void 0 === e && (e = {});
                var n, i, r = new on(e);
                for (r.smoothChildTiming = ae(e.smoothChildTiming), y.remove(r), r._dp = 0, r._time = r._tTime = y._time, n = y._first; n;) i = n._next, !t && !n._dur && n instanceof fn && n.vars.onComplete === n._targets[0] || st(r, n, n._start - n._delay), n = i;
                return st(y, r, 0), r
            },
            utils: {
                wrap: function e(t, n, i) {
                    var r = n - t;
                    return ue(t) ? At(t, e(0, t.length), n) : mt(i, (function (e) {
                        return (r + (e - t) % r) % r + t
                    }))
                },
                wrapYoyo: function e(t, n, i) {
                    var r = n - t,
                        o = 2 * r;
                    return ue(t) ? At(t, e(0, t.length - 1), n) : mt(i, (function (e) {
                        return t + ((e = (o + (e - t) % o) % o || 0) > r ? o - e : e)
                    }))
                },
                distribute: Mt,
                random: Et,
                snap: St,
                normalize: function (e, t, n) {
                    return Lt(e, t, 0, 1, n)
                },
                getUnit: vt,
                clamp: function (e, t, n) {
                    return mt(n, (function (n) {
                        return gt(e, t, n)
                    }))
                },
                splitColor: zt,
                toArray: bt,
                mapRange: Lt,
                pipe: function () {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    return function (e) {
                        return t.reduce((function (e, t) {
                            return t(e)
                        }), e)
                    }
                },
                unitize: function (e, t) {
                    return function (n) {
                        return e(parseFloat(n)) + (t || vt(n))
                    }
                },
                interpolate: function e(t, n, i, r) {
                    var o = isNaN(t + n) ? 0 : function (e) {
                        return (1 - e) * t + e * n
                    };
                    if (!o) {
                        var a, s, l, c, u, h = te(t),
                            d = {};
                        if (!0 === i && (r = 1) && (i = null), h) t = {
                            p: t
                        }, n = {
                            p: n
                        };
                        else if (ue(t) && !ue(n)) {
                            for (l = [], c = t.length, u = c - 2, s = 1; s < c; s++) l.push(e(t[s - 1], t[s]));
                            c--, o = function (e) {
                                e *= c;
                                var t = Math.min(u, ~~e);
                                return l[t](e - t)
                            }, i = n
                        } else r || (t = qe(ue(t) ? [] : {}, t));
                        if (!l) {
                            for (a in n) ln.call(d, t, a, "get", n[a]);
                            o = function (e) {
                                return Mn(e, d) || (h ? t.p : t)
                            }
                        }
                    }
                    return mt(i, o)
                },
                shuffle: _t
            },
            install: we,
            effects: Le,
            ticker: Gt,
            updateRoot: on.updateRoot,
            plugins: Ce,
            globalTimeline: y,
            core: {
                PropTween: Cn,
                globals: Me,
                Tween: fn,
                Timeline: on,
                Animation: rn,
                getCache: ke,
                _removeLinkedListItem: Ze,
                suppressOverwrites: function (e) {
                    return v = e
                }
            }
        };
        Ie("to,from,fromTo,delayedCall,set,killTweensOf", (function (e) {
            return Ln[e] = fn[e]
        })), Gt.add(on.updateRoot), T = Ln.to({}, {
            duration: 0
        });
        var Pn = function (e, t) {
            for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t;) n = n._next;
            return n
        },
            Rn = function (e, t) {
                return {
                    name: e,
                    rawVars: 1,
                    init: function (e, n, i) {
                        i._onInit = function (e) {
                            var i, r;
                            if (te(n) && (i = {}, Ie(n, (function (e) {
                                return i[e] = 1
                            })), n = i), t) {
                                for (r in i = {}, n) i[r] = t(n[r]);
                                n = i
                            } ! function (e, t) {
                                var n, i, r, o = e._targets;
                                for (n in t)
                                    for (i = o.length; i--;)(r = e._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = Pn(r, n)), r && r.modifier && r.modifier(t[n], e, o[i], n))
                            }(e, n)
                        }
                    }
                }
            },
            On = Ln.registerPlugin({
                name: "attr",
                init: function (e, t, n, i, r) {
                    var o, a;
                    for (o in t) (a = this.add(e, "setAttribute", (e.getAttribute(o) || 0) + "", t[o], i, r, 0, 0, o)) && (a.op = o), this._props.push(o)
                }
            }, {
                name: "endArray",
                init: function (e, t) {
                    for (var n = t.length; n--;) this.add(e, n, e[n] || 0, t[n])
                }
            }, Rn("roundProps", Tt), Rn("modifiers"), Rn("snap", St)) || Ln;
        fn.version = on.version = On.version = "3.6.1", _ = 1, se() && Vt();
        Wt.Power0, Wt.Power1;
        var Dn, kn, Nn, In, zn, Fn, Hn, Bn = Wt.Power2,
            Un = Wt.Power3,
            jn = (Wt.Power4, Wt.Linear, Wt.Quad),
            Gn = (Wt.Cubic, Wt.Quart, Wt.Quint, Wt.Strong, Wt.Elastic),
            Vn = (Wt.Back, Wt.SteppedEase, Wt.Bounce, Wt.Sine, Wt.Expo),
            Wn = (Wt.Circ, {}),
            qn = 180 / Math.PI,
            $n = Math.PI / 180,
            Xn = Math.atan2,
            Yn = /([A-Z])/g,
            Zn = /(?:left|right|width|margin|padding|x)/i,
            Jn = /[\s,\(]\S/,
            Qn = {
                autoAlpha: "opacity,visibility",
                scale: "scaleX,scaleY",
                alpha: "opacity"
            },
            Kn = function (e, t) {
                return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
            },
            ei = function (e, t) {
                return t.set(t.t, t.p, 1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
            },
            ti = function (e, t) {
                return t.set(t.t, t.p, e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b, t)
            },
            ni = function (e, t) {
                var n = t.s + t.c * e;
                t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
            },
            ii = function (e, t) {
                return t.set(t.t, t.p, e ? t.e : t.b, t)
            },
            ri = function (e, t) {
                return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t)
            },
            oi = function (e, t, n) {
                return e.style[t] = n
            },
            ai = function (e, t, n) {
                return e.style.setProperty(t, n)
            },
            si = function (e, t, n) {
                return e._gsap[t] = n
            },
            li = function (e, t, n) {
                return e._gsap.scaleX = e._gsap.scaleY = n
            },
            ci = function (e, t, n, i, r) {
                var o = e._gsap;
                o.scaleX = o.scaleY = n, o.renderTransform(r, o)
            },
            ui = function (e, t, n, i, r) {
                var o = e._gsap;
                o[t] = n, o.renderTransform(r, o)
            },
            hi = "transform",
            di = hi + "Origin",
            pi = function (e, t) {
                var n = kn.createElementNS ? kn.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : kn.createElement(e);
                return n.style ? n : kn.createElement(e)
            },
            fi = function e(t, n, i) {
                var r = getComputedStyle(t);
                return r[n] || r.getPropertyValue(n.replace(Yn, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && e(t, gi(n) || n, 1) || ""
            },
            mi = "O,Moz,ms,Ms,Webkit".split(","),
            gi = function (e, t, n) {
                var i = (t || zn).style,
                    r = 5;
                if (e in i && !n) return e;
                for (e = e.charAt(0).toUpperCase() + e.substr(1); r-- && !(mi[r] + e in i););
                return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? mi[r] : "") + e
            },
            vi = function () {
                "undefined" != typeof window && window.document && (Dn = window, kn = Dn.document, Nn = kn.documentElement, zn = pi("div") || {
                    style: {}
                }, pi("div"), hi = gi(hi), di = hi + "Origin", zn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Hn = !!gi("perspective"), In = 1)
            },
            yi = function e(t) {
                var n, i = pi("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    r = this.parentNode,
                    o = this.nextSibling,
                    a = this.style.cssText;
                if (Nn.appendChild(i), i.appendChild(this), this.style.display = "block", t) try {
                    n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = e
                } catch (e) { } else this._gsapBBox && (n = this._gsapBBox());
                return r && (o ? r.insertBefore(this, o) : r.appendChild(this)), Nn.removeChild(i), this.style.cssText = a, n
            },
            xi = function (e, t) {
                for (var n = t.length; n--;)
                    if (e.hasAttribute(t[n])) return e.getAttribute(t[n])
            },
            wi = function (e) {
                var t;
                try {
                    t = e.getBBox()
                } catch (n) {
                    t = yi.call(e, !0)
                }
                return t && (t.width || t.height) || e.getBBox === yi || (t = yi.call(e, !0)), !t || t.width || t.x || t.y ? t : {
                    x: +xi(e, ["x", "cx", "x1"]) || 0,
                    y: +xi(e, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                }
            },
            bi = function (e) {
                return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !wi(e))
            },
            _i = function (e, t) {
                if (t) {
                    var n = e.style;
                    t in Wn && t !== di && (t = hi), n.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), n.removeProperty(t.replace(Yn, "-$1").toLowerCase())) : n.removeAttribute(t)
                }
            },
            Mi = function (e, t, n, i, r, o) {
                var a = new Cn(e._pt, t, n, 0, 1, o ? ri : ii);
                return e._pt = a, a.b = i, a.e = r, e._props.push(n), a
            },
            Ti = {
                deg: 1,
                rad: 1,
                turn: 1
            },
            Si = function e(t, n, i, r) {
                var o, a, s, l, c = parseFloat(i) || 0,
                    u = (i + "").trim().substr((c + "").length) || "px",
                    h = zn.style,
                    d = Zn.test(n),
                    p = "svg" === t.tagName.toLowerCase(),
                    f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
                    m = 100,
                    g = "px" === r,
                    v = "%" === r;
                return r === u || !c || Ti[r] || Ti[u] ? c : ("px" !== u && !g && (c = e(t, n, i, "px")), l = t.getCTM && bi(t), !v && "%" !== u || !Wn[n] && !~n.indexOf("adius") ? (h[d ? "width" : "height"] = m + (g ? u : r), a = ~n.indexOf("adius") || "em" === r && t.appendChild && !p ? t : t.parentNode, l && (a = (t.ownerSVGElement || {}).parentNode), a && a !== kn && a.appendChild || (a = kn.body), (s = a._gsap) && v && s.width && d && s.time === Gt.time ? ze(c / s.width * m) : ((v || "%" === u) && (h.position = fi(t, "position")), a === t && (h.position = "static"), a.appendChild(zn), o = zn[f], a.removeChild(zn), h.position = "absolute", d && v && ((s = ke(a)).time = Gt.time, s.width = a[f]), ze(g ? o * c / m : o && c ? m / o * c : 0))) : (o = l ? t.getBBox()[d ? "width" : "height"] : t[f], ze(v ? c / o * m : c / 100 * o)))
            },
            Ei = function (e, t, n, i) {
                var r;
                return In || vi(), t in Qn && "transform" !== t && ~(t = Qn[t]).indexOf(",") && (t = t.split(",")[0]), Wn[t] && "transform" !== t ? (r = zi(e, i), r = "transformOrigin" !== t ? r[t] : Fi(fi(e, di)) + " " + r.zOrigin + "px") : (!(r = e.style[t]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Pi[t] && Pi[t](e, t, n) || fi(e, t) || Ne(e, t) || ("opacity" === t ? 1 : 0)), n && !~(r + "").trim().indexOf(" ") ? Si(e, t, r, n) + n : r
            },
            Ai = function (e, t, n, i) {
                if (!n || "none" === n) {
                    var r = gi(t, e, 1),
                        o = r && fi(e, r, 1);
                    o && o !== n ? (t = r, n = o) : "borderColor" === t && (n = fi(e, "borderTopColor"))
                }
                var a, s, l, c, u, h, d, p, f, m, g, v, y = new Cn(this._pt, e.style, t, 0, 1, _n),
                    x = 0,
                    w = 0;
                if (y.b = n, y.e = i, n += "", "auto" === (i += "") && (e.style[t] = i, i = fi(e, t) || i, e.style[t] = n), jt(a = [n, i]), i = a[1], l = (n = a[0]).match(pe) || [], (i.match(pe) || []).length) {
                    for (; s = pe.exec(i);) d = s[0], f = i.substring(x, s.index), u ? u = (u + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (u = 1), d !== (h = l[w++] || "") && (c = parseFloat(h) || 0, g = h.substr((c + "").length), (v = "=" === d.charAt(1) ? +(d.charAt(0) + "1") : 0) && (d = d.substr(2)), p = parseFloat(d), m = d.substr((p + "").length), x = pe.lastIndex - m.length, m || (m = m || W.units[t] || g, x === i.length && (i += m, y.e += m)), g !== m && (c = Si(e, t, h, m) || 0), y._pt = {
                        _next: y._pt,
                        p: f || 1 === w ? f : ",",
                        s: c,
                        c: v ? v * p : p - c,
                        m: u && u < 4 || "zIndex" === t ? Math.round : 0
                    });
                    y.c = x < i.length ? i.substring(x, i.length) : ""
                } else y.r = "display" === t && "none" === i ? ri : ii;
                return me.test(i) && (y.e = 0), this._pt = y, y
            },
            Ci = {
                top: "0%",
                bottom: "100%",
                left: "0%",
                right: "100%",
                center: "50%"
            },
            Li = function (e, t) {
                if (t.tween && t.tween._time === t.tween._dur) {
                    var n, i, r, o = t.t,
                        a = o.style,
                        s = t.u,
                        l = o._gsap;
                    if ("all" === s || !0 === s) a.cssText = "", i = 1;
                    else
                        for (r = (s = s.split(",")).length; --r > -1;) n = s[r], Wn[n] && (i = 1, n = "transformOrigin" === n ? di : hi), _i(o, n);
                    i && (_i(o, hi), l && (l.svg && o.removeAttribute("transform"), zi(o, 1), l.uncache = 1))
                }
            },
            Pi = {
                clearProps: function (e, t, n, i, r) {
                    if ("isFromStart" !== r.data) {
                        var o = e._pt = new Cn(e._pt, t, n, 0, 0, Li);
                        return o.u = i, o.pr = -10, o.tween = r, e._props.push(n), 1
                    }
                }
            },
            Ri = [1, 0, 0, 1, 0, 0],
            Oi = {},
            Di = function (e) {
                return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e
            },
            ki = function (e) {
                var t = fi(e, hi);
                return Di(t) ? Ri : t.substr(7).match(de).map(ze)
            },
            Ni = function (e, t) {
                var n, i, r, o, a = e._gsap || ke(e),
                    s = e.style,
                    l = ki(e);
                return a.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = e.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Ri : l : (l !== Ri || e.offsetParent || e === Nn || a.svg || (r = s.display, s.display = "block", (n = e.parentNode) && e.offsetParent || (o = 1, i = e.nextSibling, Nn.appendChild(e)), l = ki(e), r ? s.display = r : _i(e, "display"), o && (i ? n.insertBefore(e, i) : n ? n.appendChild(e) : Nn.removeChild(e))), t && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
            },
            Ii = function (e, t, n, i, r, o) {
                var a, s, l, c = e._gsap,
                    u = r || Ni(e, !0),
                    h = c.xOrigin || 0,
                    d = c.yOrigin || 0,
                    p = c.xOffset || 0,
                    f = c.yOffset || 0,
                    m = u[0],
                    g = u[1],
                    v = u[2],
                    y = u[3],
                    x = u[4],
                    w = u[5],
                    b = t.split(" "),
                    _ = parseFloat(b[0]) || 0,
                    M = parseFloat(b[1]) || 0;
                n ? u !== Ri && (s = m * y - g * v) && (l = _ * (-g / s) + M * (m / s) - (m * w - g * x) / s, _ = _ * (y / s) + M * (-v / s) + (v * w - y * x) / s, M = l) : (_ = (a = wi(e)).x + (~b[0].indexOf("%") ? _ / 100 * a.width : _), M = a.y + (~(b[1] || b[0]).indexOf("%") ? M / 100 * a.height : M)), i || !1 !== i && c.smooth ? (x = _ - h, w = M - d, c.xOffset = p + (x * m + w * v) - x, c.yOffset = f + (x * g + w * y) - w) : c.xOffset = c.yOffset = 0, c.xOrigin = _, c.yOrigin = M, c.smooth = !!i, c.origin = t, c.originIsAbsolute = !!n, e.style[di] = "0px 0px", o && (Mi(o, c, "xOrigin", h, _), Mi(o, c, "yOrigin", d, M), Mi(o, c, "xOffset", p, c.xOffset), Mi(o, c, "yOffset", f, c.yOffset)), e.setAttribute("data-svg-origin", _ + " " + M)
            },
            zi = function (e, t) {
                var n = e._gsap || new nn(e);
                if ("x" in n && !t && !n.uncache) return n;
                var i, r, o, a, s, l, c, u, h, d, p, f, m, g, v, y, x, w, b, _, M, T, S, E, A, C, L, P, R, O, D, k, N = e.style,
                    I = n.scaleX < 0,
                    z = "px",
                    F = "deg",
                    H = fi(e, di) || "0";
                return i = r = o = l = c = u = h = d = p = 0, a = s = 1, n.svg = !(!e.getCTM || !bi(e)), g = Ni(e, n.svg), n.svg && (E = !n.uncache && !t && e.getAttribute("data-svg-origin"), Ii(e, E || H, !!E || n.originIsAbsolute, !1 !== n.smooth, g)), f = n.xOrigin || 0, m = n.yOrigin || 0, g !== Ri && (w = g[0], b = g[1], _ = g[2], M = g[3], i = T = g[4], r = S = g[5], 6 === g.length ? (a = Math.sqrt(w * w + b * b), s = Math.sqrt(M * M + _ * _), l = w || b ? Xn(b, w) * qn : 0, (h = _ || M ? Xn(_, M) * qn + l : 0) && (s *= Math.abs(Math.cos(h * $n))), n.svg && (i -= f - (f * w + m * _), r -= m - (f * b + m * M))) : (k = g[6], O = g[7], L = g[8], P = g[9], R = g[10], D = g[11], i = g[12], r = g[13], o = g[14], c = (v = Xn(k, R)) * qn, v && (E = T * (y = Math.cos(-v)) + L * (x = Math.sin(-v)), A = S * y + P * x, C = k * y + R * x, L = T * -x + L * y, P = S * -x + P * y, R = k * -x + R * y, D = O * -x + D * y, T = E, S = A, k = C), u = (v = Xn(-_, R)) * qn, v && (y = Math.cos(-v), D = M * (x = Math.sin(-v)) + D * y, w = E = w * y - L * x, b = A = b * y - P * x, _ = C = _ * y - R * x), l = (v = Xn(b, w)) * qn, v && (E = w * (y = Math.cos(v)) + b * (x = Math.sin(v)), A = T * y + S * x, b = b * y - w * x, S = S * y - T * x, w = E, T = A), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, u = 180 - u), a = ze(Math.sqrt(w * w + b * b + _ * _)), s = ze(Math.sqrt(S * S + k * k)), v = Xn(T, S), h = Math.abs(v) > 2e-4 ? v * qn : 0, p = D ? 1 / (D < 0 ? -D : D) : 0), n.svg && (E = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !Di(fi(e, hi)), E && e.setAttribute("transform", E))), Math.abs(h) > 90 && Math.abs(h) < 270 && (I ? (a *= -1, h += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (s *= -1, h += h <= 0 ? 180 : -180)), n.x = i - ((n.xPercent = i && (n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + z, n.y = r - ((n.yPercent = r && (n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + z, n.z = o + z, n.scaleX = ze(a), n.scaleY = ze(s), n.rotation = ze(l) + F, n.rotationX = ze(c) + F, n.rotationY = ze(u) + F, n.skewX = h + F, n.skewY = d + F, n.transformPerspective = p + z, (n.zOrigin = parseFloat(H.split(" ")[2]) || 0) && (N[di] = Fi(H)), n.xOffset = n.yOffset = 0, n.force3D = W.force3D, n.renderTransform = n.svg ? Wi : Hn ? Vi : Bi, n.uncache = 0, n
            },
            Fi = function (e) {
                return (e = e.split(" "))[0] + " " + e[1]
            },
            Hi = function (e, t, n) {
                var i = vt(t);
                return ze(parseFloat(t) + parseFloat(Si(e, "x", n + "px", i))) + i
            },
            Bi = function (e, t) {
                t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, Vi(e, t)
            },
            Ui = "0deg",
            ji = "0px",
            Gi = ") ",
            Vi = function (e, t) {
                var n = t || this,
                    i = n.xPercent,
                    r = n.yPercent,
                    o = n.x,
                    a = n.y,
                    s = n.z,
                    l = n.rotation,
                    c = n.rotationY,
                    u = n.rotationX,
                    h = n.skewX,
                    d = n.skewY,
                    p = n.scaleX,
                    f = n.scaleY,
                    m = n.transformPerspective,
                    g = n.force3D,
                    v = n.target,
                    y = n.zOrigin,
                    x = "",
                    w = "auto" === g && e && 1 !== e || !0 === g;
                if (y && (u !== Ui || c !== Ui)) {
                    var b, _ = parseFloat(c) * $n,
                        M = Math.sin(_),
                        T = Math.cos(_);
                    _ = parseFloat(u) * $n, b = Math.cos(_), o = Hi(v, o, M * b * -y), a = Hi(v, a, -Math.sin(_) * -y), s = Hi(v, s, T * b * -y + y)
                }
                m !== ji && (x += "perspective(" + m + Gi), (i || r) && (x += "translate(" + i + "%, " + r + "%) "), (w || o !== ji || a !== ji || s !== ji) && (x += s !== ji || w ? "translate3d(" + o + ", " + a + ", " + s + ") " : "translate(" + o + ", " + a + Gi), l !== Ui && (x += "rotate(" + l + Gi), c !== Ui && (x += "rotateY(" + c + Gi), u !== Ui && (x += "rotateX(" + u + Gi), h === Ui && d === Ui || (x += "skew(" + h + ", " + d + Gi), 1 === p && 1 === f || (x += "scale(" + p + ", " + f + Gi), v.style[hi] = x || "translate(0, 0)"
            },
            Wi = function (e, t) {
                var n, i, r, o, a, s = t || this,
                    l = s.xPercent,
                    c = s.yPercent,
                    u = s.x,
                    h = s.y,
                    d = s.rotation,
                    p = s.skewX,
                    f = s.skewY,
                    m = s.scaleX,
                    g = s.scaleY,
                    v = s.target,
                    y = s.xOrigin,
                    x = s.yOrigin,
                    w = s.xOffset,
                    b = s.yOffset,
                    _ = s.forceCSS,
                    M = parseFloat(u),
                    T = parseFloat(h);
                d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= $n, p *= $n, n = Math.cos(d) * m, i = Math.sin(d) * m, r = Math.sin(d - p) * -g, o = Math.cos(d - p) * g, p && (f *= $n, a = Math.tan(p - f), r *= a = Math.sqrt(1 + a * a), o *= a, f && (a = Math.tan(f), n *= a = Math.sqrt(1 + a * a), i *= a)), n = ze(n), i = ze(i), r = ze(r), o = ze(o)) : (n = m, o = g, i = r = 0), (M && !~(u + "").indexOf("px") || T && !~(h + "").indexOf("px")) && (M = Si(v, "x", u, "px"), T = Si(v, "y", h, "px")), (y || x || w || b) && (M = ze(M + y - (y * n + x * r) + w), T = ze(T + x - (y * i + x * o) + b)), (l || c) && (a = v.getBBox(), M = ze(M + l / 100 * a.width), T = ze(T + c / 100 * a.height)), a = "matrix(" + n + "," + i + "," + r + "," + o + "," + M + "," + T + ")", v.setAttribute("transform", a), _ && (v.style[hi] = a)
            },
            qi = function (e, t, n, i, r, o) {
                var a, s, l = 360,
                    c = te(r),
                    u = parseFloat(r) * (c && ~r.indexOf("rad") ? qn : 1),
                    h = o ? u * o : u - i,
                    d = i + h + "deg";
                return c && ("short" === (a = r.split("_")[1]) && (h %= l) !== h % 180 && (h += h < 0 ? l : -360), "cw" === a && h < 0 ? h = (h + 36e9) % l - ~~(h / l) * l : "ccw" === a && h > 0 && (h = (h - 36e9) % l - ~~(h / l) * l)), e._pt = s = new Cn(e._pt, t, n, i, h, ei), s.e = d, s.u = "deg", e._props.push(n), s
            },
            $i = function (e, t) {
                for (var n in t) e[n] = t[n];
                return e
            },
            Xi = function (e, t, n) {
                var i, r, o, a, s, l, c, u = $i({}, n._gsap),
                    h = n.style;
                for (r in u.svg ? (o = n.getAttribute("transform"), n.setAttribute("transform", ""), h[hi] = t, i = zi(n, 1), _i(n, hi), n.setAttribute("transform", o)) : (o = getComputedStyle(n)[hi], h[hi] = t, i = zi(n, 1), h[hi] = o), Wn) (o = u[r]) !== (a = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (s = vt(o) !== (c = vt(a)) ? Si(n, r, o, c) : parseFloat(o), l = parseFloat(a), e._pt = new Cn(e._pt, i, r, s, l - s, Kn), e._pt.u = c || 0, e._props.push(r));
                $i(i, u)
            };
        Ie("padding,margin,Width,Radius", (function (e, t) {
            var n = "Top",
                i = "Right",
                r = "Bottom",
                o = "Left",
                a = (t < 3 ? [n, i, r, o] : [n + o, n + i, r + i, r + o]).map((function (n) {
                    return t < 2 ? e + n : "border" + n + e
                }));
            Pi[t > 1 ? "border" + e : e] = function (e, t, n, i, r) {
                var o, s;
                if (arguments.length < 4) return o = a.map((function (t) {
                    return Ei(e, t, n)
                })), 5 === (s = o.join(" ")).split(o[0]).length ? o[0] : s;
                o = (i + "").split(" "), s = {}, a.forEach((function (e, t) {
                    return s[e] = o[t] = o[t] || o[(t - 1) / 2 | 0]
                })), e.init(t, s, r)
            }
        }));
        var Yi, Zi, Ji, Qi = {
            name: "css",
            register: vi,
            targetTest: function (e) {
                return e.style && e.nodeType
            },
            init: function (e, t, n, i, r) {
                var o, a, s, l, c, u, h, d, p, f, m, g, v, y, x, w, b, _, M, T = this._props,
                    S = e.style,
                    E = n.vars.startAt;
                for (h in In || vi(), t)
                    if ("autoRound" !== h && (a = t[h], !Ce[h] || !cn(h, t, n, i, e, r)))
                        if (c = typeof a, u = Pi[h], "function" === c && (c = typeof (a = a.call(n, i, e, r))), "string" === c && ~a.indexOf("random(") && (a = Ct(a)), u) u(this, e, h, a, n) && (x = 1);
                        else if ("--" === h.substr(0, 2)) o = (getComputedStyle(e).getPropertyValue(h) + "").trim(), a += "", Bt.lastIndex = 0, Bt.test(o) || (d = vt(o), p = vt(a)), p ? d !== p && (o = Si(e, h, o, p) + p) : d && (a += d), this.add(S, "setProperty", o, a, i, r, 0, 0, h);
                        else if ("undefined" !== c) {
                            if (E && h in E ? (o = "function" == typeof E[h] ? E[h].call(n, i, e, r) : E[h], h in W.units && !vt(o) && (o += W.units[h]), "=" === (o + "").charAt(1) && (o = Ei(e, h))) : o = Ei(e, h), l = parseFloat(o), (f = "string" === c && "=" === a.charAt(1) ? +(a.charAt(0) + "1") : 0) && (a = a.substr(2)), s = parseFloat(a), h in Qn && ("autoAlpha" === h && (1 === l && "hidden" === Ei(e, "visibility") && s && (l = 0), Mi(this, S, "visibility", l ? "inherit" : "hidden", s ? "inherit" : "hidden", !s)), "scale" !== h && "transform" !== h && ~(h = Qn[h]).indexOf(",") && (h = h.split(",")[0])), m = h in Wn)
                                if (g || ((v = e._gsap).renderTransform && !t.parseTransform || zi(e, t.parseTransform), y = !1 !== t.smoothOrigin && v.smooth, (g = this._pt = new Cn(this._pt, S, hi, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === h) this._pt = new Cn(this._pt, v, "scaleY", v.scaleY, f ? f * s : s - v.scaleY), T.push("scaleY", h), h += "X";
                                else {
                                    if ("transformOrigin" === h) {
                                        b = void 0, _ = void 0, M = void 0, b = (w = a).split(" "), _ = b[0], M = b[1] || "50%", "top" !== _ && "bottom" !== _ && "left" !== M && "right" !== M || (w = _, _ = M, M = w), b[0] = Ci[_] || _, b[1] = Ci[M] || M, a = b.join(" "), v.svg ? Ii(e, a, 0, y, 0, this) : ((p = parseFloat(a.split(" ")[2]) || 0) !== v.zOrigin && Mi(this, v, "zOrigin", v.zOrigin, p), Mi(this, S, h, Fi(o), Fi(a)));
                                        continue
                                    }
                                    if ("svgOrigin" === h) {
                                        Ii(e, a, 1, y, 0, this);
                                        continue
                                    }
                                    if (h in Oi) {
                                        qi(this, v, h, l, a, f);
                                        continue
                                    }
                                    if ("smoothOrigin" === h) {
                                        Mi(this, v, "smooth", v.smooth, a);
                                        continue
                                    }
                                    if ("force3D" === h) {
                                        v[h] = a;
                                        continue
                                    }
                                    if ("transform" === h) {
                                        Xi(this, a, e);
                                        continue
                                    }
                                }
                            else h in S || (h = gi(h) || h);
                            if (m || (s || 0 === s) && (l || 0 === l) && !Jn.test(a) && h in S) s || (s = 0), (d = (o + "").substr((l + "").length)) !== (p = vt(a) || (h in W.units ? W.units[h] : d)) && (l = Si(e, h, o, p)), this._pt = new Cn(this._pt, m ? v : S, h, l, f ? f * s : s - l, m || "px" !== p && "zIndex" !== h || !1 === t.autoRound ? Kn : ni), this._pt.u = p || 0, d !== p && (this._pt.b = o, this._pt.r = ti);
                            else if (h in S) Ai.call(this, e, h, o, a);
                            else {
                                if (!(h in e)) {
                                    be(h, a);
                                    continue
                                }
                                this.add(e, h, e[h], a, i, r)
                            }
                            T.push(h)
                        }
                x && An(this)
            },
            get: Ei,
            aliases: Qn,
            getSetter: function (e, t, n) {
                var i = Qn[t];
                return i && i.indexOf(",") < 0 && (t = i), t in Wn && t !== di && (e._gsap.x || Ei(e, "x")) ? n && Fn === n ? "scale" === t ? li : si : (Fn = n || {}) && ("scale" === t ? ci : ui) : e.style && !re(e.style[t]) ? oi : ~t.indexOf("-") ? ai : xn(e, t)
            },
            core: {
                _removeProperty: _i,
                _getMatrix: Ni
            }
        };
        On.utils.checkPrefix = gi, Ji = Ie((Yi = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (Zi = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (e) {
            Wn[e] = 1
        })), Ie(Zi, (function (e) {
            W.units[e] = "deg", Oi[e] = 1
        })), Qn[Ji[13]] = Yi + "," + Zi, Ie("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (e) {
            var t = e.split(":");
            Qn[t[1]] = Ji[t[0]]
        })), Ie("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (e) {
            W.units[e] = "px"
        })), On.registerPlugin(Qi);
        var Ki = On.registerPlugin(Qi) || On,
            er = Ki.core.Tween,
            tr = n(4),
            nr = n(2);
        Object(tr.ScrollMagicPluginGsap)(f, er, on), Ki.registerPlugin(nr.ScrollToPlugin), r()(".svg").each((function () {
            var e = r()(this);
            if (e.hasClass("svg-inline")) return !0;
            var t = e.css("background-image").replace("url(", "").replace(")", "").replace(/\"/g, "");
            t && "none" != t && r.a.get(t, (function (t) {
                e.html(r()(t).find("svg")).addClass("svg-inline").trigger("svg-ready")
            }))
        })), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (e) {
            return "number" == typeof e && isFinite(e) && Math.floor(e) === e
        }), void 0 === Math.sign && (Math.sign = function (e) {
            return e < 0 ? -1 : e > 0 ? 1 : +e
        }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
            get: function () {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
            }
        }), void 0 === Object.assign && (Object.assign = function (e) {
            if (null == e) throw new TypeError("Cannot convert undefined or null to object");
            for (var t = Object(e), n = 1; n < arguments.length; n++) {
                var i = arguments[n];
                if (null != i)
                    for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r])
            }
            return t
        });
        var ir = 100,
            rr = 204,
            or = 205,
            ar = 306,
            sr = 1e3,
            lr = 1001,
            cr = 1002,
            ur = 1003,
            hr = 1004,
            dr = 1005,
            pr = 1006,
            fr = 1008,
            mr = 1009,
            gr = 1012,
            vr = 1014,
            yr = 1015,
            xr = 1016,
            wr = 1020,
            br = 1022,
            _r = 1023,
            Mr = 1026,
            Tr = 1027,
            Sr = 2300,
            Er = 2301,
            Ar = 2302,
            Cr = 2400,
            Lr = 2401,
            Pr = 2402,
            Rr = 3e3,
            Or = 3001,
            Dr = 3002,
            kr = 7680,
            Nr = 35044,
            Ir = 35048;

        function zr() { }
        Object.assign(zr.prototype, {
            addEventListener: function (e, t) {
                void 0 === this._listeners && (this._listeners = {});
                var n = this._listeners;
                void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
            },
            hasEventListener: function (e, t) {
                if (void 0 === this._listeners) return !1;
                var n = this._listeners;
                return void 0 !== n[e] && -1 !== n[e].indexOf(t)
            },
            removeEventListener: function (e, t) {
                if (void 0 !== this._listeners) {
                    var n = this._listeners[e];
                    if (void 0 !== n) {
                        var i = n.indexOf(t); - 1 !== i && n.splice(i, 1)
                    }
                }
            },
            dispatchEvent: function (e) {
                if (void 0 !== this._listeners) {
                    var t = this._listeners[e.type];
                    if (void 0 !== t) {
                        e.target = this;
                        for (var n = t.slice(0), i = 0, r = n.length; i < r; i++) n[i].call(this, e)
                    }
                }
            }
        });
        for (var Fr = [], Hr = 0; Hr < 256; Hr++) Fr[Hr] = (Hr < 16 ? "0" : "") + Hr.toString(16);
        var Br, Ur = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function () {
                var e = 4294967295 * Math.random() | 0,
                    t = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    i = 4294967295 * Math.random() | 0;
                return (Fr[255 & e] + Fr[e >> 8 & 255] + Fr[e >> 16 & 255] + Fr[e >> 24 & 255] + "-" + Fr[255 & t] + Fr[t >> 8 & 255] + "-" + Fr[t >> 16 & 15 | 64] + Fr[t >> 24 & 255] + "-" + Fr[63 & n | 128] + Fr[n >> 8 & 255] + "-" + Fr[n >> 16 & 255] + Fr[n >> 24 & 255] + Fr[255 & i] + Fr[i >> 8 & 255] + Fr[i >> 16 & 255] + Fr[i >> 24 & 255]).toUpperCase()
            },
            clamp: function (e, t, n) {
                return Math.max(t, Math.min(n, e))
            },
            euclideanModulo: function (e, t) {
                return (e % t + t) % t
            },
            mapLinear: function (e, t, n, i, r) {
                return i + (e - t) * (r - i) / (n - t)
            },
            lerp: function (e, t, n) {
                return (1 - n) * e + n * t
            },
            smoothstep: function (e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
            },
            smootherstep: function (e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
            },
            randInt: function (e, t) {
                return e + Math.floor(Math.random() * (t - e + 1))
            },
            randFloat: function (e, t) {
                return e + Math.random() * (t - e)
            },
            randFloatSpread: function (e) {
                return e * (.5 - Math.random())
            },
            degToRad: function (e) {
                return e * Ur.DEG2RAD
            },
            radToDeg: function (e) {
                return e * Ur.RAD2DEG
            },
            isPowerOfTwo: function (e) {
                return 0 == (e & e - 1) && 0 !== e
            },
            ceilPowerOfTwo: function (e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            },
            floorPowerOfTwo: function (e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            },
            setQuaternionFromProperEuler: function (e, t, n, i, r) {
                var o = Math.cos,
                    a = Math.sin,
                    s = o(n / 2),
                    l = a(n / 2),
                    c = o((t + i) / 2),
                    u = a((t + i) / 2),
                    h = o((t - i) / 2),
                    d = a((t - i) / 2),
                    p = o((i - t) / 2),
                    f = a((i - t) / 2);
                "XYX" === r ? e.set(s * u, l * h, l * d, s * c) : "YZY" === r ? e.set(l * d, s * u, l * h, s * c) : "ZXZ" === r ? e.set(l * h, l * d, s * u, s * c) : "XZX" === r ? e.set(s * u, l * f, l * p, s * c) : "YXY" === r ? e.set(l * p, s * u, l * f, s * c) : "ZYZ" === r ? e.set(l * f, l * p, s * u, s * c) : console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.")
            }
        };

        function jr(e, t) {
            this.x = e || 0, this.y = t || 0
        }

        function Gr() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }
        Object.defineProperties(jr.prototype, {
            width: {
                get: function () {
                    return this.x
                },
                set: function (e) {
                    this.x = e
                }
            },
            height: {
                get: function () {
                    return this.y
                },
                set: function (e) {
                    this.y = e
                }
            }
        }), Object.assign(jr.prototype, {
            isVector2: !0,
            set: function (e, t) {
                return this.x = e, this.y = t, this
            },
            setScalar: function (e) {
                return this.x = e, this.y = e, this
            },
            setX: function (e) {
                return this.x = e, this
            },
            setY: function (e) {
                return this.y = e, this
            },
            setComponent: function (e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            },
            getComponent: function (e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            },
            clone: function () {
                return new this.constructor(this.x, this.y)
            },
            copy: function (e) {
                return this.x = e.x, this.y = e.y, this
            },
            add: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
            },
            addScalar: function (e) {
                return this.x += e, this.y += e, this
            },
            addVectors: function (e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this
            },
            addScaledVector: function (e, t) {
                return this.x += e.x * t, this.y += e.y * t, this
            },
            sub: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
            },
            subScalar: function (e) {
                return this.x -= e, this.y -= e, this
            },
            subVectors: function (e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this
            },
            multiply: function (e) {
                return this.x *= e.x, this.y *= e.y, this
            },
            multiplyScalar: function (e) {
                return this.x *= e, this.y *= e, this
            },
            divide: function (e) {
                return this.x /= e.x, this.y /= e.y, this
            },
            divideScalar: function (e) {
                return this.multiplyScalar(1 / e)
            },
            applyMatrix3: function (e) {
                var t = this.x,
                    n = this.y,
                    i = e.elements;
                return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
            },
            min: function (e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
            },
            max: function (e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
            },
            clamp: function (e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
            },
            clampScalar: function (e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
            },
            clampLength: function (e, t) {
                var n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            },
            floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            },
            ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            },
            round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            },
            roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            },
            negate: function () {
                return this.x = -this.x, this.y = -this.y, this
            },
            dot: function (e) {
                return this.x * e.x + this.y * e.y
            },
            cross: function (e) {
                return this.x * e.y - this.y * e.x
            },
            lengthSq: function () {
                return this.x * this.x + this.y * this.y
            },
            length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y)
            },
            normalize: function () {
                return this.divideScalar(this.length() || 1)
            },
            angle: function () {
                return Math.atan2(-this.y, -this.x) + Math.PI
            },
            distanceTo: function (e) {
                return Math.sqrt(this.distanceToSquared(e))
            },
            distanceToSquared: function (e) {
                var t = this.x - e.x,
                    n = this.y - e.y;
                return t * t + n * n
            },
            manhattanDistanceTo: function (e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
            },
            setLength: function (e) {
                return this.normalize().multiplyScalar(e)
            },
            lerp: function (e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
            },
            lerpVectors: function (e, t, n) {
                return this.subVectors(t, e).multiplyScalar(n).add(e)
            },
            equals: function (e) {
                return e.x === this.x && e.y === this.y
            },
            fromArray: function (e, t) {
                return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
            },
            toArray: function (e, t) {
                return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
            },
            fromBufferAttribute: function (e, t, n) {
                return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
            },
            rotateAround: function (e, t) {
                var n = Math.cos(t),
                    i = Math.sin(t),
                    r = this.x - e.x,
                    o = this.y - e.y;
                return this.x = r * n - o * i + e.x, this.y = r * i + o * n + e.y, this
            }
        }), Object.assign(Gr.prototype, {
            isMatrix3: !0,
            set: function (e, t, n, i, r, o, a, s, l) {
                var c = this.elements;
                return c[0] = e, c[1] = i, c[2] = a, c[3] = t, c[4] = r, c[5] = s, c[6] = n, c[7] = o, c[8] = l, this
            },
            identity: function () {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            },
            clone: function () {
                return (new this.constructor).fromArray(this.elements)
            },
            copy: function (e) {
                var t = this.elements,
                    n = e.elements;
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
            },
            extractBasis: function (e, t, n) {
                return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            },
            setFromMatrix4: function (e) {
                var t = e.elements;
                return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
            },
            multiply: function (e) {
                return this.multiplyMatrices(this, e)
            },
            premultiply: function (e) {
                return this.multiplyMatrices(e, this)
            },
            multiplyMatrices: function (e, t) {
                var n = e.elements,
                    i = t.elements,
                    r = this.elements,
                    o = n[0],
                    a = n[3],
                    s = n[6],
                    l = n[1],
                    c = n[4],
                    u = n[7],
                    h = n[2],
                    d = n[5],
                    p = n[8],
                    f = i[0],
                    m = i[3],
                    g = i[6],
                    v = i[1],
                    y = i[4],
                    x = i[7],
                    w = i[2],
                    b = i[5],
                    _ = i[8];
                return r[0] = o * f + a * v + s * w, r[3] = o * m + a * y + s * b, r[6] = o * g + a * x + s * _, r[1] = l * f + c * v + u * w, r[4] = l * m + c * y + u * b, r[7] = l * g + c * x + u * _, r[2] = h * f + d * v + p * w, r[5] = h * m + d * y + p * b, r[8] = h * g + d * x + p * _, this
            },
            multiplyScalar: function (e) {
                var t = this.elements;
                return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
            },
            determinant: function () {
                var e = this.elements,
                    t = e[0],
                    n = e[1],
                    i = e[2],
                    r = e[3],
                    o = e[4],
                    a = e[5],
                    s = e[6],
                    l = e[7],
                    c = e[8];
                return t * o * c - t * a * l - n * r * c + n * a * s + i * r * l - i * o * s
            },
            getInverse: function (e, t) {
                void 0 !== t && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
                var n = e.elements,
                    i = this.elements,
                    r = n[0],
                    o = n[1],
                    a = n[2],
                    s = n[3],
                    l = n[4],
                    c = n[5],
                    u = n[6],
                    h = n[7],
                    d = n[8],
                    p = d * l - c * h,
                    f = c * u - d * s,
                    m = h * s - l * u,
                    g = r * p + o * f + a * m;
                if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                var v = 1 / g;
                return i[0] = p * v, i[1] = (a * h - d * o) * v, i[2] = (c * o - a * l) * v, i[3] = f * v, i[4] = (d * r - a * u) * v, i[5] = (a * s - c * r) * v, i[6] = m * v, i[7] = (o * u - h * r) * v, i[8] = (l * r - o * s) * v, this
            },
            transpose: function () {
                var e, t = this.elements;
                return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
            },
            getNormalMatrix: function (e) {
                return this.setFromMatrix4(e).getInverse(this).transpose()
            },
            transposeIntoArray: function (e) {
                var t = this.elements;
                return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
            },
            setUvTransform: function (e, t, n, i, r, o, a) {
                var s = Math.cos(r),
                    l = Math.sin(r);
                this.set(n * s, n * l, -n * (s * o + l * a) + o + e, -i * l, i * s, -i * (-l * o + s * a) + a + t, 0, 0, 1)
            },
            scale: function (e, t) {
                var n = this.elements;
                return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
            },
            rotate: function (e) {
                var t = Math.cos(e),
                    n = Math.sin(e),
                    i = this.elements,
                    r = i[0],
                    o = i[3],
                    a = i[6],
                    s = i[1],
                    l = i[4],
                    c = i[7];
                return i[0] = t * r + n * s, i[3] = t * o + n * l, i[6] = t * a + n * c, i[1] = -n * r + t * s, i[4] = -n * o + t * l, i[7] = -n * a + t * c, this
            },
            translate: function (e, t) {
                var n = this.elements;
                return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
            },
            equals: function (e) {
                for (var t = this.elements, n = e.elements, i = 0; i < 9; i++)
                    if (t[i] !== n[i]) return !1;
                return !0
            },
            fromArray: function (e, t) {
                void 0 === t && (t = 0);
                for (var n = 0; n < 9; n++) this.elements[n] = e[n + t];
                return this
            },
            toArray: function (e, t) {
                void 0 === e && (e = []), void 0 === t && (t = 0);
                var n = this.elements;
                return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
            }
        });
        var Vr = {
            getDataURL: function (e) {
                var t;
                if ("undefined" == typeof HTMLCanvasElement) return e.src;
                if (e instanceof HTMLCanvasElement) t = e;
                else {
                    void 0 === Br && (Br = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Br.width = e.width, Br.height = e.height;
                    var n = Br.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Br
                }
                return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
            }
        },
            Wr = 0;

        function qr(e, t, n, i, r, o, a, s, l, c) {
            Object.defineProperty(this, "id", {
                value: Wr++
            }), this.uuid = Ur.generateUUID(), this.name = "", this.image = void 0 !== e ? e : qr.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : qr.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : lr, this.wrapT = void 0 !== i ? i : lr, this.magFilter = void 0 !== r ? r : pr, this.minFilter = void 0 !== o ? o : fr, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== a ? a : _r, this.internalFormat = null, this.type = void 0 !== s ? s : mr, this.offset = new jr(0, 0), this.repeat = new jr(1, 1), this.center = new jr(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Gr, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== c ? c : Rr, this.version = 0, this.onUpdate = null
        }

        function $r(e, t, n, i) {
            this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1
        }

        function Xr(e, t, n) {
            this.width = e, this.height = t, this.scissor = new $r(0, 0, e, t), this.scissorTest = !1, this.viewport = new $r(0, 0, e, t), n = n || {}, this.texture = new qr(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = e, this.texture.image.height = t, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : pr, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
        }

        function Yr(e, t, n) {
            Xr.call(this, e, t, n), this.samples = 4
        }

        function Zr(e, t, n, i) {
            this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1
        }
        qr.DEFAULT_IMAGE = void 0, qr.DEFAULT_MAPPING = 300, qr.prototype = Object.assign(Object.create(zr.prototype), {
            constructor: qr,
            isTexture: !0,
            updateMatrix: function () {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
            },
            toJSON: function (e) {
                var t = void 0 === e || "string" == typeof e;
                if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                var n = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (void 0 !== this.image) {
                    var i = this.image;
                    if (void 0 === i.uuid && (i.uuid = Ur.generateUUID()), !t && void 0 === e.images[i.uuid]) {
                        var r;
                        if (Array.isArray(i)) {
                            r = [];
                            for (var o = 0, a = i.length; o < a; o++) r.push(Vr.getDataURL(i[o]))
                        } else r = Vr.getDataURL(i);
                        e.images[i.uuid] = {
                            uuid: i.uuid,
                            url: r
                        }
                    }
                    n.image = i.uuid
                }
                return t || (e.textures[this.uuid] = n), n
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            },
            transformUv: function (e) {
                if (300 !== this.mapping) return e;
                if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                    case sr:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case lr:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case cr:
                        1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                }
                if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                    case sr:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case lr:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case cr:
                        1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                }
                return this.flipY && (e.y = 1 - e.y), e
            }
        }), Object.defineProperty(qr.prototype, "needsUpdate", {
            set: function (e) {
                !0 === e && this.version++
            }
        }), Object.defineProperties($r.prototype, {
            width: {
                get: function () {
                    return this.z
                },
                set: function (e) {
                    this.z = e
                }
            },
            height: {
                get: function () {
                    return this.w
                },
                set: function (e) {
                    this.w = e
                }
            }
        }), Object.assign($r.prototype, {
            isVector4: !0,
            set: function (e, t, n, i) {
                return this.x = e, this.y = t, this.z = n, this.w = i, this
            },
            setScalar: function (e) {
                return this.x = e, this.y = e, this.z = e, this.w = e, this
            },
            setX: function (e) {
                return this.x = e, this
            },
            setY: function (e) {
                return this.y = e, this
            },
            setZ: function (e) {
                return this.z = e, this
            },
            setW: function (e) {
                return this.w = e, this
            },
            setComponent: function (e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    case 3:
                        this.w = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            },
            getComponent: function (e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            },
            clone: function () {
                return new this.constructor(this.x, this.y, this.z, this.w)
            },
            copy: function (e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
            },
            add: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
            },
            addScalar: function (e) {
                return this.x += e, this.y += e, this.z += e, this.w += e, this
            },
            addVectors: function (e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
            },
            addScaledVector: function (e, t) {
                return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
            },
            sub: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
            },
            subScalar: function (e) {
                return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
            },
            subVectors: function (e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
            },
            multiplyScalar: function (e) {
                return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
            },
            applyMatrix4: function (e) {
                var t = this.x,
                    n = this.y,
                    i = this.z,
                    r = this.w,
                    o = e.elements;
                return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r, this
            },
            divideScalar: function (e) {
                return this.multiplyScalar(1 / e)
            },
            setAxisAngleFromQuaternion: function (e) {
                this.w = 2 * Math.acos(e.w);
                var t = Math.sqrt(1 - e.w * e.w);
                return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
            },
            setAxisAngleFromRotationMatrix: function (e) {
                var t, n, i, r, o = .01,
                    a = .1,
                    s = e.elements,
                    l = s[0],
                    c = s[4],
                    u = s[8],
                    h = s[1],
                    d = s[5],
                    p = s[9],
                    f = s[2],
                    m = s[6],
                    g = s[10];
                if (Math.abs(c - h) < o && Math.abs(u - f) < o && Math.abs(p - m) < o) {
                    if (Math.abs(c + h) < a && Math.abs(u + f) < a && Math.abs(p + m) < a && Math.abs(l + d + g - 3) < a) return this.set(1, 0, 0, 0), this;
                    t = Math.PI;
                    var v = (l + 1) / 2,
                        y = (d + 1) / 2,
                        x = (g + 1) / 2,
                        w = (c + h) / 4,
                        b = (u + f) / 4,
                        _ = (p + m) / 4;
                    return v > y && v > x ? v < o ? (n = 0, i = .707106781, r = .707106781) : (i = w / (n = Math.sqrt(v)), r = b / n) : y > x ? y < o ? (n = .707106781, i = 0, r = .707106781) : (n = w / (i = Math.sqrt(y)), r = _ / i) : x < o ? (n = .707106781, i = .707106781, r = 0) : (n = b / (r = Math.sqrt(x)), i = _ / r), this.set(n, i, r, t), this
                }
                var M = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
                return Math.abs(M) < .001 && (M = 1), this.x = (m - p) / M, this.y = (u - f) / M, this.z = (h - c) / M, this.w = Math.acos((l + d + g - 1) / 2), this
            },
            min: function (e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
            },
            max: function (e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
            },
            clamp: function (e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
            },
            clampScalar: function (e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
            },
            clampLength: function (e, t) {
                var n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            },
            floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            },
            ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            },
            round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            },
            roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            },
            negate: function () {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            },
            dot: function (e) {
                return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
            },
            lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            },
            length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            },
            manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            },
            normalize: function () {
                return this.divideScalar(this.length() || 1)
            },
            setLength: function (e) {
                return this.normalize().multiplyScalar(e)
            },
            lerp: function (e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
            },
            lerpVectors: function (e, t, n) {
                return this.subVectors(t, e).multiplyScalar(n).add(e)
            },
            equals: function (e) {
                return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
            },
            fromArray: function (e, t) {
                return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
            },
            toArray: function (e, t) {
                return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
            },
            fromBufferAttribute: function (e, t, n) {
                return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
            }
        }), Xr.prototype = Object.assign(Object.create(zr.prototype), {
            constructor: Xr,
            isWebGLRenderTarget: !0,
            setSize: function (e, t) {
                this.width === e && this.height === t || (this.width = e, this.height = t, this.texture.image.width = e, this.texture.image.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), Yr.prototype = Object.assign(Object.create(Xr.prototype), {
            constructor: Yr,
            isWebGLMultisampleRenderTarget: !0,
            copy: function (e) {
                return Xr.prototype.copy.call(this, e), this.samples = e.samples, this
            }
        }), Object.assign(Zr, {
            slerp: function (e, t, n, i) {
                return n.copy(e).slerp(t, i)
            },
            slerpFlat: function (e, t, n, i, r, o, a) {
                var s = n[i + 0],
                    l = n[i + 1],
                    c = n[i + 2],
                    u = n[i + 3],
                    h = r[o + 0],
                    d = r[o + 1],
                    p = r[o + 2],
                    f = r[o + 3];
                if (u !== f || s !== h || l !== d || c !== p) {
                    var m = 1 - a,
                        g = s * h + l * d + c * p + u * f,
                        v = g >= 0 ? 1 : -1,
                        y = 1 - g * g;
                    if (y > Number.EPSILON) {
                        var x = Math.sqrt(y),
                            w = Math.atan2(x, g * v);
                        m = Math.sin(m * w) / x, a = Math.sin(a * w) / x
                    }
                    var b = a * v;
                    if (s = s * m + h * b, l = l * m + d * b, c = c * m + p * b, u = u * m + f * b, m === 1 - a) {
                        var _ = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
                        s *= _, l *= _, c *= _, u *= _
                    }
                }
                e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u
            }
        }), Object.defineProperties(Zr.prototype, {
            x: {
                get: function () {
                    return this._x
                },
                set: function (e) {
                    this._x = e, this._onChangeCallback()
                }
            },
            y: {
                get: function () {
                    return this._y
                },
                set: function (e) {
                    this._y = e, this._onChangeCallback()
                }
            },
            z: {
                get: function () {
                    return this._z
                },
                set: function (e) {
                    this._z = e, this._onChangeCallback()
                }
            },
            w: {
                get: function () {
                    return this._w
                },
                set: function (e) {
                    this._w = e, this._onChangeCallback()
                }
            }
        }), Object.assign(Zr.prototype, {
            isQuaternion: !0,
            set: function (e, t, n, i) {
                return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
            },
            clone: function () {
                return new this.constructor(this._x, this._y, this._z, this._w)
            },
            copy: function (e) {
                return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
            },
            setFromEuler: function (e, t) {
                if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                var n = e._x,
                    i = e._y,
                    r = e._z,
                    o = e.order,
                    a = Math.cos,
                    s = Math.sin,
                    l = a(n / 2),
                    c = a(i / 2),
                    u = a(r / 2),
                    h = s(n / 2),
                    d = s(i / 2),
                    p = s(r / 2);
                return "XYZ" === o ? (this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p) : "YXZ" === o ? (this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p) : "ZXY" === o ? (this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p) : "ZYX" === o ? (this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p) : "YZX" === o ? (this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p) : "XZY" === o && (this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p), !1 !== t && this._onChangeCallback(), this
            },
            setFromAxisAngle: function (e, t) {
                var n = t / 2,
                    i = Math.sin(n);
                return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
            },
            setFromRotationMatrix: function (e) {
                var t, n = e.elements,
                    i = n[0],
                    r = n[4],
                    o = n[8],
                    a = n[1],
                    s = n[5],
                    l = n[9],
                    c = n[2],
                    u = n[6],
                    h = n[10],
                    d = i + s + h;
                return d > 0 ? (t = .5 / Math.sqrt(d + 1), this._w = .25 / t, this._x = (u - l) * t, this._y = (o - c) * t, this._z = (a - r) * t) : i > s && i > h ? (t = 2 * Math.sqrt(1 + i - s - h), this._w = (u - l) / t, this._x = .25 * t, this._y = (r + a) / t, this._z = (o + c) / t) : s > h ? (t = 2 * Math.sqrt(1 + s - i - h), this._w = (o - c) / t, this._x = (r + a) / t, this._y = .25 * t, this._z = (l + u) / t) : (t = 2 * Math.sqrt(1 + h - i - s), this._w = (a - r) / t, this._x = (o + c) / t, this._y = (l + u) / t, this._z = .25 * t), this._onChangeCallback(), this
            },
            setFromUnitVectors: function (e, t) {
                var n = e.dot(t) + 1;
                return n < 1e-6 ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
            },
            angleTo: function (e) {
                return 2 * Math.acos(Math.abs(Ur.clamp(this.dot(e), -1, 1)))
            },
            rotateTowards: function (e, t) {
                var n = this.angleTo(e);
                if (0 === n) return this;
                var i = Math.min(1, t / n);
                return this.slerp(e, i), this
            },
            inverse: function () {
                return this.conjugate()
            },
            conjugate: function () {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            },
            dot: function (e) {
                return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
            },
            lengthSq: function () {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            },
            length: function () {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            },
            normalize: function () {
                var e = this.length();
                return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
            },
            multiply: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
            },
            premultiply: function (e) {
                return this.multiplyQuaternions(e, this)
            },
            multiplyQuaternions: function (e, t) {
                var n = e._x,
                    i = e._y,
                    r = e._z,
                    o = e._w,
                    a = t._x,
                    s = t._y,
                    l = t._z,
                    c = t._w;
                return this._x = n * c + o * a + i * l - r * s, this._y = i * c + o * s + r * a - n * l, this._z = r * c + o * l + n * s - i * a, this._w = o * c - n * a - i * s - r * l, this._onChangeCallback(), this
            },
            slerp: function (e, t) {
                if (0 === t) return this;
                if (1 === t) return this.copy(e);
                var n = this._x,
                    i = this._y,
                    r = this._z,
                    o = this._w,
                    a = o * e._w + n * e._x + i * e._y + r * e._z;
                if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this;
                var s = 1 - a * a;
                if (s <= Number.EPSILON) {
                    var l = 1 - t;
                    return this._w = l * o + t * this._w, this._x = l * n + t * this._x, this._y = l * i + t * this._y, this._z = l * r + t * this._z, this.normalize(), this._onChangeCallback(), this
                }
                var c = Math.sqrt(s),
                    u = Math.atan2(c, a),
                    h = Math.sin((1 - t) * u) / c,
                    d = Math.sin(t * u) / c;
                return this._w = o * h + this._w * d, this._x = n * h + this._x * d, this._y = i * h + this._y * d, this._z = r * h + this._z * d, this._onChangeCallback(), this
            },
            equals: function (e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
            },
            fromArray: function (e, t) {
                return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
            },
            toArray: function (e, t) {
                return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
            },
            fromBufferAttribute: function (e, t) {
                return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
            },
            _onChange: function (e) {
                return this._onChangeCallback = e, this
            },
            _onChangeCallback: function () { }
        });
        var Jr = new Kr,
            Qr = new Zr;

        function Kr(e, t, n) {
            this.x = e || 0, this.y = t || 0, this.z = n || 0
        }
        Object.assign(Kr.prototype, {
            isVector3: !0,
            set: function (e, t, n) {
                return this.x = e, this.y = t, this.z = n, this
            },
            setScalar: function (e) {
                return this.x = e, this.y = e, this.z = e, this
            },
            setX: function (e) {
                return this.x = e, this
            },
            setY: function (e) {
                return this.y = e, this
            },
            setZ: function (e) {
                return this.z = e, this
            },
            setComponent: function (e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            },
            getComponent: function (e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            },
            clone: function () {
                return new this.constructor(this.x, this.y, this.z)
            },
            copy: function (e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this
            },
            add: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
            },
            addScalar: function (e) {
                return this.x += e, this.y += e, this.z += e, this
            },
            addVectors: function (e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
            },
            addScaledVector: function (e, t) {
                return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
            },
            sub: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
            },
            subScalar: function (e) {
                return this.x -= e, this.y -= e, this.z -= e, this
            },
            subVectors: function (e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
            },
            multiply: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
            },
            multiplyScalar: function (e) {
                return this.x *= e, this.y *= e, this.z *= e, this
            },
            multiplyVectors: function (e, t) {
                return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
            },
            applyEuler: function (e) {
                return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Qr.setFromEuler(e))
            },
            applyAxisAngle: function (e, t) {
                return this.applyQuaternion(Qr.setFromAxisAngle(e, t))
            },
            applyMatrix3: function (e) {
                var t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements;
                return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
            },
            applyNormalMatrix: function (e) {
                return this.applyMatrix3(e).normalize()
            },
            applyMatrix4: function (e) {
                var t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements,
                    o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o, this
            },
            applyQuaternion: function (e) {
                var t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.x,
                    o = e.y,
                    a = e.z,
                    s = e.w,
                    l = s * t + o * i - a * n,
                    c = s * n + a * t - r * i,
                    u = s * i + r * n - o * t,
                    h = -r * t - o * n - a * i;
                return this.x = l * s + h * -r + c * -a - u * -o, this.y = c * s + h * -o + u * -r - l * -a, this.z = u * s + h * -a + l * -o - c * -r, this
            },
            project: function (e) {
                return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
            },
            unproject: function (e) {
                return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
            },
            transformDirection: function (e) {
                var t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements;
                return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize()
            },
            divide: function (e) {
                return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
            },
            divideScalar: function (e) {
                return this.multiplyScalar(1 / e)
            },
            min: function (e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
            },
            max: function (e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
            },
            clamp: function (e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
            },
            clampScalar: function (e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
            },
            clampLength: function (e, t) {
                var n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            },
            floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            },
            ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            },
            round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            },
            roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            },
            negate: function () {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            },
            dot: function (e) {
                return this.x * e.x + this.y * e.y + this.z * e.z
            },
            lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z
            },
            length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            },
            manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            },
            normalize: function () {
                return this.divideScalar(this.length() || 1)
            },
            setLength: function (e) {
                return this.normalize().multiplyScalar(e)
            },
            lerp: function (e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
            },
            lerpVectors: function (e, t, n) {
                return this.subVectors(t, e).multiplyScalar(n).add(e)
            },
            cross: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
            },
            crossVectors: function (e, t) {
                var n = e.x,
                    i = e.y,
                    r = e.z,
                    o = t.x,
                    a = t.y,
                    s = t.z;
                return this.x = i * s - r * a, this.y = r * o - n * s, this.z = n * a - i * o, this
            },
            projectOnVector: function (e) {
                var t = e.lengthSq();
                if (0 === t) return this.set(0, 0, 0);
                var n = e.dot(this) / t;
                return this.copy(e).multiplyScalar(n)
            },
            projectOnPlane: function (e) {
                return Jr.copy(this).projectOnVector(e), this.sub(Jr)
            },
            reflect: function (e) {
                return this.sub(Jr.copy(e).multiplyScalar(2 * this.dot(e)))
            },
            angleTo: function (e) {
                var t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t) return Math.PI / 2;
                var n = this.dot(e) / t;
                return Math.acos(Ur.clamp(n, -1, 1))
            },
            distanceTo: function (e) {
                return Math.sqrt(this.distanceToSquared(e))
            },
            distanceToSquared: function (e) {
                var t = this.x - e.x,
                    n = this.y - e.y,
                    i = this.z - e.z;
                return t * t + n * n + i * i
            },
            manhattanDistanceTo: function (e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
            },
            setFromSpherical: function (e) {
                return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
            },
            setFromSphericalCoords: function (e, t, n) {
                var i = Math.sin(t) * e;
                return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
            },
            setFromCylindrical: function (e) {
                return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
            },
            setFromCylindricalCoords: function (e, t, n) {
                return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
            },
            setFromMatrixPosition: function (e) {
                var t = e.elements;
                return this.x = t[12], this.y = t[13], this.z = t[14], this
            },
            setFromMatrixScale: function (e) {
                var t = this.setFromMatrixColumn(e, 0).length(),
                    n = this.setFromMatrixColumn(e, 1).length(),
                    i = this.setFromMatrixColumn(e, 2).length();
                return this.x = t, this.y = n, this.z = i, this
            },
            setFromMatrixColumn: function (e, t) {
                return this.fromArray(e.elements, 4 * t)
            },
            setFromMatrix3Column: function (e, t) {
                return this.fromArray(e.elements, 3 * t)
            },
            equals: function (e) {
                return e.x === this.x && e.y === this.y && e.z === this.z
            },
            fromArray: function (e, t) {
                return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
            },
            toArray: function (e, t) {
                return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
            },
            fromBufferAttribute: function (e, t, n) {
                return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
            }
        });
        var eo = new Kr,
            to = new so,
            no = new Kr(0, 0, 0),
            io = new Kr(1, 1, 1),
            ro = new Kr,
            oo = new Kr,
            ao = new Kr;

        function so() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }
        Object.assign(so.prototype, {
            isMatrix4: !0,
            set: function (e, t, n, i, r, o, a, s, l, c, u, h, d, p, f, m) {
                var g = this.elements;
                return g[0] = e, g[4] = t, g[8] = n, g[12] = i, g[1] = r, g[5] = o, g[9] = a, g[13] = s, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
            },
            identity: function () {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            clone: function () {
                return (new so).fromArray(this.elements)
            },
            copy: function (e) {
                var t = this.elements,
                    n = e.elements;
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
            },
            copyPosition: function (e) {
                var t = this.elements,
                    n = e.elements;
                return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
            },
            extractBasis: function (e, t, n) {
                return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            },
            makeBasis: function (e, t, n) {
                return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
            },
            extractRotation: function (e) {
                var t = this.elements,
                    n = e.elements,
                    i = 1 / eo.setFromMatrixColumn(e, 0).length(),
                    r = 1 / eo.setFromMatrixColumn(e, 1).length(),
                    o = 1 / eo.setFromMatrixColumn(e, 2).length();
                return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
            },
            makeRotationFromEuler: function (e) {
                e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var t = this.elements,
                    n = e.x,
                    i = e.y,
                    r = e.z,
                    o = Math.cos(n),
                    a = Math.sin(n),
                    s = Math.cos(i),
                    l = Math.sin(i),
                    c = Math.cos(r),
                    u = Math.sin(r);
                if ("XYZ" === e.order) {
                    var h = o * c,
                        d = o * u,
                        p = a * c,
                        f = a * u;
                    t[0] = s * c, t[4] = -s * u, t[8] = l, t[1] = d + p * l, t[5] = h - f * l, t[9] = -a * s, t[2] = f - h * l, t[6] = p + d * l, t[10] = o * s
                } else if ("YXZ" === e.order) {
                    var m = s * c,
                        g = s * u,
                        v = l * c,
                        y = l * u;
                    t[0] = m + y * a, t[4] = v * a - g, t[8] = o * l, t[1] = o * u, t[5] = o * c, t[9] = -a, t[2] = g * a - v, t[6] = y + m * a, t[10] = o * s
                } else if ("ZXY" === e.order) {
                    m = s * c, g = s * u, v = l * c, y = l * u;
                    t[0] = m - y * a, t[4] = -o * u, t[8] = v + g * a, t[1] = g + v * a, t[5] = o * c, t[9] = y - m * a, t[2] = -o * l, t[6] = a, t[10] = o * s
                } else if ("ZYX" === e.order) {
                    h = o * c, d = o * u, p = a * c, f = a * u;
                    t[0] = s * c, t[4] = p * l - d, t[8] = h * l + f, t[1] = s * u, t[5] = f * l + h, t[9] = d * l - p, t[2] = -l, t[6] = a * s, t[10] = o * s
                } else if ("YZX" === e.order) {
                    var x = o * s,
                        w = o * l,
                        b = a * s,
                        _ = a * l;
                    t[0] = s * c, t[4] = _ - x * u, t[8] = b * u + w, t[1] = u, t[5] = o * c, t[9] = -a * c, t[2] = -l * c, t[6] = w * u + b, t[10] = x - _ * u
                } else if ("XZY" === e.order) {
                    x = o * s, w = o * l, b = a * s, _ = a * l;
                    t[0] = s * c, t[4] = -u, t[8] = l * c, t[1] = x * u + _, t[5] = o * c, t[9] = w * u - b, t[2] = b * u - w, t[6] = a * c, t[10] = _ * u + x
                }
                return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
            },
            makeRotationFromQuaternion: function (e) {
                return this.compose(no, e, io)
            },
            lookAt: function (e, t, n) {
                var i = this.elements;
                return ao.subVectors(e, t), 0 === ao.lengthSq() && (ao.z = 1), ao.normalize(), ro.crossVectors(n, ao), 0 === ro.lengthSq() && (1 === Math.abs(n.z) ? ao.x += 1e-4 : ao.z += 1e-4, ao.normalize(), ro.crossVectors(n, ao)), ro.normalize(), oo.crossVectors(ao, ro), i[0] = ro.x, i[4] = oo.x, i[8] = ao.x, i[1] = ro.y, i[5] = oo.y, i[9] = ao.y, i[2] = ro.z, i[6] = oo.z, i[10] = ao.z, this
            },
            multiply: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
            },
            premultiply: function (e) {
                return this.multiplyMatrices(e, this)
            },
            multiplyMatrices: function (e, t) {
                var n = e.elements,
                    i = t.elements,
                    r = this.elements,
                    o = n[0],
                    a = n[4],
                    s = n[8],
                    l = n[12],
                    c = n[1],
                    u = n[5],
                    h = n[9],
                    d = n[13],
                    p = n[2],
                    f = n[6],
                    m = n[10],
                    g = n[14],
                    v = n[3],
                    y = n[7],
                    x = n[11],
                    w = n[15],
                    b = i[0],
                    _ = i[4],
                    M = i[8],
                    T = i[12],
                    S = i[1],
                    E = i[5],
                    A = i[9],
                    C = i[13],
                    L = i[2],
                    P = i[6],
                    R = i[10],
                    O = i[14],
                    D = i[3],
                    k = i[7],
                    N = i[11],
                    I = i[15];
                return r[0] = o * b + a * S + s * L + l * D, r[4] = o * _ + a * E + s * P + l * k, r[8] = o * M + a * A + s * R + l * N, r[12] = o * T + a * C + s * O + l * I, r[1] = c * b + u * S + h * L + d * D, r[5] = c * _ + u * E + h * P + d * k, r[9] = c * M + u * A + h * R + d * N, r[13] = c * T + u * C + h * O + d * I, r[2] = p * b + f * S + m * L + g * D, r[6] = p * _ + f * E + m * P + g * k, r[10] = p * M + f * A + m * R + g * N, r[14] = p * T + f * C + m * O + g * I, r[3] = v * b + y * S + x * L + w * D, r[7] = v * _ + y * E + x * P + w * k, r[11] = v * M + y * A + x * R + w * N, r[15] = v * T + y * C + x * O + w * I, this
            },
            multiplyScalar: function (e) {
                var t = this.elements;
                return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
            },
            determinant: function () {
                var e = this.elements,
                    t = e[0],
                    n = e[4],
                    i = e[8],
                    r = e[12],
                    o = e[1],
                    a = e[5],
                    s = e[9],
                    l = e[13],
                    c = e[2],
                    u = e[6],
                    h = e[10],
                    d = e[14];
                return e[3] * (+r * s * u - i * l * u - r * a * h + n * l * h + i * a * d - n * s * d) + e[7] * (+t * s * d - t * l * h + r * o * h - i * o * d + i * l * c - r * s * c) + e[11] * (+t * l * u - t * a * d - r * o * u + n * o * d + r * a * c - n * l * c) + e[15] * (-i * a * c - t * s * u + t * a * h + i * o * u - n * o * h + n * s * c)
            },
            transpose: function () {
                var e, t = this.elements;
                return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
            },
            setPosition: function (e, t, n) {
                var i = this.elements;
                return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
            },
            getInverse: function (e, t) {
                void 0 !== t && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
                var n = this.elements,
                    i = e.elements,
                    r = i[0],
                    o = i[1],
                    a = i[2],
                    s = i[3],
                    l = i[4],
                    c = i[5],
                    u = i[6],
                    h = i[7],
                    d = i[8],
                    p = i[9],
                    f = i[10],
                    m = i[11],
                    g = i[12],
                    v = i[13],
                    y = i[14],
                    x = i[15],
                    w = p * y * h - v * f * h + v * u * m - c * y * m - p * u * x + c * f * x,
                    b = g * f * h - d * y * h - g * u * m + l * y * m + d * u * x - l * f * x,
                    _ = d * v * h - g * p * h + g * c * m - l * v * m - d * c * x + l * p * x,
                    M = g * p * u - d * v * u - g * c * f + l * v * f + d * c * y - l * p * y,
                    T = r * w + o * b + a * _ + s * M;
                if (0 === T) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                var S = 1 / T;
                return n[0] = w * S, n[1] = (v * f * s - p * y * s - v * a * m + o * y * m + p * a * x - o * f * x) * S, n[2] = (c * y * s - v * u * s + v * a * h - o * y * h - c * a * x + o * u * x) * S, n[3] = (p * u * s - c * f * s - p * a * h + o * f * h + c * a * m - o * u * m) * S, n[4] = b * S, n[5] = (d * y * s - g * f * s + g * a * m - r * y * m - d * a * x + r * f * x) * S, n[6] = (g * u * s - l * y * s - g * a * h + r * y * h + l * a * x - r * u * x) * S, n[7] = (l * f * s - d * u * s + d * a * h - r * f * h - l * a * m + r * u * m) * S, n[8] = _ * S, n[9] = (g * p * s - d * v * s - g * o * m + r * v * m + d * o * x - r * p * x) * S, n[10] = (l * v * s - g * c * s + g * o * h - r * v * h - l * o * x + r * c * x) * S, n[11] = (d * c * s - l * p * s - d * o * h + r * p * h + l * o * m - r * c * m) * S, n[12] = M * S, n[13] = (d * v * a - g * p * a + g * o * f - r * v * f - d * o * y + r * p * y) * S, n[14] = (g * c * a - l * v * a - g * o * u + r * v * u + l * o * y - r * c * y) * S, n[15] = (l * p * a - d * c * a + d * o * u - r * p * u - l * o * f + r * c * f) * S, this
            },
            scale: function (e) {
                var t = this.elements,
                    n = e.x,
                    i = e.y,
                    r = e.z;
                return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
            },
            getMaxScaleOnAxis: function () {
                var e = this.elements,
                    t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                    n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                    i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                return Math.sqrt(Math.max(t, n, i))
            },
            makeTranslation: function (e, t, n) {
                return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
            },
            makeRotationX: function (e) {
                var t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
            },
            makeRotationY: function (e) {
                var t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
            },
            makeRotationZ: function (e) {
                var t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            makeRotationAxis: function (e, t) {
                var n = Math.cos(t),
                    i = Math.sin(t),
                    r = 1 - n,
                    o = e.x,
                    a = e.y,
                    s = e.z,
                    l = r * o,
                    c = r * a;
                return this.set(l * o + n, l * a - i * s, l * s + i * a, 0, l * a + i * s, c * a + n, c * s - i * o, 0, l * s - i * a, c * s + i * o, r * s * s + n, 0, 0, 0, 0, 1), this
            },
            makeScale: function (e, t, n) {
                return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            },
            makeShear: function (e, t, n) {
                return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this
            },
            compose: function (e, t, n) {
                var i = this.elements,
                    r = t._x,
                    o = t._y,
                    a = t._z,
                    s = t._w,
                    l = r + r,
                    c = o + o,
                    u = a + a,
                    h = r * l,
                    d = r * c,
                    p = r * u,
                    f = o * c,
                    m = o * u,
                    g = a * u,
                    v = s * l,
                    y = s * c,
                    x = s * u,
                    w = n.x,
                    b = n.y,
                    _ = n.z;
                return i[0] = (1 - (f + g)) * w, i[1] = (d + x) * w, i[2] = (p - y) * w, i[3] = 0, i[4] = (d - x) * b, i[5] = (1 - (h + g)) * b, i[6] = (m + v) * b, i[7] = 0, i[8] = (p + y) * _, i[9] = (m - v) * _, i[10] = (1 - (h + f)) * _, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
            },
            decompose: function (e, t, n) {
                var i = this.elements,
                    r = eo.set(i[0], i[1], i[2]).length(),
                    o = eo.set(i[4], i[5], i[6]).length(),
                    a = eo.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], to.copy(this);
                var s = 1 / r,
                    l = 1 / o,
                    c = 1 / a;
                return to.elements[0] *= s, to.elements[1] *= s, to.elements[2] *= s, to.elements[4] *= l, to.elements[5] *= l, to.elements[6] *= l, to.elements[8] *= c, to.elements[9] *= c, to.elements[10] *= c, t.setFromRotationMatrix(to), n.x = r, n.y = o, n.z = a, this
            },
            makePerspective: function (e, t, n, i, r, o) {
                void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                var a = this.elements,
                    s = 2 * r / (t - e),
                    l = 2 * r / (n - i),
                    c = (t + e) / (t - e),
                    u = (n + i) / (n - i),
                    h = -(o + r) / (o - r),
                    d = -2 * o * r / (o - r);
                return a[0] = s, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = l, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = h, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
            },
            makeOrthographic: function (e, t, n, i, r, o) {
                var a = this.elements,
                    s = 1 / (t - e),
                    l = 1 / (n - i),
                    c = 1 / (o - r),
                    u = (t + e) * s,
                    h = (n + i) * l,
                    d = (o + r) * c;
                return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -h, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
            },
            equals: function (e) {
                for (var t = this.elements, n = e.elements, i = 0; i < 16; i++)
                    if (t[i] !== n[i]) return !1;
                return !0
            },
            fromArray: function (e, t) {
                void 0 === t && (t = 0);
                for (var n = 0; n < 16; n++) this.elements[n] = e[n + t];
                return this
            },
            toArray: function (e, t) {
                void 0 === e && (e = []), void 0 === t && (t = 0);
                var n = this.elements;
                return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
            }
        });
        var lo = new so,
            co = new Zr;

        function uo(e, t, n, i) {
            this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = i || uo.DefaultOrder
        }

        function ho() {
            this.mask = 1
        }
        uo.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], uo.DefaultOrder = "XYZ", Object.defineProperties(uo.prototype, {
            x: {
                get: function () {
                    return this._x
                },
                set: function (e) {
                    this._x = e, this._onChangeCallback()
                }
            },
            y: {
                get: function () {
                    return this._y
                },
                set: function (e) {
                    this._y = e, this._onChangeCallback()
                }
            },
            z: {
                get: function () {
                    return this._z
                },
                set: function (e) {
                    this._z = e, this._onChangeCallback()
                }
            },
            order: {
                get: function () {
                    return this._order
                },
                set: function (e) {
                    this._order = e, this._onChangeCallback()
                }
            }
        }), Object.assign(uo.prototype, {
            isEuler: !0,
            set: function (e, t, n, i) {
                return this._x = e, this._y = t, this._z = n, this._order = i || this._order, this._onChangeCallback(), this
            },
            clone: function () {
                return new this.constructor(this._x, this._y, this._z, this._order)
            },
            copy: function (e) {
                return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
            },
            setFromRotationMatrix: function (e, t, n) {
                var i = Ur.clamp,
                    r = e.elements,
                    o = r[0],
                    a = r[4],
                    s = r[8],
                    l = r[1],
                    c = r[5],
                    u = r[9],
                    h = r[2],
                    d = r[6],
                    p = r[10];
                return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(i(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(d, c), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-i(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, o), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(i(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(l, o))) : "ZYX" === t ? (this._y = Math.asin(-i(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, o)) : (this._x = 0, this._z = Math.atan2(-a, c))) : "YZX" === t ? (this._z = Math.asin(i(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === t ? (this._z = Math.asin(-i(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-u, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== n && this._onChangeCallback(), this
            },
            setFromQuaternion: function (e, t, n) {
                return lo.makeRotationFromQuaternion(e), this.setFromRotationMatrix(lo, t, n)
            },
            setFromVector3: function (e, t) {
                return this.set(e.x, e.y, e.z, t || this._order)
            },
            reorder: function (e) {
                return co.setFromEuler(this), this.setFromQuaternion(co, e)
            },
            equals: function (e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
            },
            fromArray: function (e) {
                return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
            },
            toArray: function (e, t) {
                return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
            },
            toVector3: function (e) {
                return e ? e.set(this._x, this._y, this._z) : new Kr(this._x, this._y, this._z)
            },
            _onChange: function (e) {
                return this._onChangeCallback = e, this
            },
            _onChangeCallback: function () { }
        }), Object.assign(ho.prototype, {
            set: function (e) {
                this.mask = 1 << e | 0
            },
            enable: function (e) {
                this.mask |= 1 << e | 0
            },
            enableAll: function () {
                this.mask = -1
            },
            toggle: function (e) {
                this.mask ^= 1 << e | 0
            },
            disable: function (e) {
                this.mask &= ~(1 << e | 0)
            },
            disableAll: function () {
                this.mask = 0
            },
            test: function (e) {
                return 0 != (this.mask & e.mask)
            }
        });
        var po = 0,
            fo = new Kr,
            mo = new Zr,
            go = new so,
            vo = new Kr,
            yo = new Kr,
            xo = new Kr,
            wo = new Zr,
            bo = new Kr(1, 0, 0),
            _o = new Kr(0, 1, 0),
            Mo = new Kr(0, 0, 1),
            To = {
                type: "added"
            },
            So = {
                type: "removed"
            };

        function Eo() {
            Object.defineProperty(this, "id", {
                value: po++
            }), this.uuid = Ur.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Eo.DefaultUp.clone();
            var e = new Kr,
                t = new uo,
                n = new Zr,
                i = new Kr(1, 1, 1);
            t._onChange((function () {
                n.setFromEuler(t, !1)
            })), n._onChange((function () {
                t.setFromQuaternion(n, void 0, !1)
            })), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                modelViewMatrix: {
                    value: new so
                },
                normalMatrix: {
                    value: new Gr
                }
            }), this.matrix = new so, this.matrixWorld = new so, this.matrixAutoUpdate = Eo.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new ho, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
        }

        function Ao() {
            Eo.call(this), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }
        Eo.DefaultUp = new Kr(0, 1, 0), Eo.DefaultMatrixAutoUpdate = !0, Eo.prototype = Object.assign(Object.create(zr.prototype), {
            constructor: Eo,
            isObject3D: !0,
            onBeforeRender: function () { },
            onAfterRender: function () { },
            applyMatrix4: function (e) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            applyQuaternion: function (e) {
                return this.quaternion.premultiply(e), this
            },
            setRotationFromAxisAngle: function (e, t) {
                this.quaternion.setFromAxisAngle(e, t)
            },
            setRotationFromEuler: function (e) {
                this.quaternion.setFromEuler(e, !0)
            },
            setRotationFromMatrix: function (e) {
                this.quaternion.setFromRotationMatrix(e)
            },
            setRotationFromQuaternion: function (e) {
                this.quaternion.copy(e)
            },
            rotateOnAxis: function (e, t) {
                return mo.setFromAxisAngle(e, t), this.quaternion.multiply(mo), this
            },
            rotateOnWorldAxis: function (e, t) {
                return mo.setFromAxisAngle(e, t), this.quaternion.premultiply(mo), this
            },
            rotateX: function (e) {
                return this.rotateOnAxis(bo, e)
            },
            rotateY: function (e) {
                return this.rotateOnAxis(_o, e)
            },
            rotateZ: function (e) {
                return this.rotateOnAxis(Mo, e)
            },
            translateOnAxis: function (e, t) {
                return fo.copy(e).applyQuaternion(this.quaternion), this.position.add(fo.multiplyScalar(t)), this
            },
            translateX: function (e) {
                return this.translateOnAxis(bo, e)
            },
            translateY: function (e) {
                return this.translateOnAxis(_o, e)
            },
            translateZ: function (e) {
                return this.translateOnAxis(Mo, e)
            },
            localToWorld: function (e) {
                return e.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function (e) {
                return e.applyMatrix4(go.getInverse(this.matrixWorld))
            },
            lookAt: function (e, t, n) {
                e.isVector3 ? vo.copy(e) : vo.set(e, t, n);
                var i = this.parent;
                this.updateWorldMatrix(!0, !1), yo.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? go.lookAt(yo, vo, this.up) : go.lookAt(vo, yo, this.up), this.quaternion.setFromRotationMatrix(go), i && (go.extractRotation(i.matrixWorld), mo.setFromRotationMatrix(go), this.quaternion.premultiply(mo.inverse()))
            },
            add: function (e) {
                if (arguments.length > 1) {
                    for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                    return this
                }
                return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(To)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
            },
            remove: function (e) {
                if (arguments.length > 1) {
                    for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                    return this
                }
                var n = this.children.indexOf(e);
                return -1 !== n && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(So)), this
            },
            attach: function (e) {
                return this.updateWorldMatrix(!0, !1), go.getInverse(this.matrixWorld), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), go.multiply(e.parent.matrixWorld)), e.applyMatrix4(go), e.updateWorldMatrix(!1, !1), this.add(e), this
            },
            getObjectById: function (e) {
                return this.getObjectByProperty("id", e)
            },
            getObjectByName: function (e) {
                return this.getObjectByProperty("name", e)
            },
            getObjectByProperty: function (e, t) {
                if (this[e] === t) return this;
                for (var n = 0, i = this.children.length; n < i; n++) {
                    var r = this.children[n].getObjectByProperty(e, t);
                    if (void 0 !== r) return r
                }
            },
            getWorldPosition: function (e) {
                return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new Kr), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function (e) {
                return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), e = new Zr), this.updateMatrixWorld(!0), this.matrixWorld.decompose(yo, e, xo), e
            },
            getWorldScale: function (e) {
                return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), e = new Kr), this.updateMatrixWorld(!0), this.matrixWorld.decompose(yo, wo, e), e
            },
            getWorldDirection: function (e) {
                void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new Kr), this.updateMatrixWorld(!0);
                var t = this.matrixWorld.elements;
                return e.set(t[8], t[9], t[10]).normalize()
            },
            raycast: function () { },
            traverse: function (e) {
                e(this);
                for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].traverse(e)
            },
            traverseVisible: function (e) {
                if (!1 !== this.visible) {
                    e(this);
                    for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
                }
            },
            traverseAncestors: function (e) {
                var t = this.parent;
                null !== t && (e(t), t.traverseAncestors(e))
            },
            updateMatrix: function () {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function (e) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
            },
            updateWorldMatrix: function (e, t) {
                var n = this.parent;
                if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
                    for (var i = this.children, r = 0, o = i.length; r < o; r++) i[r].updateWorldMatrix(!1, !0)
            },
            toJSON: function (e) {
                var t = void 0 === e || "string" == typeof e,
                    n = {};
                t && (e = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {}
                }, n.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                var i = {};

                function r(t, n) {
                    return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                }
                if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(e.geometries, this.geometry);
                    var o = this.geometry.parameters;
                    if (void 0 !== o && void 0 !== o.shapes) {
                        var a = o.shapes;
                        if (Array.isArray(a))
                            for (var s = 0, l = a.length; s < l; s++) {
                                var c = a[s];
                                r(e.shapes, c)
                            } else r(e.shapes, a)
                    }
                }
                if (void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        var u = [];
                        for (s = 0, l = this.material.length; s < l; s++) u.push(r(e.materials, this.material[s]));
                        i.material = u
                    } else i.material = r(e.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (s = 0; s < this.children.length; s++) i.children.push(this.children[s].toJSON(e).object)
                }
                if (t) {
                    var h = m(e.geometries),
                        d = m(e.materials),
                        p = m(e.textures),
                        f = m(e.images);
                    a = m(e.shapes);
                    h.length > 0 && (n.geometries = h), d.length > 0 && (n.materials = d), p.length > 0 && (n.textures = p), f.length > 0 && (n.images = f), a.length > 0 && (n.shapes = a)
                }
                return n.object = i, n;

                function m(e) {
                    var t = [];
                    for (var n in e) {
                        var i = e[n];
                        delete i.metadata, t.push(i)
                    }
                    return t
                }
            },
            clone: function (e) {
                return (new this.constructor).copy(this, e)
            },
            copy: function (e, t) {
                if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                    for (var n = 0; n < e.children.length; n++) {
                        var i = e.children[n];
                        this.add(i.clone())
                    }
                return this
            }
        }), Ao.prototype = Object.assign(Object.create(Eo.prototype), {
            constructor: Ao,
            isScene: !0,
            copy: function (e, t) {
                return Eo.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
            },
            toJSON: function (e) {
                var t = Eo.prototype.toJSON.call(this, e);
                return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.environment && (t.object.environment = this.environment.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        var Co = [new Kr, new Kr, new Kr, new Kr, new Kr, new Kr, new Kr, new Kr],
            Lo = new Kr,
            Po = new Uo,
            Ro = new Kr,
            Oo = new Kr,
            Do = new Kr,
            ko = new Kr,
            No = new Kr,
            Io = new Kr,
            zo = new Kr,
            Fo = new Kr,
            Ho = new Kr,
            Bo = new Kr;

        function Uo(e, t) {
            this.min = void 0 !== e ? e : new Kr(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new Kr(-1 / 0, -1 / 0, -1 / 0)
        }

        function jo(e, t, n, i, r) {
            var o, a;
            for (o = 0, a = e.length - 3; o <= a; o += 3) {
                Bo.fromArray(e, o);
                var s = r.x * Math.abs(Bo.x) + r.y * Math.abs(Bo.y) + r.z * Math.abs(Bo.z),
                    l = t.dot(Bo),
                    c = n.dot(Bo),
                    u = i.dot(Bo);
                if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > s) return !1
            }
            return !0
        }
        Object.assign(Uo.prototype, {
            isBox3: !0,
            set: function (e, t) {
                return this.min.copy(e), this.max.copy(t), this
            },
            setFromArray: function (e) {
                for (var t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = e.length; s < l; s += 3) {
                    var c = e[s],
                        u = e[s + 1],
                        h = e[s + 2];
                    c < t && (t = c), u < n && (n = u), h < i && (i = h), c > r && (r = c), u > o && (o = u), h > a && (a = h)
                }
                return this.min.set(t, n, i), this.max.set(r, o, a), this
            },
            setFromBufferAttribute: function (e) {
                for (var t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = e.count; s < l; s++) {
                    var c = e.getX(s),
                        u = e.getY(s),
                        h = e.getZ(s);
                    c < t && (t = c), u < n && (n = u), h < i && (i = h), c > r && (r = c), u > o && (o = u), h > a && (a = h)
                }
                return this.min.set(t, n, i), this.max.set(r, o, a), this
            },
            setFromPoints: function (e) {
                this.makeEmpty();
                for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                return this
            },
            setFromCenterAndSize: function (e, t) {
                var n = Lo.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            },
            setFromObject: function (e) {
                return this.makeEmpty(), this.expandByObject(e)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.min.copy(e.min), this.max.copy(e.max), this
            },
            makeEmpty: function () {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            },
            isEmpty: function () {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            },
            getCenter: function (e) {
                return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new Kr), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function (e) {
                return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new Kr), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            },
            expandByPoint: function (e) {
                return this.min.min(e), this.max.max(e), this
            },
            expandByVector: function (e) {
                return this.min.sub(e), this.max.add(e), this
            },
            expandByScalar: function (e) {
                return this.min.addScalar(-e), this.max.addScalar(e), this
            },
            expandByObject: function (e) {
                e.updateWorldMatrix(!1, !1);
                var t = e.geometry;
                void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), Po.copy(t.boundingBox), Po.applyMatrix4(e.matrixWorld), this.union(Po));
                for (var n = e.children, i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
                return this
            },
            containsPoint: function (e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
            },
            containsBox: function (e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
            },
            getParameter: function (e, t) {
                return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new Kr), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
            },
            intersectsBox: function (e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
            },
            intersectsSphere: function (e) {
                return this.clampPoint(e.center, Lo), Lo.distanceToSquared(e.center) <= e.radius * e.radius
            },
            intersectsPlane: function (e) {
                var t, n;
                return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
            },
            intersectsTriangle: function (e) {
                if (this.isEmpty()) return !1;
                this.getCenter(zo), Fo.subVectors(this.max, zo), Ro.subVectors(e.a, zo), Oo.subVectors(e.b, zo), Do.subVectors(e.c, zo), ko.subVectors(Oo, Ro), No.subVectors(Do, Oo), Io.subVectors(Ro, Do);
                var t = [0, -ko.z, ko.y, 0, -No.z, No.y, 0, -Io.z, Io.y, ko.z, 0, -ko.x, No.z, 0, -No.x, Io.z, 0, -Io.x, -ko.y, ko.x, 0, -No.y, No.x, 0, -Io.y, Io.x, 0];
                return !!jo(t, Ro, Oo, Do, Fo) && (!!jo(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], Ro, Oo, Do, Fo) && (Ho.crossVectors(ko, No), jo(t = [Ho.x, Ho.y, Ho.z], Ro, Oo, Do, Fo)))
            },
            clampPoint: function (e, t) {
                return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new Kr), t.copy(e).clamp(this.min, this.max)
            },
            distanceToPoint: function (e) {
                return Lo.copy(e).clamp(this.min, this.max).sub(e).length()
            },
            getBoundingSphere: function (e) {
                return void 0 === e && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = .5 * this.getSize(Lo).length(), e
            },
            intersect: function (e) {
                return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
            },
            union: function (e) {
                return this.min.min(e.min), this.max.max(e.max), this
            },
            applyMatrix4: function (e) {
                return this.isEmpty() || (Co[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Co[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Co[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Co[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Co[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Co[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Co[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Co[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Co)), this
            },
            translate: function (e) {
                return this.min.add(e), this.max.add(e), this
            },
            equals: function (e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        });
        var Go = new Uo;

        function Vo(e, t) {
            this.center = void 0 !== e ? e : new Kr, this.radius = void 0 !== t ? t : 0
        }
        Object.assign(Vo.prototype, {
            set: function (e, t) {
                return this.center.copy(e), this.radius = t, this
            },
            setFromPoints: function (e, t) {
                var n = this.center;
                void 0 !== t ? n.copy(t) : Go.setFromPoints(e).getCenter(n);
                for (var i = 0, r = 0, o = e.length; r < o; r++) i = Math.max(i, n.distanceToSquared(e[r]));
                return this.radius = Math.sqrt(i), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.center.copy(e.center), this.radius = e.radius, this
            },
            empty: function () {
                return this.radius <= 0
            },
            containsPoint: function (e) {
                return e.distanceToSquared(this.center) <= this.radius * this.radius
            },
            distanceToPoint: function (e) {
                return e.distanceTo(this.center) - this.radius
            },
            intersectsSphere: function (e) {
                var t = this.radius + e.radius;
                return e.center.distanceToSquared(this.center) <= t * t
            },
            intersectsBox: function (e) {
                return e.intersectsSphere(this)
            },
            intersectsPlane: function (e) {
                return Math.abs(e.distanceToPoint(this.center)) <= this.radius
            },
            clampPoint: function (e, t) {
                var n = this.center.distanceToSquared(e);
                return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new Kr), t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
            },
            getBoundingBox: function (e) {
                return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new Uo), e.set(this.center, this.center), e.expandByScalar(this.radius), e
            },
            applyMatrix4: function (e) {
                return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
            },
            translate: function (e) {
                return this.center.add(e), this
            },
            equals: function (e) {
                return e.center.equals(this.center) && e.radius === this.radius
            }
        });
        var Wo = new Kr,
            qo = new Kr,
            $o = new Kr,
            Xo = new Kr,
            Yo = new Kr,
            Zo = new Kr,
            Jo = new Kr;

        function Qo(e, t) {
            this.origin = void 0 !== e ? e : new Kr, this.direction = void 0 !== t ? t : new Kr(0, 0, -1)
        }
        Object.assign(Qo.prototype, {
            set: function (e, t) {
                return this.origin.copy(e), this.direction.copy(t), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.origin.copy(e.origin), this.direction.copy(e.direction), this
            },
            at: function (e, t) {
                return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new Kr), t.copy(this.direction).multiplyScalar(e).add(this.origin)
            },
            lookAt: function (e) {
                return this.direction.copy(e).sub(this.origin).normalize(), this
            },
            recast: function (e) {
                return this.origin.copy(this.at(e, Wo)), this
            },
            closestPointToPoint: function (e, t) {
                void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new Kr), t.subVectors(e, this.origin);
                var n = t.dot(this.direction);
                return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
            },
            distanceToPoint: function (e) {
                return Math.sqrt(this.distanceSqToPoint(e))
            },
            distanceSqToPoint: function (e) {
                var t = Wo.subVectors(e, this.origin).dot(this.direction);
                return t < 0 ? this.origin.distanceToSquared(e) : (Wo.copy(this.direction).multiplyScalar(t).add(this.origin), Wo.distanceToSquared(e))
            },
            distanceSqToSegment: function (e, t, n, i) {
                qo.copy(e).add(t).multiplyScalar(.5), $o.copy(t).sub(e).normalize(), Xo.copy(this.origin).sub(qo);
                var r, o, a, s, l = .5 * e.distanceTo(t),
                    c = -this.direction.dot($o),
                    u = Xo.dot(this.direction),
                    h = -Xo.dot($o),
                    d = Xo.lengthSq(),
                    p = Math.abs(1 - c * c);
                if (p > 0)
                    if (o = c * u - h, s = l * p, (r = c * h - u) >= 0)
                        if (o >= -s)
                            if (o <= s) {
                                var f = 1 / p;
                                a = (r *= f) * (r + c * (o *= f) + 2 * u) + o * (c * r + o + 2 * h) + d
                            } else o = l, a = -(r = Math.max(0, -(c * o + u))) * r + o * (o + 2 * h) + d;
                        else o = -l, a = -(r = Math.max(0, -(c * o + u))) * r + o * (o + 2 * h) + d;
                    else o <= -s ? a = -(r = Math.max(0, -(-c * l + u))) * r + (o = r > 0 ? -l : Math.min(Math.max(-l, -h), l)) * (o + 2 * h) + d : o <= s ? (r = 0, a = (o = Math.min(Math.max(-l, -h), l)) * (o + 2 * h) + d) : a = -(r = Math.max(0, -(c * l + u))) * r + (o = r > 0 ? l : Math.min(Math.max(-l, -h), l)) * (o + 2 * h) + d;
                else o = c > 0 ? -l : l, a = -(r = Math.max(0, -(c * o + u))) * r + o * (o + 2 * h) + d;
                return n && n.copy(this.direction).multiplyScalar(r).add(this.origin), i && i.copy($o).multiplyScalar(o).add(qo), a
            },
            intersectSphere: function (e, t) {
                Wo.subVectors(e.center, this.origin);
                var n = Wo.dot(this.direction),
                    i = Wo.dot(Wo) - n * n,
                    r = e.radius * e.radius;
                if (i > r) return null;
                var o = Math.sqrt(r - i),
                    a = n - o,
                    s = n + o;
                return a < 0 && s < 0 ? null : a < 0 ? this.at(s, t) : this.at(a, t)
            },
            intersectsSphere: function (e) {
                return this.distanceSqToPoint(e.center) <= e.radius * e.radius
            },
            distanceToPlane: function (e) {
                var t = e.normal.dot(this.direction);
                if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                var n = -(this.origin.dot(e.normal) + e.constant) / t;
                return n >= 0 ? n : null
            },
            intersectPlane: function (e, t) {
                var n = this.distanceToPlane(e);
                return null === n ? null : this.at(n, t)
            },
            intersectsPlane: function (e) {
                var t = e.distanceToPoint(this.origin);
                return 0 === t || e.normal.dot(this.direction) * t < 0
            },
            intersectBox: function (e, t) {
                var n, i, r, o, a, s, l = 1 / this.direction.x,
                    c = 1 / this.direction.y,
                    u = 1 / this.direction.z,
                    h = this.origin;
                return l >= 0 ? (n = (e.min.x - h.x) * l, i = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, i = (e.min.x - h.x) * l), c >= 0 ? (r = (e.min.y - h.y) * c, o = (e.max.y - h.y) * c) : (r = (e.max.y - h.y) * c, o = (e.min.y - h.y) * c), n > o || r > i ? null : ((r > n || n != n) && (n = r), (o < i || i != i) && (i = o), u >= 0 ? (a = (e.min.z - h.z) * u, s = (e.max.z - h.z) * u) : (a = (e.max.z - h.z) * u, s = (e.min.z - h.z) * u), n > s || a > i ? null : ((a > n || n != n) && (n = a), (s < i || i != i) && (i = s), i < 0 ? null : this.at(n >= 0 ? n : i, t)))
            },
            intersectsBox: function (e) {
                return null !== this.intersectBox(e, Wo)
            },
            intersectTriangle: function (e, t, n, i, r) {
                Yo.subVectors(t, e), Zo.subVectors(n, e), Jo.crossVectors(Yo, Zo);
                var o, a = this.direction.dot(Jo);
                if (a > 0) {
                    if (i) return null;
                    o = 1
                } else {
                    if (!(a < 0)) return null;
                    o = -1, a = -a
                }
                Xo.subVectors(this.origin, e);
                var s = o * this.direction.dot(Zo.crossVectors(Xo, Zo));
                if (s < 0) return null;
                var l = o * this.direction.dot(Yo.cross(Xo));
                if (l < 0) return null;
                if (s + l > a) return null;
                var c = -o * Xo.dot(Jo);
                return c < 0 ? null : this.at(c / a, r)
            },
            applyMatrix4: function (e) {
                return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
            },
            equals: function (e) {
                return e.origin.equals(this.origin) && e.direction.equals(this.direction)
            }
        });
        var Ko = new Kr,
            ea = new Kr,
            ta = new Gr;

        function na(e, t) {
            this.normal = void 0 !== e ? e : new Kr(1, 0, 0), this.constant = void 0 !== t ? t : 0
        }
        Object.assign(na.prototype, {
            isPlane: !0,
            set: function (e, t) {
                return this.normal.copy(e), this.constant = t, this
            },
            setComponents: function (e, t, n, i) {
                return this.normal.set(e, t, n), this.constant = i, this
            },
            setFromNormalAndCoplanarPoint: function (e, t) {
                return this.normal.copy(e), this.constant = -t.dot(this.normal), this
            },
            setFromCoplanarPoints: function (e, t, n) {
                var i = Ko.subVectors(n, t).cross(ea.subVectors(e, t)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, e), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.normal.copy(e.normal), this.constant = e.constant, this
            },
            normalize: function () {
                var e = 1 / this.normal.length();
                return this.normal.multiplyScalar(e), this.constant *= e, this
            },
            negate: function () {
                return this.constant *= -1, this.normal.negate(), this
            },
            distanceToPoint: function (e) {
                return this.normal.dot(e) + this.constant
            },
            distanceToSphere: function (e) {
                return this.distanceToPoint(e.center) - e.radius
            },
            projectPoint: function (e, t) {
                return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new Kr), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
            },
            intersectLine: function (e, t) {
                void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"), t = new Kr);
                var n = e.delta(Ko),
                    i = this.normal.dot(n);
                if (0 === i) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0;
                var r = -(e.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? void 0 : t.copy(n).multiplyScalar(r).add(e.start)
            },
            intersectsLine: function (e) {
                var t = this.distanceToPoint(e.start),
                    n = this.distanceToPoint(e.end);
                return t < 0 && n > 0 || n < 0 && t > 0
            },
            intersectsBox: function (e) {
                return e.intersectsPlane(this)
            },
            intersectsSphere: function (e) {
                return e.intersectsPlane(this)
            },
            coplanarPoint: function (e) {
                return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new Kr), e.copy(this.normal).multiplyScalar(-this.constant)
            },
            applyMatrix4: function (e, t) {
                var n = t || ta.getNormalMatrix(e),
                    i = this.coplanarPoint(Ko).applyMatrix4(e),
                    r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r), this
            },
            translate: function (e) {
                return this.constant -= e.dot(this.normal), this
            },
            equals: function (e) {
                return e.normal.equals(this.normal) && e.constant === this.constant
            }
        });
        var ia = new Kr,
            ra = new Kr,
            oa = new Kr,
            aa = new Kr,
            sa = new Kr,
            la = new Kr,
            ca = new Kr,
            ua = new Kr,
            ha = new Kr,
            da = new Kr;

        function pa(e, t, n) {
            this.a = void 0 !== e ? e : new Kr, this.b = void 0 !== t ? t : new Kr, this.c = void 0 !== n ? n : new Kr
        }
        Object.assign(pa, {
            getNormal: function (e, t, n, i) {
                void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new Kr), i.subVectors(n, t), ia.subVectors(e, t), i.cross(ia);
                var r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            },
            getBarycoord: function (e, t, n, i, r) {
                ia.subVectors(i, t), ra.subVectors(n, t), oa.subVectors(e, t);
                var o = ia.dot(ia),
                    a = ia.dot(ra),
                    s = ia.dot(oa),
                    l = ra.dot(ra),
                    c = ra.dot(oa),
                    u = o * l - a * a;
                if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new Kr), 0 === u) return r.set(-2, -1, -1);
                var h = 1 / u,
                    d = (l * s - a * c) * h,
                    p = (o * c - a * s) * h;
                return r.set(1 - d - p, p, d)
            },
            containsPoint: function (e, t, n, i) {
                return pa.getBarycoord(e, t, n, i, aa), aa.x >= 0 && aa.y >= 0 && aa.x + aa.y <= 1
            },
            getUV: function (e, t, n, i, r, o, a, s) {
                return this.getBarycoord(e, t, n, i, aa), s.set(0, 0), s.addScaledVector(r, aa.x), s.addScaledVector(o, aa.y), s.addScaledVector(a, aa.z), s
            },
            isFrontFacing: function (e, t, n, i) {
                return ia.subVectors(n, t), ra.subVectors(e, t), ia.cross(ra).dot(i) < 0
            }
        }), Object.assign(pa.prototype, {
            set: function (e, t, n) {
                return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
            },
            setFromPointsAndIndices: function (e, t, n, i) {
                return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
            },
            getArea: function () {
                return ia.subVectors(this.c, this.b), ra.subVectors(this.a, this.b), .5 * ia.cross(ra).length()
            },
            getMidpoint: function (e) {
                return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new Kr), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            },
            getNormal: function (e) {
                return pa.getNormal(this.a, this.b, this.c, e)
            },
            getPlane: function (e) {
                return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new na), e.setFromCoplanarPoints(this.a, this.b, this.c)
            },
            getBarycoord: function (e, t) {
                return pa.getBarycoord(e, this.a, this.b, this.c, t)
            },
            getUV: function (e, t, n, i, r) {
                return pa.getUV(e, this.a, this.b, this.c, t, n, i, r)
            },
            containsPoint: function (e) {
                return pa.containsPoint(e, this.a, this.b, this.c)
            },
            isFrontFacing: function (e) {
                return pa.isFrontFacing(this.a, this.b, this.c, e)
            },
            intersectsBox: function (e) {
                return e.intersectsTriangle(this)
            },
            closestPointToPoint: function (e, t) {
                void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), t = new Kr);
                var n, i, r = this.a,
                    o = this.b,
                    a = this.c;
                sa.subVectors(o, r), la.subVectors(a, r), ua.subVectors(e, r);
                var s = sa.dot(ua),
                    l = la.dot(ua);
                if (s <= 0 && l <= 0) return t.copy(r);
                ha.subVectors(e, o);
                var c = sa.dot(ha),
                    u = la.dot(ha);
                if (c >= 0 && u <= c) return t.copy(o);
                var h = s * u - c * l;
                if (h <= 0 && s >= 0 && c <= 0) return n = s / (s - c), t.copy(r).addScaledVector(sa, n);
                da.subVectors(e, a);
                var d = sa.dot(da),
                    p = la.dot(da);
                if (p >= 0 && d <= p) return t.copy(a);
                var f = d * l - s * p;
                if (f <= 0 && l >= 0 && p <= 0) return i = l / (l - p), t.copy(r).addScaledVector(la, i);
                var m = c * p - d * u;
                if (m <= 0 && u - c >= 0 && d - p >= 0) return ca.subVectors(a, o), i = (u - c) / (u - c + (d - p)), t.copy(o).addScaledVector(ca, i);
                var g = 1 / (m + f + h);
                return n = f * g, i = h * g, t.copy(r).addScaledVector(sa, n).addScaledVector(la, i)
            },
            equals: function (e) {
                return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
            }
        });
        var fa = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        },
            ma = {
                h: 0,
                s: 0,
                l: 0
            },
            ga = {
                h: 0,
                s: 0,
                l: 0
            };

        function va(e, t, n) {
            return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
        }

        function ya(e, t, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
        }

        function xa(e) {
            return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
        }

        function wa(e) {
            return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
        }

        function ba(e, t, n, i, r, o) {
            this.a = e, this.b = t, this.c = n, this.normal = i && i.isVector3 ? i : new Kr, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new va, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0
        }
        Object.assign(va.prototype, {
            isColor: !0,
            r: 1,
            g: 1,
            b: 1,
            set: function (e) {
                return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
            },
            setScalar: function (e) {
                return this.r = e, this.g = e, this.b = e, this
            },
            setHex: function (e) {
                return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
            },
            setRGB: function (e, t, n) {
                return this.r = e, this.g = t, this.b = n, this
            },
            setHSL: function (e, t, n) {
                if (e = Ur.euclideanModulo(e, 1), t = Ur.clamp(t, 0, 1), n = Ur.clamp(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                else {
                    var i = n <= .5 ? n * (1 + t) : n + t - n * t,
                        r = 2 * n - i;
                    this.r = ya(r, i, e + 1 / 3), this.g = ya(r, i, e), this.b = ya(r, i, e - 1 / 3)
                }
                return this
            },
            setStyle: function (e) {
                function t(t) {
                    void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                }
                var n;
                if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                    var i, r = n[1],
                        o = n[2];
                    switch (r) {
                        case "rgb":
                        case "rgba":
                            if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, t(i[5]), this;
                            if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, t(i[5]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                                var a = parseFloat(i[1]) / 360,
                                    s = parseInt(i[2], 10) / 100,
                                    l = parseInt(i[3], 10) / 100;
                                return t(i[5]), this.setHSL(a, s, l)
                            }
                    }
                } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
                    var c = n[1],
                        u = c.length;
                    if (3 === u) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
                    if (6 === u) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
                }
                return e && e.length > 0 ? this.setColorName(e) : this
            },
            setColorName: function (e) {
                var t = fa[e];
                return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this
            },
            clone: function () {
                return new this.constructor(this.r, this.g, this.b)
            },
            copy: function (e) {
                return this.r = e.r, this.g = e.g, this.b = e.b, this
            },
            copyGammaToLinear: function (e, t) {
                return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
            },
            copyLinearToGamma: function (e, t) {
                void 0 === t && (t = 2);
                var n = t > 0 ? 1 / t : 1;
                return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
            },
            convertGammaToLinear: function (e) {
                return this.copyGammaToLinear(this, e), this
            },
            convertLinearToGamma: function (e) {
                return this.copyLinearToGamma(this, e), this
            },
            copySRGBToLinear: function (e) {
                return this.r = xa(e.r), this.g = xa(e.g), this.b = xa(e.b), this
            },
            copyLinearToSRGB: function (e) {
                return this.r = wa(e.r), this.g = wa(e.g), this.b = wa(e.b), this
            },
            convertSRGBToLinear: function () {
                return this.copySRGBToLinear(this), this
            },
            convertLinearToSRGB: function () {
                return this.copyLinearToSRGB(this), this
            },
            getHex: function () {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            },
            getHexString: function () {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            },
            getHSL: function (e) {
                void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = {
                    h: 0,
                    s: 0,
                    l: 0
                });
                var t, n, i = this.r,
                    r = this.g,
                    o = this.b,
                    a = Math.max(i, r, o),
                    s = Math.min(i, r, o),
                    l = (s + a) / 2;
                if (s === a) t = 0, n = 0;
                else {
                    var c = a - s;
                    switch (n = l <= .5 ? c / (a + s) : c / (2 - a - s), a) {
                        case i:
                            t = (r - o) / c + (r < o ? 6 : 0);
                            break;
                        case r:
                            t = (o - i) / c + 2;
                            break;
                        case o:
                            t = (i - r) / c + 4
                    }
                    t /= 6
                }
                return e.h = t, e.s = n, e.l = l, e
            },
            getStyle: function () {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            },
            offsetHSL: function (e, t, n) {
                return this.getHSL(ma), ma.h += e, ma.s += t, ma.l += n, this.setHSL(ma.h, ma.s, ma.l), this
            },
            add: function (e) {
                return this.r += e.r, this.g += e.g, this.b += e.b, this
            },
            addColors: function (e, t) {
                return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
            },
            addScalar: function (e) {
                return this.r += e, this.g += e, this.b += e, this
            },
            sub: function (e) {
                return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
            },
            multiply: function (e) {
                return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
            },
            multiplyScalar: function (e) {
                return this.r *= e, this.g *= e, this.b *= e, this
            },
            lerp: function (e, t) {
                return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
            },
            lerpHSL: function (e, t) {
                this.getHSL(ma), e.getHSL(ga);
                var n = Ur.lerp(ma.h, ga.h, t),
                    i = Ur.lerp(ma.s, ga.s, t),
                    r = Ur.lerp(ma.l, ga.l, t);
                return this.setHSL(n, i, r), this
            },
            equals: function (e) {
                return e.r === this.r && e.g === this.g && e.b === this.b
            },
            fromArray: function (e, t) {
                return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
            },
            toArray: function (e, t) {
                return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
            },
            toJSON: function () {
                return this.getHex()
            }
        }), va.NAMES = fa, Object.assign(ba.prototype, {
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
                for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
                for (t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone();
                return this
            }
        });
        var _a = 0;

        function Ma() {
            Object.defineProperty(this, "id", {
                value: _a++
            }), this.uuid = Ur.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = ir, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = kr, this.stencilZFail = kr, this.stencilZPass = kr, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
        }

        function Ta(e) {
            Ma.call(this), this.type = "MeshBasicMaterial", this.color = new va(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(e)
        }
        Ma.prototype = Object.assign(Object.create(zr.prototype), {
            constructor: Ma,
            isMaterial: !0,
            onBeforeCompile: function () { },
            setValues: function (e) {
                if (void 0 !== e)
                    for (var t in e) {
                        var n = e[t];
                        if (void 0 !== n)
                            if ("shading" !== t) {
                                var i = this[t];
                                void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                            } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                        else console.warn("THREE.Material: '" + t + "' parameter is undefined.")
                    }
            },
            toJSON: function (e) {
                var t = void 0 === e || "string" == typeof e;
                t && (e = {
                    textures: {},
                    images: {}
                });
                var n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function i(e) {
                    var t = [];
                    for (var n in e) {
                        var i = e[n];
                        delete i.metadata, t.push(i)
                    }
                    return t
                }
                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
                    var r = i(e.textures),
                        o = i(e.images);
                    r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o)
                }
                return n
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                var t = e.clippingPlanes,
                    n = null;
                if (null !== t) {
                    var i = t.length;
                    n = new Array(i);
                    for (var r = 0; r !== i; ++r) n[r] = t[r].clone()
                }
                return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), Object.defineProperty(Ma.prototype, "needsUpdate", {
            set: function (e) {
                !0 === e && this.version++
            }
        }), Ta.prototype = Object.create(Ma.prototype), Ta.prototype.constructor = Ta, Ta.prototype.isMeshBasicMaterial = !0, Ta.prototype.copy = function (e) {
            return Ma.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
        };
        var Sa = new Kr;

        function Ea(e, t, n) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = Nr, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        function Aa(e, t, n) {
            Ea.call(this, new Int8Array(e), t, n)
        }

        function Ca(e, t, n) {
            Ea.call(this, new Uint8Array(e), t, n)
        }

        function La(e, t, n) {
            Ea.call(this, new Uint8ClampedArray(e), t, n)
        }

        function Pa(e, t, n) {
            Ea.call(this, new Int16Array(e), t, n)
        }

        function Ra(e, t, n) {
            Ea.call(this, new Uint16Array(e), t, n)
        }

        function Oa(e, t, n) {
            Ea.call(this, new Int32Array(e), t, n)
        }

        function Da(e, t, n) {
            Ea.call(this, new Uint32Array(e), t, n)
        }

        function ka(e, t, n) {
            Ea.call(this, new Float32Array(e), t, n)
        }

        function Na(e, t, n) {
            Ea.call(this, new Float64Array(e), t, n)
        }

        function Ia() {
            this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
        }

        function za(e) {
            if (0 === e.length) return -1 / 0;
            for (var t = e[0], n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
            return t
        }
        Object.defineProperty(Ea.prototype, "needsUpdate", {
            set: function (e) {
                !0 === e && this.version++
            }
        }), Object.assign(Ea.prototype, {
            isBufferAttribute: !0,
            onUploadCallback: function () { },
            setUsage: function (e) {
                return this.usage = e, this
            },
            copy: function (e) {
                return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
            },
            copyAt: function (e, t, n) {
                e *= this.itemSize, n *= t.itemSize;
                for (var i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
                return this
            },
            copyArray: function (e) {
                return this.array.set(e), this
            },
            copyColorsArray: function (e) {
                for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                    var o = e[i];
                    void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), o = new va), t[n++] = o.r, t[n++] = o.g, t[n++] = o.b
                }
                return this
            },
            copyVector2sArray: function (e) {
                for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                    var o = e[i];
                    void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), o = new jr), t[n++] = o.x, t[n++] = o.y
                }
                return this
            },
            copyVector3sArray: function (e) {
                for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                    var o = e[i];
                    void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), o = new Kr), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z
                }
                return this
            },
            copyVector4sArray: function (e) {
                for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                    var o = e[i];
                    void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), o = new $r), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z, t[n++] = o.w
                }
                return this
            },
            applyMatrix3: function (e) {
                for (var t = 0, n = this.count; t < n; t++) Sa.x = this.getX(t), Sa.y = this.getY(t), Sa.z = this.getZ(t), Sa.applyMatrix3(e), this.setXYZ(t, Sa.x, Sa.y, Sa.z);
                return this
            },
            applyMatrix4: function (e) {
                for (var t = 0, n = this.count; t < n; t++) Sa.x = this.getX(t), Sa.y = this.getY(t), Sa.z = this.getZ(t), Sa.applyMatrix4(e), this.setXYZ(t, Sa.x, Sa.y, Sa.z);
                return this
            },
            applyNormalMatrix: function (e) {
                for (var t = 0, n = this.count; t < n; t++) Sa.x = this.getX(t), Sa.y = this.getY(t), Sa.z = this.getZ(t), Sa.applyNormalMatrix(e), this.setXYZ(t, Sa.x, Sa.y, Sa.z);
                return this
            },
            transformDirection: function (e) {
                for (var t = 0, n = this.count; t < n; t++) Sa.x = this.getX(t), Sa.y = this.getY(t), Sa.z = this.getZ(t), Sa.transformDirection(e), this.setXYZ(t, Sa.x, Sa.y, Sa.z);
                return this
            },
            set: function (e, t) {
                return void 0 === t && (t = 0), this.array.set(e, t), this
            },
            getX: function (e) {
                return this.array[e * this.itemSize]
            },
            setX: function (e, t) {
                return this.array[e * this.itemSize] = t, this
            },
            getY: function (e) {
                return this.array[e * this.itemSize + 1]
            },
            setY: function (e, t) {
                return this.array[e * this.itemSize + 1] = t, this
            },
            getZ: function (e) {
                return this.array[e * this.itemSize + 2]
            },
            setZ: function (e, t) {
                return this.array[e * this.itemSize + 2] = t, this
            },
            getW: function (e) {
                return this.array[e * this.itemSize + 3]
            },
            setW: function (e, t) {
                return this.array[e * this.itemSize + 3] = t, this
            },
            setXY: function (e, t, n) {
                return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
            },
            setXYZ: function (e, t, n, i) {
                return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
            },
            setXYZW: function (e, t, n, i, r) {
                return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
            },
            onUpload: function (e) {
                return this.onUploadCallback = e, this
            },
            clone: function () {
                return new this.constructor(this.array, this.itemSize).copy(this)
            },
            toJSON: function () {
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                }
            }
        }), Aa.prototype = Object.create(Ea.prototype), Aa.prototype.constructor = Aa, Ca.prototype = Object.create(Ea.prototype), Ca.prototype.constructor = Ca, La.prototype = Object.create(Ea.prototype), La.prototype.constructor = La, Pa.prototype = Object.create(Ea.prototype), Pa.prototype.constructor = Pa, Ra.prototype = Object.create(Ea.prototype), Ra.prototype.constructor = Ra, Oa.prototype = Object.create(Ea.prototype), Oa.prototype.constructor = Oa, Da.prototype = Object.create(Ea.prototype), Da.prototype.constructor = Da, ka.prototype = Object.create(Ea.prototype), ka.prototype.constructor = ka, Na.prototype = Object.create(Ea.prototype), Na.prototype.constructor = Na, Object.assign(Ia.prototype, {
            computeGroups: function (e) {
                for (var t, n = [], i = void 0, r = e.faces, o = 0; o < r.length; o++) {
                    var a = r[o];
                    a.materialIndex !== i && (i = a.materialIndex, void 0 !== t && (t.count = 3 * o - t.start, n.push(t)), t = {
                        start: 3 * o,
                        materialIndex: i
                    })
                }
                void 0 !== t && (t.count = 3 * o - t.start, n.push(t)), this.groups = n
            },
            fromGeometry: function (e) {
                var t, n = e.faces,
                    i = e.vertices,
                    r = e.faceVertexUvs,
                    o = r[0] && r[0].length > 0,
                    a = r[1] && r[1].length > 0,
                    s = e.morphTargets,
                    l = s.length;
                if (l > 0) {
                    t = [];
                    for (var c = 0; c < l; c++) t[c] = {
                        name: s[c].name,
                        data: []
                    };
                    this.morphTargets.position = t
                }
                var u, h = e.morphNormals,
                    d = h.length;
                if (d > 0) {
                    u = [];
                    for (c = 0; c < d; c++) u[c] = {
                        name: h[c].name,
                        data: []
                    };
                    this.morphTargets.normal = u
                }
                var p = e.skinIndices,
                    f = e.skinWeights,
                    m = p.length === i.length,
                    g = f.length === i.length;
                i.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                for (c = 0; c < n.length; c++) {
                    var v = n[c];
                    this.vertices.push(i[v.a], i[v.b], i[v.c]);
                    var y = v.vertexNormals;
                    if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                    else {
                        var x = v.normal;
                        this.normals.push(x, x, x)
                    }
                    var w, b = v.vertexColors;
                    if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                    else {
                        var _ = v.color;
                        this.colors.push(_, _, _)
                    }
                    if (!0 === o) void 0 !== (w = r[0][c]) ? this.uvs.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", c), this.uvs.push(new jr, new jr, new jr));
                    if (!0 === a) void 0 !== (w = r[1][c]) ? this.uvs2.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", c), this.uvs2.push(new jr, new jr, new jr));
                    for (var M = 0; M < l; M++) {
                        var T = s[M].vertices;
                        t[M].data.push(T[v.a], T[v.b], T[v.c])
                    }
                    for (M = 0; M < d; M++) {
                        var S = h[M].vertexNormals[c];
                        u[M].data.push(S.a, S.b, S.c)
                    }
                    m && this.skinIndices.push(p[v.a], p[v.b], p[v.c]), g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
                }
                return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
            }
        });
        var Fa = 1,
            Ha = new so,
            Ba = new Eo,
            Ua = new Kr,
            ja = new Uo,
            Ga = new Uo,
            Va = new Kr;

        function Wa() {
            Object.defineProperty(this, "id", {
                value: Fa += 2
            }), this.uuid = Ur.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {}
        }
        Wa.prototype = Object.assign(Object.create(zr.prototype), {
            constructor: Wa,
            isBufferGeometry: !0,
            getIndex: function () {
                return this.index
            },
            setIndex: function (e) {
                Array.isArray(e) ? this.index = new (za(e) > 65535 ? Da : Ra)(e, 1) : this.index = e
            },
            getAttribute: function (e) {
                return this.attributes[e]
            },
            setAttribute: function (e, t) {
                return this.attributes[e] = t, this
            },
            deleteAttribute: function (e) {
                return delete this.attributes[e], this
            },
            addGroup: function (e, t, n) {
                this.groups.push({
                    start: e,
                    count: t,
                    materialIndex: void 0 !== n ? n : 0
                })
            },
            clearGroups: function () {
                this.groups = []
            },
            setDrawRange: function (e, t) {
                this.drawRange.start = e, this.drawRange.count = t
            },
            applyMatrix4: function (e) {
                var t = this.attributes.position;
                void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                var n = this.attributes.normal;
                if (void 0 !== n) {
                    var i = (new Gr).getNormalMatrix(e);
                    n.applyNormalMatrix(i), n.needsUpdate = !0
                }
                var r = this.attributes.tangent;
                return void 0 !== r && (r.transformDirection(e), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            },
            rotateX: function (e) {
                return Ha.makeRotationX(e), this.applyMatrix4(Ha), this
            },
            rotateY: function (e) {
                return Ha.makeRotationY(e), this.applyMatrix4(Ha), this
            },
            rotateZ: function (e) {
                return Ha.makeRotationZ(e), this.applyMatrix4(Ha), this
            },
            translate: function (e, t, n) {
                return Ha.makeTranslation(e, t, n), this.applyMatrix4(Ha), this
            },
            scale: function (e, t, n) {
                return Ha.makeScale(e, t, n), this.applyMatrix4(Ha), this
            },
            lookAt: function (e) {
                return Ba.lookAt(e), Ba.updateMatrix(), this.applyMatrix4(Ba.matrix), this
            },
            center: function () {
                return this.computeBoundingBox(), this.boundingBox.getCenter(Ua).negate(), this.translate(Ua.x, Ua.y, Ua.z), this
            },
            setFromObject: function (e) {
                var t = e.geometry;
                if (e.isPoints || e.isLine) {
                    var n = new ka(3 * t.vertices.length, 3),
                        i = new ka(3 * t.colors.length, 3);
                    if (this.setAttribute("position", n.copyVector3sArray(t.vertices)), this.setAttribute("color", i.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
                        var r = new ka(t.lineDistances.length, 1);
                        this.setAttribute("lineDistance", r.copyArray(t.lineDistances))
                    }
                    null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
                } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
                return this
            },
            setFromPoints: function (e) {
                for (var t = [], n = 0, i = e.length; n < i; n++) {
                    var r = e[n];
                    t.push(r.x, r.y, r.z || 0)
                }
                return this.setAttribute("position", new ka(t, 3)), this
            },
            updateFromObject: function (e) {
                var t, n = e.geometry;
                if (e.isMesh) {
                    var i = n.__directGeometry;
                    if (!0 === n.elementsNeedUpdate && (i = void 0, n.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(n);
                    i.verticesNeedUpdate = n.verticesNeedUpdate, i.normalsNeedUpdate = n.normalsNeedUpdate, i.colorsNeedUpdate = n.colorsNeedUpdate, i.uvsNeedUpdate = n.uvsNeedUpdate, i.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = i
                }
                return !0 === n.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(n.vertices), t.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(n.normals), t.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(n.colors), t.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(n.uvs), t.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(n.lineDistances), t.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(e.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
            },
            fromGeometry: function (e) {
                return e.__directGeometry = (new Ia).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
            },
            fromDirectGeometry: function (e) {
                var t = new Float32Array(3 * e.vertices.length);
                if (this.setAttribute("position", new Ea(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
                    var n = new Float32Array(3 * e.normals.length);
                    this.setAttribute("normal", new Ea(n, 3).copyVector3sArray(e.normals))
                }
                if (e.colors.length > 0) {
                    var i = new Float32Array(3 * e.colors.length);
                    this.setAttribute("color", new Ea(i, 3).copyColorsArray(e.colors))
                }
                if (e.uvs.length > 0) {
                    var r = new Float32Array(2 * e.uvs.length);
                    this.setAttribute("uv", new Ea(r, 2).copyVector2sArray(e.uvs))
                }
                if (e.uvs2.length > 0) {
                    var o = new Float32Array(2 * e.uvs2.length);
                    this.setAttribute("uv2", new Ea(o, 2).copyVector2sArray(e.uvs2))
                }
                for (var a in this.groups = e.groups, e.morphTargets) {
                    for (var s = [], l = e.morphTargets[a], c = 0, u = l.length; c < u; c++) {
                        var h = l[c],
                            d = new ka(3 * h.data.length, 3);
                        d.name = h.name, s.push(d.copyVector3sArray(h.data))
                    }
                    this.morphAttributes[a] = s
                }
                if (e.skinIndices.length > 0) {
                    var p = new ka(4 * e.skinIndices.length, 4);
                    this.setAttribute("skinIndex", p.copyVector4sArray(e.skinIndices))
                }
                if (e.skinWeights.length > 0) {
                    var f = new ka(4 * e.skinWeights.length, 4);
                    this.setAttribute("skinWeight", f.copyVector4sArray(e.skinWeights))
                }
                return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
            },
            computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new Uo);
                var e = this.attributes.position,
                    t = this.morphAttributes.position;
                if (void 0 !== e) {
                    if (this.boundingBox.setFromBufferAttribute(e), t)
                        for (var n = 0, i = t.length; n < i; n++) {
                            var r = t[n];
                            ja.setFromBufferAttribute(r), this.morphTargetsRelative ? (Va.addVectors(this.boundingBox.min, ja.min), this.boundingBox.expandByPoint(Va), Va.addVectors(this.boundingBox.max, ja.max), this.boundingBox.expandByPoint(Va)) : (this.boundingBox.expandByPoint(ja.min), this.boundingBox.expandByPoint(ja.max))
                        }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            },
            computeBoundingSphere: function () {
                null === this.boundingSphere && (this.boundingSphere = new Vo);
                var e = this.attributes.position,
                    t = this.morphAttributes.position;
                if (e) {
                    var n = this.boundingSphere.center;
                    if (ja.setFromBufferAttribute(e), t)
                        for (var i = 0, r = t.length; i < r; i++) {
                            var o = t[i];
                            Ga.setFromBufferAttribute(o), this.morphTargetsRelative ? (Va.addVectors(ja.min, Ga.min), ja.expandByPoint(Va), Va.addVectors(ja.max, Ga.max), ja.expandByPoint(Va)) : (ja.expandByPoint(Ga.min), ja.expandByPoint(Ga.max))
                        }
                    ja.getCenter(n);
                    var a = 0;
                    for (i = 0, r = e.count; i < r; i++) Va.fromBufferAttribute(e, i), a = Math.max(a, n.distanceToSquared(Va));
                    if (t)
                        for (i = 0, r = t.length; i < r; i++) {
                            o = t[i];
                            for (var s = this.morphTargetsRelative, l = 0, c = o.count; l < c; l++) Va.fromBufferAttribute(o, l), s && (Ua.fromBufferAttribute(e, l), Va.add(Ua)), a = Math.max(a, n.distanceToSquared(Va))
                        }
                    this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            },
            computeFaceNormals: function () { },
            computeVertexNormals: function () {
                var e = this.index,
                    t = this.attributes;
                if (t.position) {
                    var n = t.position.array;
                    if (void 0 === t.normal) this.setAttribute("normal", new Ea(new Float32Array(n.length), 3));
                    else
                        for (var i = t.normal.array, r = 0, o = i.length; r < o; r++) i[r] = 0;
                    var a, s, l, c = t.normal.array,
                        u = new Kr,
                        h = new Kr,
                        d = new Kr,
                        p = new Kr,
                        f = new Kr;
                    if (e) {
                        var m = e.array;
                        for (r = 0, o = e.count; r < o; r += 3) a = 3 * m[r + 0], s = 3 * m[r + 1], l = 3 * m[r + 2], u.fromArray(n, a), h.fromArray(n, s), d.fromArray(n, l), p.subVectors(d, h), f.subVectors(u, h), p.cross(f), c[a] += p.x, c[a + 1] += p.y, c[a + 2] += p.z, c[s] += p.x, c[s + 1] += p.y, c[s + 2] += p.z, c[l] += p.x, c[l + 1] += p.y, c[l + 2] += p.z
                    } else
                        for (r = 0, o = n.length; r < o; r += 9) u.fromArray(n, r), h.fromArray(n, r + 3), d.fromArray(n, r + 6), p.subVectors(d, h), f.subVectors(u, h), p.cross(f), c[r] = p.x, c[r + 1] = p.y, c[r + 2] = p.z, c[r + 3] = p.x, c[r + 4] = p.y, c[r + 5] = p.z, c[r + 6] = p.x, c[r + 7] = p.y, c[r + 8] = p.z;
                    this.normalizeNormals(), t.normal.needsUpdate = !0
                }
            },
            merge: function (e, t) {
                if (e && e.isBufferGeometry) {
                    void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    var n = this.attributes;
                    for (var i in n)
                        if (void 0 !== e.attributes[i])
                            for (var r = n[i].array, o = e.attributes[i], a = o.array, s = o.itemSize * t, l = Math.min(a.length, r.length - s), c = 0, u = s; c < l; c++, u++) r[u] = a[c];
                    return this
                }
                console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
            },
            normalizeNormals: function () {
                for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++) Va.x = e.getX(t), Va.y = e.getY(t), Va.z = e.getZ(t), Va.normalize(), e.setXYZ(t, Va.x, Va.y, Va.z)
            },
            toNonIndexed: function () {
                function e(e, t) {
                    for (var n = e.array, i = e.itemSize, r = new n.constructor(t.length * i), o = 0, a = 0, s = 0, l = t.length; s < l; s++) {
                        o = t[s] * i;
                        for (var c = 0; c < i; c++) r[a++] = n[o++]
                    }
                    return new Ea(r, i)
                }
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                var t = new Wa,
                    n = this.index.array,
                    i = this.attributes;
                for (var r in i) {
                    var o = e(i[r], n);
                    t.setAttribute(r, o)
                }
                var a = this.morphAttributes;
                for (r in a) {
                    for (var s = [], l = a[r], c = 0, u = l.length; c < u; c++) {
                        o = e(l[c], n);
                        s.push(o)
                    }
                    t.morphAttributes[r] = s
                }
                t.morphTargetsRelative = this.morphTargetsRelative;
                for (var h = this.groups, d = (c = 0, h.length); c < d; c++) {
                    var p = h[c];
                    t.addGroup(p.start, p.count, p.materialIndex)
                }
                return t
            },
            toJSON: function () {
                var e = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                    var t = this.parameters;
                    for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                    return e
                }
                e.data = {
                    attributes: {}
                };
                var i = this.index;
                null !== i && (e.data.index = {
                    type: i.array.constructor.name,
                    array: Array.prototype.slice.call(i.array)
                });
                var r = this.attributes;
                for (var n in r) {
                    var o = (d = r[n]).toJSON();
                    "" !== d.name && (o.name = d.name), e.data.attributes[n] = o
                }
                var a = {},
                    s = !1;
                for (var n in this.morphAttributes) {
                    for (var l = this.morphAttributes[n], c = [], u = 0, h = l.length; u < h; u++) {
                        var d;
                        o = (d = l[u]).toJSON();
                        "" !== d.name && (o.name = d.name), c.push(o)
                    }
                    c.length > 0 && (a[n] = c, s = !0)
                }
                s && (e.data.morphAttributes = a, e.data.morphTargetsRelative = this.morphTargetsRelative);
                var p = this.groups;
                p.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(p)));
                var f = this.boundingSphere;
                return null !== f && (e.data.boundingSphere = {
                    center: f.center.toArray(),
                    radius: f.radius
                }), e
            },
            clone: function () {
                return (new Wa).copy(this)
            },
            copy: function (e) {
                var t, n, i;
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                var r = e.index;
                null !== r && this.setIndex(r.clone());
                var o = e.attributes;
                for (t in o) {
                    var a = o[t];
                    this.setAttribute(t, a.clone())
                }
                var s = e.morphAttributes;
                for (t in s) {
                    var l = [],
                        c = s[t];
                    for (n = 0, i = c.length; n < i; n++) l.push(c[n].clone());
                    this.morphAttributes[t] = l
                }
                this.morphTargetsRelative = e.morphTargetsRelative;
                var u = e.groups;
                for (n = 0, i = u.length; n < i; n++) {
                    var h = u[n];
                    this.addGroup(h.start, h.count, h.materialIndex)
                }
                var d = e.boundingBox;
                null !== d && (this.boundingBox = d.clone());
                var p = e.boundingSphere;
                return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        var qa = new so,
            $a = new Qo,
            Xa = new Vo,
            Ya = new Kr,
            Za = new Kr,
            Ja = new Kr,
            Qa = new Kr,
            Ka = new Kr,
            es = new Kr,
            ts = new Kr,
            ns = new Kr,
            is = new Kr,
            rs = new jr,
            os = new jr,
            as = new jr,
            ss = new Kr,
            ls = new Kr;

        function cs(e, t) {
            Eo.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new Wa, this.material = void 0 !== t ? t : new Ta, this.updateMorphTargets()
        }

        function us(e, t, n, i, r, o, a, s) {
            if (null === (1 === t.side ? i.intersectTriangle(a, o, r, !0, s) : i.intersectTriangle(r, o, a, 2 !== t.side, s))) return null;
            ls.copy(s), ls.applyMatrix4(e.matrixWorld);
            var l = n.ray.origin.distanceTo(ls);
            return l < n.near || l > n.far ? null : {
                distance: l,
                point: ls.clone(),
                object: e
            }
        }

        function hs(e, t, n, i, r, o, a, s, l, c, u, h) {
            Ya.fromBufferAttribute(r, c), Za.fromBufferAttribute(r, u), Ja.fromBufferAttribute(r, h);
            var d = e.morphTargetInfluences;
            if (t.morphTargets && o && d) {
                ts.set(0, 0, 0), ns.set(0, 0, 0), is.set(0, 0, 0);
                for (var p = 0, f = o.length; p < f; p++) {
                    var m = d[p],
                        g = o[p];
                    0 !== m && (Qa.fromBufferAttribute(g, c), Ka.fromBufferAttribute(g, u), es.fromBufferAttribute(g, h), a ? (ts.addScaledVector(Qa, m), ns.addScaledVector(Ka, m), is.addScaledVector(es, m)) : (ts.addScaledVector(Qa.sub(Ya), m), ns.addScaledVector(Ka.sub(Za), m), is.addScaledVector(es.sub(Ja), m)))
                }
                Ya.add(ts), Za.add(ns), Ja.add(is)
            }
            var v = us(e, t, n, i, Ya, Za, Ja, ss);
            if (v) {
                s && (rs.fromBufferAttribute(s, c), os.fromBufferAttribute(s, u), as.fromBufferAttribute(s, h), v.uv = pa.getUV(ss, Ya, Za, Ja, rs, os, as, new jr)), l && (rs.fromBufferAttribute(l, c), os.fromBufferAttribute(l, u), as.fromBufferAttribute(l, h), v.uv2 = pa.getUV(ss, Ya, Za, Ja, rs, os, as, new jr));
                var y = new ba(c, u, h);
                pa.getNormal(Ya, Za, Ja, y.normal), v.face = y
            }
            return v
        }
        cs.prototype = Object.assign(Object.create(Eo.prototype), {
            constructor: cs,
            isMesh: !0,
            copy: function (e) {
                return Eo.prototype.copy.call(this, e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this
            },
            updateMorphTargets: function () {
                var e, t, n, i = this.geometry;
                if (i.isBufferGeometry) {
                    var r = i.morphAttributes,
                        o = Object.keys(r);
                    if (o.length > 0) {
                        var a = r[o[0]];
                        if (void 0 !== a)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = a.length; e < t; e++) n = a[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                    }
                } else {
                    var s = i.morphTargets;
                    void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            },
            raycast: function (e, t) {
                var n, i = this.geometry,
                    r = this.material,
                    o = this.matrixWorld;
                if (void 0 !== r && (null === i.boundingSphere && i.computeBoundingSphere(), Xa.copy(i.boundingSphere), Xa.applyMatrix4(o), !1 !== e.ray.intersectsSphere(Xa) && (qa.getInverse(o), $a.copy(e.ray).applyMatrix4(qa), null === i.boundingBox || !1 !== $a.intersectsBox(i.boundingBox))))
                    if (i.isBufferGeometry) {
                        var a, s, l, c, u, h, d, p, f, m = i.index,
                            g = i.attributes.position,
                            v = i.morphAttributes.position,
                            y = i.morphTargetsRelative,
                            x = i.attributes.uv,
                            w = i.attributes.uv2,
                            b = i.groups,
                            _ = i.drawRange;
                        if (null !== m)
                            if (Array.isArray(r))
                                for (c = 0, h = b.length; c < h; c++)
                                    for (f = r[(p = b[c]).materialIndex], u = Math.max(p.start, _.start), d = Math.min(p.start + p.count, _.start + _.count); u < d; u += 3) a = m.getX(u), s = m.getX(u + 1), l = m.getX(u + 2), (n = hs(this, f, e, $a, g, v, y, x, w, a, s, l)) && (n.faceIndex = Math.floor(u / 3), n.face.materialIndex = p.materialIndex, t.push(n));
                            else
                                for (c = Math.max(0, _.start), h = Math.min(m.count, _.start + _.count); c < h; c += 3) a = m.getX(c), s = m.getX(c + 1), l = m.getX(c + 2), (n = hs(this, r, e, $a, g, v, y, x, w, a, s, l)) && (n.faceIndex = Math.floor(c / 3), t.push(n));
                        else if (void 0 !== g)
                            if (Array.isArray(r))
                                for (c = 0, h = b.length; c < h; c++)
                                    for (f = r[(p = b[c]).materialIndex], u = Math.max(p.start, _.start), d = Math.min(p.start + p.count, _.start + _.count); u < d; u += 3)(n = hs(this, f, e, $a, g, v, y, x, w, a = u, s = u + 1, l = u + 2)) && (n.faceIndex = Math.floor(u / 3), n.face.materialIndex = p.materialIndex, t.push(n));
                            else
                                for (c = Math.max(0, _.start), h = Math.min(g.count, _.start + _.count); c < h; c += 3)(n = hs(this, r, e, $a, g, v, y, x, w, a = c, s = c + 1, l = c + 2)) && (n.faceIndex = Math.floor(c / 3), t.push(n))
                    } else if (i.isGeometry) {
                        var M, T, S, E, A = Array.isArray(r),
                            C = i.vertices,
                            L = i.faces,
                            P = i.faceVertexUvs[0];
                        P.length > 0 && (E = P);
                        for (var R = 0, O = L.length; R < O; R++) {
                            var D = L[R],
                                k = A ? r[D.materialIndex] : r;
                            if (void 0 !== k && (M = C[D.a], T = C[D.b], S = C[D.c], n = us(this, k, e, $a, M, T, S, ss))) {
                                if (E && E[R]) {
                                    var N = E[R];
                                    rs.copy(N[0]), os.copy(N[1]), as.copy(N[2]), n.uv = pa.getUV(ss, M, T, S, rs, os, as, new jr)
                                }
                                n.face = D, n.faceIndex = R, t.push(n)
                            }
                        }
                    }
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        });
        var ds = 0,
            ps = new so,
            fs = new Eo,
            ms = new Kr;

        function gs() {
            Object.defineProperty(this, "id", {
                value: ds += 2
            }), this.uuid = Ur.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
        }
        gs.prototype = Object.assign(Object.create(zr.prototype), {
            constructor: gs,
            isGeometry: !0,
            applyMatrix4: function (e) {
                for (var t = (new Gr).getNormalMatrix(e), n = 0, i = this.vertices.length; n < i; n++) {
                    this.vertices[n].applyMatrix4(e)
                }
                for (n = 0, i = this.faces.length; n < i; n++) {
                    var r = this.faces[n];
                    r.normal.applyMatrix3(t).normalize();
                    for (var o = 0, a = r.vertexNormals.length; o < a; o++) r.vertexNormals[o].applyMatrix3(t).normalize()
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
            },
            rotateX: function (e) {
                return ps.makeRotationX(e), this.applyMatrix4(ps), this
            },
            rotateY: function (e) {
                return ps.makeRotationY(e), this.applyMatrix4(ps), this
            },
            rotateZ: function (e) {
                return ps.makeRotationZ(e), this.applyMatrix4(ps), this
            },
            translate: function (e, t, n) {
                return ps.makeTranslation(e, t, n), this.applyMatrix4(ps), this
            },
            scale: function (e, t, n) {
                return ps.makeScale(e, t, n), this.applyMatrix4(ps), this
            },
            lookAt: function (e) {
                return fs.lookAt(e), fs.updateMatrix(), this.applyMatrix4(fs.matrix), this
            },
            fromBufferGeometry: function (e) {
                var t = this,
                    n = null !== e.index ? e.index.array : void 0,
                    i = e.attributes;
                if (void 0 === i.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
                var r = i.position.array,
                    o = void 0 !== i.normal ? i.normal.array : void 0,
                    a = void 0 !== i.color ? i.color.array : void 0,
                    s = void 0 !== i.uv ? i.uv.array : void 0,
                    l = void 0 !== i.uv2 ? i.uv2.array : void 0;
                void 0 !== l && (this.faceVertexUvs[1] = []);
                for (var c = 0; c < r.length; c += 3) t.vertices.push((new Kr).fromArray(r, c)), void 0 !== a && t.colors.push((new va).fromArray(a, c));

                function u(e, n, i, r) {
                    var c = void 0 === a ? [] : [t.colors[e].clone(), t.colors[n].clone(), t.colors[i].clone()],
                        u = new ba(e, n, i, void 0 === o ? [] : [(new Kr).fromArray(o, 3 * e), (new Kr).fromArray(o, 3 * n), (new Kr).fromArray(o, 3 * i)], c, r);
                    t.faces.push(u), void 0 !== s && t.faceVertexUvs[0].push([(new jr).fromArray(s, 2 * e), (new jr).fromArray(s, 2 * n), (new jr).fromArray(s, 2 * i)]), void 0 !== l && t.faceVertexUvs[1].push([(new jr).fromArray(l, 2 * e), (new jr).fromArray(l, 2 * n), (new jr).fromArray(l, 2 * i)])
                }
                var h = e.groups;
                if (h.length > 0)
                    for (c = 0; c < h.length; c++)
                        for (var d = h[c], p = d.start, f = p, m = p + d.count; f < m; f += 3) void 0 !== n ? u(n[f], n[f + 1], n[f + 2], d.materialIndex) : u(f, f + 1, f + 2, d.materialIndex);
                else if (void 0 !== n)
                    for (c = 0; c < n.length; c += 3) u(n[c], n[c + 1], n[c + 2]);
                else
                    for (c = 0; c < r.length / 3; c += 3) u(c, c + 1, c + 2);
                return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
            },
            center: function () {
                return this.computeBoundingBox(), this.boundingBox.getCenter(ms).negate(), this.translate(ms.x, ms.y, ms.z), this
            },
            normalize: function () {
                this.computeBoundingSphere();
                var e = this.boundingSphere.center,
                    t = this.boundingSphere.radius,
                    n = 0 === t ? 1 : 1 / t,
                    i = new so;
                return i.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix4(i), this
            },
            computeFaceNormals: function () {
                for (var e = new Kr, t = new Kr, n = 0, i = this.faces.length; n < i; n++) {
                    var r = this.faces[n],
                        o = this.vertices[r.a],
                        a = this.vertices[r.b],
                        s = this.vertices[r.c];
                    e.subVectors(s, a), t.subVectors(o, a), e.cross(t), e.normalize(), r.normal.copy(e)
                }
            },
            computeVertexNormals: function (e) {
                var t, n, i, r, o, a;
                for (void 0 === e && (e = !0), a = new Array(this.vertices.length), t = 0, n = this.vertices.length; t < n; t++) a[t] = new Kr;
                if (e) {
                    var s, l, c, u = new Kr,
                        h = new Kr;
                    for (i = 0, r = this.faces.length; i < r; i++) o = this.faces[i], s = this.vertices[o.a], l = this.vertices[o.b], c = this.vertices[o.c], u.subVectors(c, l), h.subVectors(s, l), u.cross(h), a[o.a].add(u), a[o.b].add(u), a[o.c].add(u)
                } else
                    for (this.computeFaceNormals(), i = 0, r = this.faces.length; i < r; i++) a[(o = this.faces[i]).a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
                for (t = 0, n = this.vertices.length; t < n; t++) a[t].normalize();
                for (i = 0, r = this.faces.length; i < r; i++) {
                    var d = (o = this.faces[i]).vertexNormals;
                    3 === d.length ? (d[0].copy(a[o.a]), d[1].copy(a[o.b]), d[2].copy(a[o.c])) : (d[0] = a[o.a].clone(), d[1] = a[o.b].clone(), d[2] = a[o.c].clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            },
            computeFlatVertexNormals: function () {
                var e, t, n;
                for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
                    var i = (n = this.faces[e]).vertexNormals;
                    3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            },
            computeMorphNormals: function () {
                var e, t, n, i, r;
                for (n = 0, i = this.faces.length; n < i; n++)
                    for ((r = this.faces[n]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), e = 0, t = r.vertexNormals.length; e < t; e++) r.__originalVertexNormals[e] ? r.__originalVertexNormals[e].copy(r.vertexNormals[e]) : r.__originalVertexNormals[e] = r.vertexNormals[e].clone();
                var o = new gs;
                for (o.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
                    if (!this.morphNormals[e]) {
                        this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                        var a = this.morphNormals[e].faceNormals,
                            s = this.morphNormals[e].vertexNormals;
                        for (n = 0, i = this.faces.length; n < i; n++) l = new Kr, c = {
                            a: new Kr,
                            b: new Kr,
                            c: new Kr
                        }, a.push(l), s.push(c)
                    }
                    var l, c, u = this.morphNormals[e];
                    for (o.vertices = this.morphTargets[e].vertices, o.computeFaceNormals(), o.computeVertexNormals(), n = 0, i = this.faces.length; n < i; n++) r = this.faces[n], l = u.faceNormals[n], c = u.vertexNormals[n], l.copy(r.normal), c.a.copy(r.vertexNormals[0]), c.b.copy(r.vertexNormals[1]), c.c.copy(r.vertexNormals[2])
                }
                for (n = 0, i = this.faces.length; n < i; n++)(r = this.faces[n]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
            },
            computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new Uo), this.boundingBox.setFromPoints(this.vertices)
            },
            computeBoundingSphere: function () {
                null === this.boundingSphere && (this.boundingSphere = new Vo), this.boundingSphere.setFromPoints(this.vertices)
            },
            merge: function (e, t, n) {
                if (e && e.isGeometry) {
                    var i, r = this.vertices.length,
                        o = this.vertices,
                        a = e.vertices,
                        s = this.faces,
                        l = e.faces,
                        c = this.colors,
                        u = e.colors;
                    void 0 === n && (n = 0), void 0 !== t && (i = (new Gr).getNormalMatrix(t));
                    for (var h = 0, d = a.length; h < d; h++) {
                        var p = a[h].clone();
                        void 0 !== t && p.applyMatrix4(t), o.push(p)
                    }
                    for (h = 0, d = u.length; h < d; h++) c.push(u[h].clone());
                    for (h = 0, d = l.length; h < d; h++) {
                        var f, m, g, v = l[h],
                            y = v.vertexNormals,
                            x = v.vertexColors;
                        (f = new ba(v.a + r, v.b + r, v.c + r)).normal.copy(v.normal), void 0 !== i && f.normal.applyMatrix3(i).normalize();
                        for (var w = 0, b = y.length; w < b; w++) m = y[w].clone(), void 0 !== i && m.applyMatrix3(i).normalize(), f.vertexNormals.push(m);
                        f.color.copy(v.color);
                        for (w = 0, b = x.length; w < b; w++) g = x[w], f.vertexColors.push(g.clone());
                        f.materialIndex = v.materialIndex + n, s.push(f)
                    }
                    for (h = 0, d = e.faceVertexUvs.length; h < d; h++) {
                        var _ = e.faceVertexUvs[h];
                        void 0 === this.faceVertexUvs[h] && (this.faceVertexUvs[h] = []);
                        for (w = 0, b = _.length; w < b; w++) {
                            for (var M = _[w], T = [], S = 0, E = M.length; S < E; S++) T.push(M[S].clone());
                            this.faceVertexUvs[h].push(T)
                        }
                    }
                } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
            },
            mergeMesh: function (e) {
                e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
            },
            mergeVertices: function () {
                var e, t, n, i, r, o, a, s, l = {},
                    c = [],
                    u = [],
                    h = Math.pow(10, 4);
                for (n = 0, i = this.vertices.length; n < i; n++) e = this.vertices[n], void 0 === l[t = Math.round(e.x * h) + "_" + Math.round(e.y * h) + "_" + Math.round(e.z * h)] ? (l[t] = n, c.push(this.vertices[n]), u[n] = c.length - 1) : u[n] = u[l[t]];
                var d = [];
                for (n = 0, i = this.faces.length; n < i; n++) {
                    (r = this.faces[n]).a = u[r.a], r.b = u[r.b], r.c = u[r.c], o = [r.a, r.b, r.c];
                    for (var p = 0; p < 3; p++)
                        if (o[p] === o[(p + 1) % 3]) {
                            d.push(n);
                            break
                        }
                }
                for (n = d.length - 1; n >= 0; n--) {
                    var f = d[n];
                    for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(f, 1)
                }
                var m = this.vertices.length - c.length;
                return this.vertices = c, m
            },
            setFromPoints: function (e) {
                this.vertices = [];
                for (var t = 0, n = e.length; t < n; t++) {
                    var i = e[t];
                    this.vertices.push(new Kr(i.x, i.y, i.z || 0))
                }
                return this
            },
            sortFacesByMaterialIndex: function () {
                for (var e = this.faces, t = e.length, n = 0; n < t; n++) e[n]._id = n;
                e.sort((function (e, t) {
                    return e.materialIndex - t.materialIndex
                }));
                var i, r, o = this.faceVertexUvs[0],
                    a = this.faceVertexUvs[1];
                o && o.length === t && (i = []), a && a.length === t && (r = []);
                for (n = 0; n < t; n++) {
                    var s = e[n]._id;
                    i && i.push(o[s]), r && r.push(a[s])
                }
                i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r)
            },
            toJSON: function () {
                var e = {
                    metadata: {
                        version: 4.5,
                        type: "Geometry",
                        generator: "Geometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                    var t = this.parameters;
                    for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                    return e
                }
                for (var i = [], r = 0; r < this.vertices.length; r++) {
                    var o = this.vertices[r];
                    i.push(o.x, o.y, o.z)
                }
                var a = [],
                    s = [],
                    l = {},
                    c = [],
                    u = {},
                    h = [],
                    d = {};
                for (r = 0; r < this.faces.length; r++) {
                    var p = this.faces[r],
                        f = void 0 !== this.faceVertexUvs[0][r],
                        m = p.normal.length() > 0,
                        g = p.vertexNormals.length > 0,
                        v = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
                        y = p.vertexColors.length > 0,
                        x = 0;
                    if (x = M(x, 0, 0), x = M(x, 1, !0), x = M(x, 2, !1), x = M(x, 3, f), x = M(x, 4, m), x = M(x, 5, g), x = M(x, 6, v), x = M(x, 7, y), a.push(x), a.push(p.a, p.b, p.c), a.push(p.materialIndex), f) {
                        var w = this.faceVertexUvs[0][r];
                        a.push(E(w[0]), E(w[1]), E(w[2]))
                    }
                    if (m && a.push(T(p.normal)), g) {
                        var b = p.vertexNormals;
                        a.push(T(b[0]), T(b[1]), T(b[2]))
                    }
                    if (v && a.push(S(p.color)), y) {
                        var _ = p.vertexColors;
                        a.push(S(_[0]), S(_[1]), S(_[2]))
                    }
                }

                function M(e, t, n) {
                    return n ? e | 1 << t : e & ~(1 << t)
                }

                function T(e) {
                    var t = e.x.toString() + e.y.toString() + e.z.toString();
                    return void 0 !== l[t] || (l[t] = s.length / 3, s.push(e.x, e.y, e.z)), l[t]
                }

                function S(e) {
                    var t = e.r.toString() + e.g.toString() + e.b.toString();
                    return void 0 !== u[t] || (u[t] = c.length, c.push(e.getHex())), u[t]
                }

                function E(e) {
                    var t = e.x.toString() + e.y.toString();
                    return void 0 !== d[t] || (d[t] = h.length / 2, h.push(e.x, e.y)), d[t]
                }
                return e.data = {}, e.data.vertices = i, e.data.normals = s, c.length > 0 && (e.data.colors = c), h.length > 0 && (e.data.uvs = [h]), e.data.faces = a, e
            },
            clone: function () {
                return (new gs).copy(this)
            },
            copy: function (e) {
                var t, n, i, r, o, a;
                this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                var s = e.vertices;
                for (t = 0, n = s.length; t < n; t++) this.vertices.push(s[t].clone());
                var l = e.colors;
                for (t = 0, n = l.length; t < n; t++) this.colors.push(l[t].clone());
                var c = e.faces;
                for (t = 0, n = c.length; t < n; t++) this.faces.push(c[t].clone());
                for (t = 0, n = e.faceVertexUvs.length; t < n; t++) {
                    var u = e.faceVertexUvs[t];
                    for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), i = 0, r = u.length; i < r; i++) {
                        var h = u[i],
                            d = [];
                        for (o = 0, a = h.length; o < a; o++) {
                            var p = h[o];
                            d.push(p.clone())
                        }
                        this.faceVertexUvs[t].push(d)
                    }
                }
                var f = e.morphTargets;
                for (t = 0, n = f.length; t < n; t++) {
                    var m = {};
                    if (m.name = f[t].name, void 0 !== f[t].vertices)
                        for (m.vertices = [], i = 0, r = f[t].vertices.length; i < r; i++) m.vertices.push(f[t].vertices[i].clone());
                    if (void 0 !== f[t].normals)
                        for (m.normals = [], i = 0, r = f[t].normals.length; i < r; i++) m.normals.push(f[t].normals[i].clone());
                    this.morphTargets.push(m)
                }
                var g = e.morphNormals;
                for (t = 0, n = g.length; t < n; t++) {
                    var v = {};
                    if (void 0 !== g[t].vertexNormals)
                        for (v.vertexNormals = [], i = 0, r = g[t].vertexNormals.length; i < r; i++) {
                            var y = g[t].vertexNormals[i],
                                x = {};
                            x.a = y.a.clone(), x.b = y.b.clone(), x.c = y.c.clone(), v.vertexNormals.push(x)
                        }
                    if (void 0 !== g[t].faceNormals)
                        for (v.faceNormals = [], i = 0, r = g[t].faceNormals.length; i < r; i++) v.faceNormals.push(g[t].faceNormals[i].clone());
                    this.morphNormals.push(v)
                }
                var w = e.skinWeights;
                for (t = 0, n = w.length; t < n; t++) this.skinWeights.push(w[t].clone());
                var b = e.skinIndices;
                for (t = 0, n = b.length; t < n; t++) this.skinIndices.push(b[t].clone());
                var _ = e.lineDistances;
                for (t = 0, n = _.length; t < n; t++) this.lineDistances.push(_[t]);
                var M = e.boundingBox;
                null !== M && (this.boundingBox = M.clone());
                var T = e.boundingSphere;
                return null !== T && (this.boundingSphere = T.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        class vs extends Wa {
            constructor(e, t, n, i, r, o) {
                super(), this.type = "BoxBufferGeometry", this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: o
                };
                var a = this;
                e = e || 1, t = t || 1, n = n || 1, i = Math.floor(i) || 1, r = Math.floor(r) || 1, o = Math.floor(o) || 1;
                var s = [],
                    l = [],
                    c = [],
                    u = [],
                    h = 0,
                    d = 0;

                function p(e, t, n, i, r, o, p, f, m, g, v) {
                    var y, x, w = o / m,
                        b = p / g,
                        _ = o / 2,
                        M = p / 2,
                        T = f / 2,
                        S = m + 1,
                        E = g + 1,
                        A = 0,
                        C = 0,
                        L = new Kr;
                    for (x = 0; x < E; x++) {
                        var P = x * b - M;
                        for (y = 0; y < S; y++) {
                            var R = y * w - _;
                            L[e] = R * i, L[t] = P * r, L[n] = T, l.push(L.x, L.y, L.z), L[e] = 0, L[t] = 0, L[n] = f > 0 ? 1 : -1, c.push(L.x, L.y, L.z), u.push(y / m), u.push(1 - x / g), A += 1
                        }
                    }
                    for (x = 0; x < g; x++)
                        for (y = 0; y < m; y++) {
                            var O = h + y + S * x,
                                D = h + y + S * (x + 1),
                                k = h + (y + 1) + S * (x + 1),
                                N = h + (y + 1) + S * x;
                            s.push(O, D, N), s.push(D, k, N), C += 6
                        }
                    a.addGroup(d, C, v), d += C, h += A
                }
                p("z", "y", "x", -1, -1, n, t, e, o, r, 0), p("z", "y", "x", 1, -1, n, t, -e, o, r, 1), p("x", "z", "y", 1, 1, e, n, t, i, o, 2), p("x", "z", "y", 1, -1, e, n, -t, i, o, 3), p("x", "y", "z", 1, -1, e, t, n, i, r, 4), p("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(s), this.setAttribute("position", new ka(l, 3)), this.setAttribute("normal", new ka(c, 3)), this.setAttribute("uv", new ka(u, 2))
            }
        }

        function ys(e) {
            var t = {};
            for (var n in e)
                for (var i in t[n] = {}, e[n]) {
                    var r = e[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
                }
            return t
        }

        function xs(e) {
            for (var t = {}, n = 0; n < e.length; n++) {
                var i = ys(e[n]);
                for (var r in i) t[r] = i[r]
            }
            return t
        }
        var ws = {
            clone: ys,
            merge: xs
        };

        function bs(e) {
            Ma.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
        }

        function _s() {
            Eo.call(this), this.type = "Camera", this.matrixWorldInverse = new so, this.projectionMatrix = new so, this.projectionMatrixInverse = new so
        }

        function Ms(e, t, n, i) {
            _s.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }
        bs.prototype = Object.create(Ma.prototype), bs.prototype.constructor = bs, bs.prototype.isShaderMaterial = !0, bs.prototype.copy = function (e) {
            return Ma.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ys(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
        }, bs.prototype.toJSON = function (e) {
            var t = Ma.prototype.toJSON.call(this, e);
            for (var n in t.uniforms = {}, this.uniforms) {
                var i = this.uniforms[n].value;
                i && i.isTexture ? t.uniforms[n] = {
                    type: "t",
                    value: i.toJSON(e).uuid
                } : i && i.isColor ? t.uniforms[n] = {
                    type: "c",
                    value: i.getHex()
                } : i && i.isVector2 ? t.uniforms[n] = {
                    type: "v2",
                    value: i.toArray()
                } : i && i.isVector3 ? t.uniforms[n] = {
                    type: "v3",
                    value: i.toArray()
                } : i && i.isVector4 ? t.uniforms[n] = {
                    type: "v4",
                    value: i.toArray()
                } : i && i.isMatrix3 ? t.uniforms[n] = {
                    type: "m3",
                    value: i.toArray()
                } : i && i.isMatrix4 ? t.uniforms[n] = {
                    type: "m4",
                    value: i.toArray()
                } : t.uniforms[n] = {
                    value: i
                }
            }
            Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
            var r = {};
            for (var o in this.extensions) !0 === this.extensions[o] && (r[o] = !0);
            return Object.keys(r).length > 0 && (t.extensions = r), t
        }, _s.prototype = Object.assign(Object.create(Eo.prototype), {
            constructor: _s,
            isCamera: !0,
            copy: function (e, t) {
                return Eo.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
            },
            getWorldDirection: function (e) {
                void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new Kr), this.updateMatrixWorld(!0);
                var t = this.matrixWorld.elements;
                return e.set(-t[8], -t[9], -t[10]).normalize()
            },
            updateMatrixWorld: function (e) {
                Eo.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
            },
            updateWorldMatrix: function (e, t) {
                Eo.prototype.updateWorldMatrix.call(this, e, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            }
        }), Ms.prototype = Object.assign(Object.create(_s.prototype), {
            constructor: Ms,
            isPerspectiveCamera: !0,
            copy: function (e, t) {
                return _s.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
            },
            setFocalLength: function (e) {
                var t = .5 * this.getFilmHeight() / e;
                this.fov = 2 * Ur.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
            },
            getFocalLength: function () {
                var e = Math.tan(.5 * Ur.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / e
            },
            getEffectiveFOV: function () {
                return 2 * Ur.RAD2DEG * Math.atan(Math.tan(.5 * Ur.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function () {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function () {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function (e, t, n, i, r, o) {
                this.aspect = e / t, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
            },
            clearViewOffset: function () {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function () {
                var e = this.near,
                    t = e * Math.tan(.5 * Ur.DEG2RAD * this.fov) / this.zoom,
                    n = 2 * t,
                    i = this.aspect * n,
                    r = -.5 * i,
                    o = this.view;
                if (null !== this.view && this.view.enabled) {
                    var a = o.fullWidth,
                        s = o.fullHeight;
                    r += o.offsetX * i / a, t -= o.offsetY * n / s, i *= o.width / a, n *= o.height / s
                }
                var l = this.filmOffset;
                0 !== l && (r += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
            },
            toJSON: function (e) {
                var t = Eo.prototype.toJSON.call(this, e);
                return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
            }
        });
        var Ts = 90;

        function Ss(e, t, n, i) {
            Eo.call(this), this.type = "CubeCamera";
            var r = new Ms(Ts, 1, e, t);
            r.up.set(0, -1, 0), r.lookAt(new Kr(1, 0, 0)), this.add(r);
            var o = new Ms(Ts, 1, e, t);
            o.up.set(0, -1, 0), o.lookAt(new Kr(-1, 0, 0)), this.add(o);
            var a = new Ms(Ts, 1, e, t);
            a.up.set(0, 0, 1), a.lookAt(new Kr(0, 1, 0)), this.add(a);
            var s = new Ms(Ts, 1, e, t);
            s.up.set(0, 0, -1), s.lookAt(new Kr(0, -1, 0)), this.add(s);
            var l = new Ms(Ts, 1, e, t);
            l.up.set(0, -1, 0), l.lookAt(new Kr(0, 0, 1)), this.add(l);
            var c = new Ms(Ts, 1, e, t);
            c.up.set(0, -1, 0), c.lookAt(new Kr(0, 0, -1)), this.add(c), i = i || {
                format: br,
                magFilter: pr,
                minFilter: pr
            }, this.renderTarget = new Es(n, i), this.renderTarget.texture.name = "CubeCamera", this.update = function (e, t) {
                null === this.parent && this.updateMatrixWorld();
                var n = e.getRenderTarget(),
                    i = this.renderTarget,
                    u = i.texture.generateMipmaps;
                i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0), e.render(t, r), e.setRenderTarget(i, 1), e.render(t, o), e.setRenderTarget(i, 2), e.render(t, a), e.setRenderTarget(i, 3), e.render(t, s), e.setRenderTarget(i, 4), e.render(t, l), i.texture.generateMipmaps = u, e.setRenderTarget(i, 5), e.render(t, c), e.setRenderTarget(n)
            }, this.clear = function (e, t, n, i) {
                for (var r = e.getRenderTarget(), o = this.renderTarget, a = 0; a < 6; a++) e.setRenderTarget(o, a), e.clear(t, n, i);
                e.setRenderTarget(r)
            }
        }

        function Es(e, t, n) {
            Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = n), Xr.call(this, e, e, t)
        }

        function As(e, t, n, i, r, o, a, s, l, c, u, h) {
            qr.call(this, null, o, a, s, l, c, i, r, u, h), this.image = {
                data: e || null,
                width: t || 1,
                height: n || 1
            }, this.magFilter = void 0 !== l ? l : ur, this.minFilter = void 0 !== c ? c : ur, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
        }
        Ss.prototype = Object.create(Eo.prototype), Ss.prototype.constructor = Ss, Es.prototype = Object.create(Xr.prototype), Es.prototype.constructor = Es, Es.prototype.isWebGLCubeRenderTarget = !0, Es.prototype.fromEquirectangularTexture = function (e, t) {
            this.texture.type = t.type, this.texture.format = t.format, this.texture.encoding = t.encoding;
            var n = new Ao,
                i = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "\tvWorldDirection = transformDirection( position, modelMatrix );", "\t#include <begin_vertex>", "\t#include <project_vertex>", "}"].join("\n"),
                    fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#define RECIPROCAL_PI 0.31830988618", "#define RECIPROCAL_PI2 0.15915494", "void main() {", "\tvec3 direction = normalize( vWorldDirection );", "\tvec2 sampleUV;", "\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;", "\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "\tgl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join("\n")
                },
                r = new bs({
                    type: "CubemapFromEquirect",
                    uniforms: ys(i.uniforms),
                    vertexShader: i.vertexShader,
                    fragmentShader: i.fragmentShader,
                    side: 1,
                    blending: 0
                });
            r.uniforms.tEquirect.value = t;
            var o = new cs(new vs(5, 5, 5), r);
            n.add(o);
            var a = new Ss(1, 10, 1);
            return a.renderTarget = this, a.renderTarget.texture.name = "CubeCameraTexture", a.update(e, n), o.geometry.dispose(), o.material.dispose(), this
        }, As.prototype = Object.create(qr.prototype), As.prototype.constructor = As, As.prototype.isDataTexture = !0;
        var Cs = new Vo,
            Ls = new Kr;

        function Ps(e, t, n, i, r, o) {
            this.planes = [void 0 !== e ? e : new na, void 0 !== t ? t : new na, void 0 !== n ? n : new na, void 0 !== i ? i : new na, void 0 !== r ? r : new na, void 0 !== o ? o : new na]
        }
        Object.assign(Ps.prototype, {
            set: function (e, t, n, i, r, o) {
                var a = this.planes;
                return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(o), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                return this
            },
            setFromProjectionMatrix: function (e) {
                var t = this.planes,
                    n = e.elements,
                    i = n[0],
                    r = n[1],
                    o = n[2],
                    a = n[3],
                    s = n[4],
                    l = n[5],
                    c = n[6],
                    u = n[7],
                    h = n[8],
                    d = n[9],
                    p = n[10],
                    f = n[11],
                    m = n[12],
                    g = n[13],
                    v = n[14],
                    y = n[15];
                return t[0].setComponents(a - i, u - s, f - h, y - m).normalize(), t[1].setComponents(a + i, u + s, f + h, y + m).normalize(), t[2].setComponents(a + r, u + l, f + d, y + g).normalize(), t[3].setComponents(a - r, u - l, f - d, y - g).normalize(), t[4].setComponents(a - o, u - c, f - p, y - v).normalize(), t[5].setComponents(a + o, u + c, f + p, y + v).normalize(), this
            },
            intersectsObject: function (e) {
                var t = e.geometry;
                return null === t.boundingSphere && t.computeBoundingSphere(), Cs.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Cs)
            },
            intersectsSprite: function (e) {
                return Cs.center.set(0, 0, 0), Cs.radius = .7071067811865476, Cs.applyMatrix4(e.matrixWorld), this.intersectsSphere(Cs)
            },
            intersectsSphere: function (e) {
                for (var t = this.planes, n = e.center, i = -e.radius, r = 0; r < 6; r++) {
                    if (t[r].distanceToPoint(n) < i) return !1
                }
                return !0
            },
            intersectsBox: function (e) {
                for (var t = this.planes, n = 0; n < 6; n++) {
                    var i = t[n];
                    if (Ls.x = i.normal.x > 0 ? e.max.x : e.min.x, Ls.y = i.normal.y > 0 ? e.max.y : e.min.y, Ls.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Ls) < 0) return !1
                }
                return !0
            },
            containsPoint: function (e) {
                for (var t = this.planes, n = 0; n < 6; n++)
                    if (t[n].distanceToPoint(e) < 0) return !1;
                return !0
            }
        });
        var Rs = {
            common: {
                diffuse: {
                    value: new va(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new Gr
                },
                uv2Transform: {
                    value: new Gr
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new jr(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new va(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }
            },
            points: {
                diffuse: {
                    value: new va(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new Gr
                }
            },
            sprite: {
                diffuse: {
                    value: new va(15658734)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new jr(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new Gr
                }
            }
        };

        function Os() {
            var e = null,
                t = !1,
                n = null;

            function i(r, o) {
                !1 !== t && (n(r, o), e.requestAnimationFrame(i))
            }
            return {
                start: function () {
                    !0 !== t && null !== n && (e.requestAnimationFrame(i), t = !0)
                },
                stop: function () {
                    t = !1
                },
                setAnimationLoop: function (e) {
                    n = e
                },
                setContext: function (t) {
                    e = t
                }
            }
        }

        function Ds(e, t) {
            var n = t.isWebGL2,
                i = new WeakMap;
            return {
                get: function (e) {
                    return e.isInterleavedBufferAttribute && (e = e.data), i.get(e)
                },
                remove: function (t) {
                    t.isInterleavedBufferAttribute && (t = t.data);
                    var n = i.get(t);
                    n && (e.deleteBuffer(n.buffer), i.delete(t))
                },
                update: function (t, r) {
                    t.isInterleavedBufferAttribute && (t = t.data);
                    var o = i.get(t);
                    void 0 === o ? i.set(t, function (t, n) {
                        var i = t.array,
                            r = t.usage,
                            o = e.createBuffer();
                        e.bindBuffer(n, o), e.bufferData(n, i, r), t.onUploadCallback();
                        var a = 5126;
                        return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? a = 5123 : i instanceof Int16Array ? a = 5122 : i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 : i instanceof Int8Array ? a = 5120 : i instanceof Uint8Array && (a = 5121), {
                            buffer: o,
                            type: a,
                            bytesPerElement: i.BYTES_PER_ELEMENT,
                            version: t.version
                        }
                    }(t, r)) : o.version < t.version && (! function (t, i, r) {
                        var o = i.array,
                            a = i.updateRange;
                        e.bindBuffer(r, t), -1 === a.count ? e.bufferSubData(r, 0, o) : (n ? e.bufferSubData(r, a.offset * o.BYTES_PER_ELEMENT, o, a.offset, a.count) : e.bufferSubData(r, a.offset * o.BYTES_PER_ELEMENT, o.subarray(a.offset, a.offset + a.count)), a.count = -1)
                    }(o.buffer, t, r), o.version = t.version)
                }
            }
        }

        function ks(e, t, n, i) {
            gs.call(this), this.type = "PlaneGeometry", this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: i
            }, this.fromBufferGeometry(new Ns(e, t, n, i)), this.mergeVertices()
        }

        function Ns(e, t, n, i) {
            Wa.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: i
            };
            var r, o, a = (e = e || 1) / 2,
                s = (t = t || 1) / 2,
                l = Math.floor(n) || 1,
                c = Math.floor(i) || 1,
                u = l + 1,
                h = c + 1,
                d = e / l,
                p = t / c,
                f = [],
                m = [],
                g = [],
                v = [];
            for (o = 0; o < h; o++) {
                var y = o * p - s;
                for (r = 0; r < u; r++) {
                    var x = r * d - a;
                    m.push(x, -y, 0), g.push(0, 0, 1), v.push(r / l), v.push(1 - o / c)
                }
            }
            for (o = 0; o < c; o++)
                for (r = 0; r < l; r++) {
                    var w = r + u * o,
                        b = r + u * (o + 1),
                        _ = r + 1 + u * (o + 1),
                        M = r + 1 + u * o;
                    f.push(w, b, M), f.push(b, _, M)
                }
            this.setIndex(f), this.setAttribute("position", new ka(m, 3)), this.setAttribute("normal", new ka(g, 3)), this.setAttribute("uv", new ka(v, 2))
        }
        ks.prototype = Object.create(gs.prototype), ks.prototype.constructor = ks, Ns.prototype = Object.create(Wa.prototype), Ns.prototype.constructor = Ns;
        var Is = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
            normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
            uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
        },
            zs = {
                basic: {
                    uniforms: xs([Rs.common, Rs.specularmap, Rs.envmap, Rs.aomap, Rs.lightmap, Rs.fog]),
                    vertexShader: Is.meshbasic_vert,
                    fragmentShader: Is.meshbasic_frag
                },
                lambert: {
                    uniforms: xs([Rs.common, Rs.specularmap, Rs.envmap, Rs.aomap, Rs.lightmap, Rs.emissivemap, Rs.fog, Rs.lights, {
                        emissive: {
                            value: new va(0)
                        }
                    }]),
                    vertexShader: Is.meshlambert_vert,
                    fragmentShader: Is.meshlambert_frag
                },
                phong: {
                    uniforms: xs([Rs.common, Rs.specularmap, Rs.envmap, Rs.aomap, Rs.lightmap, Rs.emissivemap, Rs.bumpmap, Rs.normalmap, Rs.displacementmap, Rs.fog, Rs.lights, {
                        emissive: {
                            value: new va(0)
                        },
                        specular: {
                            value: new va(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: Is.meshphong_vert,
                    fragmentShader: Is.meshphong_frag
                },
                standard: {
                    uniforms: xs([Rs.common, Rs.envmap, Rs.aomap, Rs.lightmap, Rs.emissivemap, Rs.bumpmap, Rs.normalmap, Rs.displacementmap, Rs.roughnessmap, Rs.metalnessmap, Rs.fog, Rs.lights, {
                        emissive: {
                            value: new va(0)
                        },
                        roughness: {
                            value: .5
                        },
                        metalness: {
                            value: .5
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Is.meshphysical_vert,
                    fragmentShader: Is.meshphysical_frag
                },
                toon: {
                    uniforms: xs([Rs.common, Rs.specularmap, Rs.aomap, Rs.lightmap, Rs.emissivemap, Rs.bumpmap, Rs.normalmap, Rs.displacementmap, Rs.gradientmap, Rs.fog, Rs.lights, {
                        emissive: {
                            value: new va(0)
                        },
                        specular: {
                            value: new va(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: Is.meshtoon_vert,
                    fragmentShader: Is.meshtoon_frag
                },
                matcap: {
                    uniforms: xs([Rs.common, Rs.bumpmap, Rs.normalmap, Rs.displacementmap, Rs.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: Is.meshmatcap_vert,
                    fragmentShader: Is.meshmatcap_frag
                },
                points: {
                    uniforms: xs([Rs.points, Rs.fog]),
                    vertexShader: Is.points_vert,
                    fragmentShader: Is.points_frag
                },
                dashed: {
                    uniforms: xs([Rs.common, Rs.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: Is.linedashed_vert,
                    fragmentShader: Is.linedashed_frag
                },
                depth: {
                    uniforms: xs([Rs.common, Rs.displacementmap]),
                    vertexShader: Is.depth_vert,
                    fragmentShader: Is.depth_frag
                },
                normal: {
                    uniforms: xs([Rs.common, Rs.bumpmap, Rs.normalmap, Rs.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Is.normal_vert,
                    fragmentShader: Is.normal_frag
                },
                sprite: {
                    uniforms: xs([Rs.sprite, Rs.fog]),
                    vertexShader: Is.sprite_vert,
                    fragmentShader: Is.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new Gr
                        },
                        t2D: {
                            value: null
                        }
                    },
                    vertexShader: Is.background_vert,
                    fragmentShader: Is.background_frag
                },
                cube: {
                    uniforms: xs([Rs.envmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Is.cube_vert,
                    fragmentShader: Is.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: Is.equirect_vert,
                    fragmentShader: Is.equirect_frag
                },
                distanceRGBA: {
                    uniforms: xs([Rs.common, Rs.displacementmap, {
                        referencePosition: {
                            value: new Kr
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: Is.distanceRGBA_vert,
                    fragmentShader: Is.distanceRGBA_frag
                },
                shadow: {
                    uniforms: xs([Rs.lights, Rs.fog, {
                        color: {
                            value: new va(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Is.shadow_vert,
                    fragmentShader: Is.shadow_frag
                }
            };

        function Fs(e, t, n, i) {
            var r, o, a = new va(0),
                s = 0,
                l = null,
                c = 0,
                u = null;

            function h(e, n) {
                t.buffers.color.setClear(e.r, e.g, e.b, n, i)
            }
            return {
                getClearColor: function () {
                    return a
                },
                setClearColor: function (e, t) {
                    a.set(e), h(a, s = void 0 !== t ? t : 1)
                },
                getClearAlpha: function () {
                    return s
                },
                setClearAlpha: function (e) {
                    h(a, s = e)
                },
                render: function (t, i, d, p) {
                    var f = i.background,
                        m = e.xr,
                        g = m.getSession && m.getSession();
                    if (g && "additive" === g.environmentBlendMode && (f = null), null === f ? h(a, s) : f && f.isColor && (h(f, 1), p = !0), (e.autoClear || p) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), f && (f.isCubeTexture || f.isWebGLCubeRenderTarget || f.mapping === ar)) {
                        void 0 === o && ((o = new cs(new vs(1, 1, 1), new bs({
                            type: "BackgroundCubeMaterial",
                            uniforms: ys(zs.cube.uniforms),
                            vertexShader: zs.cube.vertexShader,
                            fragmentShader: zs.cube.fragmentShader,
                            side: 1,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function (e, t, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, Object.defineProperty(o.material, "envMap", {
                            get: function () {
                                return this.uniforms.envMap.value
                            }
                        }), n.update(o));
                        var v = f.isWebGLCubeRenderTarget ? f.texture : f;
                        o.material.uniforms.envMap.value = v, o.material.uniforms.flipEnvMap.value = v.isCubeTexture ? -1 : 1, l === f && c === v.version && u === e.toneMapping || (o.material.needsUpdate = !0, l = f, c = v.version, u = e.toneMapping), t.unshift(o, o.geometry, o.material, 0, 0, null)
                    } else f && f.isTexture && (void 0 === r && ((r = new cs(new Ns(2, 2), new bs({
                        type: "BackgroundMaterial",
                        uniforms: ys(zs.background.uniforms),
                        vertexShader: zs.background.vertexShader,
                        fragmentShader: zs.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.deleteAttribute("normal"), Object.defineProperty(r.material, "map", {
                        get: function () {
                            return this.uniforms.t2D.value
                        }
                    }), n.update(r)), r.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), r.material.uniforms.uvTransform.value.copy(f.matrix), l === f && c === f.version && u === e.toneMapping || (r.material.needsUpdate = !0, l = f, c = f.version, u = e.toneMapping), t.unshift(r, r.geometry, r.material, 0, 0, null))
                }
            }
        }

        function Hs(e, t, n, i) {
            var r, o = i.isWebGL2;
            this.setMode = function (e) {
                r = e
            }, this.render = function (t, i) {
                e.drawArrays(r, t, i), n.update(i, r)
            }, this.renderInstances = function (i, a, s, l) {
                if (0 !== l) {
                    var c, u;
                    if (o) c = e, u = "drawArraysInstanced";
                    else if (u = "drawArraysInstancedANGLE", null === (c = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    c[u](r, a, s, l), n.update(s, r, l)
                }
            }
        }

        function Bs(e, t, n) {
            var i;

            function r(t) {
                if ("highp" === t) {
                    if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                    t = "mediump"
                }
                return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
            }
            var o = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext,
                a = void 0 !== n.precision ? n.precision : "highp",
                s = r(a);
            s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
            var l = !0 === n.logarithmicDepthBuffer,
                c = e.getParameter(34930),
                u = e.getParameter(35660),
                h = e.getParameter(3379),
                d = e.getParameter(34076),
                p = e.getParameter(34921),
                f = e.getParameter(36347),
                m = e.getParameter(36348),
                g = e.getParameter(36349),
                v = u > 0,
                y = o || !!t.get("OES_texture_float");
            return {
                isWebGL2: o,
                getMaxAnisotropy: function () {
                    if (void 0 !== i) return i;
                    var n = t.get("EXT_texture_filter_anisotropic");
                    return i = null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                },
                getMaxPrecision: r,
                precision: a,
                logarithmicDepthBuffer: l,
                maxTextures: c,
                maxVertexTextures: u,
                maxTextureSize: h,
                maxCubemapSize: d,
                maxAttributes: p,
                maxVertexUniforms: f,
                maxVaryings: m,
                maxFragmentUniforms: g,
                vertexTextures: v,
                floatFragmentTextures: y,
                floatVertexTextures: v && y,
                maxSamples: o ? e.getParameter(36183) : 0
            }
        }

        function Us() {
            var e = this,
                t = null,
                n = 0,
                i = !1,
                r = !1,
                o = new na,
                a = new Gr,
                s = {
                    value: null,
                    needsUpdate: !1
                };

            function l() {
                s.value !== t && (s.value = t, s.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0
            }

            function c(t, n, i, r) {
                var l = null !== t ? t.length : 0,
                    c = null;
                if (0 !== l) {
                    if (c = s.value, !0 !== r || null === c) {
                        var u = i + 4 * l,
                            h = n.matrixWorldInverse;
                        a.getNormalMatrix(h), (null === c || c.length < u) && (c = new Float32Array(u));
                        for (var d = 0, p = i; d !== l; ++d, p += 4) o.copy(t[d]).applyMatrix4(h, a), o.normal.toArray(c, p), c[p + 3] = o.constant
                    }
                    s.value = c, s.needsUpdate = !0
                }
                return e.numPlanes = l, e.numIntersection = 0, c
            }
            this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, r, o) {
                var a = 0 !== e.length || r || 0 !== n || i;
                return i = r, t = c(e, o, 0), n = e.length, a
            }, this.beginShadows = function () {
                r = !0, c(null)
            }, this.endShadows = function () {
                r = !1, l()
            }, this.setState = function (e, o, a, u, h, d) {
                if (!i || null === e || 0 === e.length || r && !a) r ? c(null) : l();
                else {
                    var p = r ? 0 : n,
                        f = 4 * p,
                        m = h.clippingState || null;
                    s.value = m, m = c(e, u, f, d);
                    for (var g = 0; g !== f; ++g) m[g] = t[g];
                    h.clippingState = m, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += p
                }
            }
        }

        function js(e) {
            var t = {};
            return {
                get: function (n) {
                    if (void 0 !== t[n]) return t[n];
                    var i;
                    switch (n) {
                        case "WEBGL_depth_texture":
                            i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            i = e.getExtension(n)
                    }
                    return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), t[n] = i, i
                }
            }
        }

        function Gs(e, t, n) {
            var i = new WeakMap,
                r = new WeakMap;

            function o(e) {
                var a = e.target,
                    s = i.get(a);
                for (var l in null !== s.index && t.remove(s.index), s.attributes) t.remove(s.attributes[l]);
                a.removeEventListener("dispose", o), i.delete(a);
                var c = r.get(s);
                c && (t.remove(c), r.delete(s)), n.memory.geometries--
            }

            function a(e) {
                var n = [],
                    i = e.index,
                    o = e.attributes.position,
                    a = 0;
                if (null !== i) {
                    var s = i.array;
                    a = i.version;
                    for (var l = 0, c = s.length; l < c; l += 3) {
                        var u = s[l + 0],
                            h = s[l + 1],
                            d = s[l + 2];
                        n.push(u, h, h, d, d, u)
                    }
                } else {
                    s = o.array;
                    a = o.version;
                    for (l = 0, c = s.length / 3 - 1; l < c; l += 3) {
                        u = l + 0, h = l + 1, d = l + 2;
                        n.push(u, h, h, d, d, u)
                    }
                }
                var p = new (za(n) > 65535 ? Da : Ra)(n, 1);
                p.version = a, t.update(p, 34963);
                var f = r.get(e);
                f && t.remove(f), r.set(e, p)
            }
            return {
                get: function (e, t) {
                    var r = i.get(t);
                    return r || (t.addEventListener("dispose", o), t.isBufferGeometry ? r = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new Wa).setFromObject(e)), r = t._bufferGeometry), i.set(t, r), n.memory.geometries++, r)
                },
                update: function (e) {
                    var n = e.index,
                        i = e.attributes;
                    for (var r in null !== n && t.update(n, 34963), i) t.update(i[r], 34962);
                    var o = e.morphAttributes;
                    for (var r in o)
                        for (var a = o[r], s = 0, l = a.length; s < l; s++) t.update(a[s], 34962)
                },
                getWireframeAttribute: function (e) {
                    var t = r.get(e);
                    if (t) {
                        var n = e.index;
                        null !== n && t.version < n.version && a(e)
                    } else a(e);
                    return r.get(e)
                }
            }
        }

        function Vs(e, t, n, i) {
            var r, o, a, s = i.isWebGL2;
            this.setMode = function (e) {
                r = e
            }, this.setIndex = function (e) {
                o = e.type, a = e.bytesPerElement
            }, this.render = function (t, i) {
                e.drawElements(r, i, o, t * a), n.update(i, r)
            }, this.renderInstances = function (i, l, c, u) {
                if (0 !== u) {
                    var h, d;
                    if (s) h = e, d = "drawElementsInstanced";
                    else if (d = "drawElementsInstancedANGLE", null === (h = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    h[d](r, c, o, l * a, u), n.update(c, r, u)
                }
            }
        }

        function Ws(e) {
            var t = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: t,
                programs: null,
                autoReset: !0,
                reset: function () {
                    t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
                },
                update: function (e, n, i) {
                    switch (i = i || 1, t.calls++, n) {
                        case 4:
                            t.triangles += i * (e / 3);
                            break;
                        case 1:
                            t.lines += i * (e / 2);
                            break;
                        case 3:
                            t.lines += i * (e - 1);
                            break;
                        case 2:
                            t.lines += i * e;
                            break;
                        case 0:
                            t.points += i * e;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                    }
                }
            }
        }

        function qs(e, t) {
            return Math.abs(t[1]) - Math.abs(e[1])
        }

        function $s(e) {
            var t = {},
                n = new Float32Array(8);
            return {
                update: function (i, r, o, a) {
                    var s = i.morphTargetInfluences,
                        l = void 0 === s ? 0 : s.length,
                        c = t[r.id];
                    if (void 0 === c) {
                        c = [];
                        for (var u = 0; u < l; u++) c[u] = [u, 0];
                        t[r.id] = c
                    }
                    var h = o.morphTargets && r.morphAttributes.position,
                        d = o.morphNormals && r.morphAttributes.normal;
                    for (u = 0; u < l; u++) {
                        0 !== (f = c[u])[1] && (h && r.deleteAttribute("morphTarget" + u), d && r.deleteAttribute("morphNormal" + u))
                    }
                    for (u = 0; u < l; u++) {
                        (f = c[u])[0] = u, f[1] = s[u]
                    }
                    c.sort(qs);
                    var p = 0;
                    for (u = 0; u < 8; u++) {
                        var f;
                        if (f = c[u]) {
                            var m = f[0],
                                g = f[1];
                            if (g) {
                                h && r.setAttribute("morphTarget" + u, h[m]), d && r.setAttribute("morphNormal" + u, d[m]), n[u] = g, p += g;
                                continue
                            }
                        }
                        n[u] = 0
                    }
                    var v = r.morphTargetsRelative ? 1 : 1 - p;
                    a.getUniforms().setValue(e, "morphTargetBaseInfluence", v), a.getUniforms().setValue(e, "morphTargetInfluences", n)
                }
            }
        }

        function Xs(e, t, n, i) {
            var r = new WeakMap;
            return {
                update: function (e) {
                    var o = i.render.frame,
                        a = e.geometry,
                        s = t.get(e, a);
                    return r.get(s) !== o && (a.isGeometry && s.updateFromObject(e), t.update(s), r.set(s, o)), e.isInstancedMesh && n.update(e.instanceMatrix, 34962), s
                },
                dispose: function () {
                    r = new WeakMap
                }
            }
        }

        function Ys(e, t, n, i, r, o, a, s, l, c) {
            e = void 0 !== e ? e : [], t = void 0 !== t ? t : 301, a = void 0 !== a ? a : br, qr.call(this, e, t, n, i, r, o, a, s, l, c), this.flipY = !1
        }

        function Zs(e, t, n, i) {
            qr.call(this, null), this.image = {
                data: e || null,
                width: t || 1,
                height: n || 1,
                depth: i || 1
            }, this.magFilter = ur, this.minFilter = ur, this.wrapR = lr, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
        }

        function Js(e, t, n, i) {
            qr.call(this, null), this.image = {
                data: e || null,
                width: t || 1,
                height: n || 1,
                depth: i || 1
            }, this.magFilter = ur, this.minFilter = ur, this.wrapR = lr, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
        }
        zs.physical = {
            uniforms: xs([zs.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new jr(1, 1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheen: {
                    value: new va(0)
                },
                transparency: {
                    value: 0
                }
            }]),
            vertexShader: Is.meshphysical_vert,
            fragmentShader: Is.meshphysical_frag
        }, Ys.prototype = Object.create(qr.prototype), Ys.prototype.constructor = Ys, Ys.prototype.isCubeTexture = !0, Object.defineProperty(Ys.prototype, "images", {
            get: function () {
                return this.image
            },
            set: function (e) {
                this.image = e
            }
        }), Zs.prototype = Object.create(qr.prototype), Zs.prototype.constructor = Zs, Zs.prototype.isDataTexture2DArray = !0, Js.prototype = Object.create(qr.prototype), Js.prototype.constructor = Js, Js.prototype.isDataTexture3D = !0;
        var Qs = new qr,
            Ks = new Zs,
            el = new Js,
            tl = new Ys,
            nl = [],
            il = [],
            rl = new Float32Array(16),
            ol = new Float32Array(9),
            al = new Float32Array(4);

        function sl(e, t, n) {
            var i = e[0];
            if (i <= 0 || i > 0) return e;
            var r = t * n,
                o = nl[r];
            if (void 0 === o && (o = new Float32Array(r), nl[r] = o), 0 !== t) {
                i.toArray(o, 0);
                for (var a = 1, s = 0; a !== t; ++a) s += n, e[a].toArray(o, s)
            }
            return o
        }

        function ll(e, t) {
            if (e.length !== t.length) return !1;
            for (var n = 0, i = e.length; n < i; n++)
                if (e[n] !== t[n]) return !1;
            return !0
        }

        function cl(e, t) {
            for (var n = 0, i = t.length; n < i; n++) e[n] = t[n]
        }

        function ul(e, t) {
            var n = il[t];
            void 0 === n && (n = new Int32Array(t), il[t] = n);
            for (var i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
            return n
        }

        function hl(e, t) {
            var n = this.cache;
            n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
        }

        function dl(e, t) {
            var n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
            else {
                if (ll(n, t)) return;
                e.uniform2fv(this.addr, t), cl(n, t)
            }
        }

        function pl(e, t) {
            var n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
            else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
            else {
                if (ll(n, t)) return;
                e.uniform3fv(this.addr, t), cl(n, t)
            }
        }

        function fl(e, t) {
            var n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
            else {
                if (ll(n, t)) return;
                e.uniform4fv(this.addr, t), cl(n, t)
            }
        }

        function ml(e, t) {
            var n = this.cache,
                i = t.elements;
            if (void 0 === i) {
                if (ll(n, t)) return;
                e.uniformMatrix2fv(this.addr, !1, t), cl(n, t)
            } else {
                if (ll(n, i)) return;
                al.set(i), e.uniformMatrix2fv(this.addr, !1, al), cl(n, i)
            }
        }

        function gl(e, t) {
            var n = this.cache,
                i = t.elements;
            if (void 0 === i) {
                if (ll(n, t)) return;
                e.uniformMatrix3fv(this.addr, !1, t), cl(n, t)
            } else {
                if (ll(n, i)) return;
                ol.set(i), e.uniformMatrix3fv(this.addr, !1, ol), cl(n, i)
            }
        }

        function vl(e, t) {
            var n = this.cache,
                i = t.elements;
            if (void 0 === i) {
                if (ll(n, t)) return;
                e.uniformMatrix4fv(this.addr, !1, t), cl(n, t)
            } else {
                if (ll(n, i)) return;
                rl.set(i), e.uniformMatrix4fv(this.addr, !1, rl), cl(n, i)
            }
        }

        function yl(e, t, n) {
            var i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(t || Qs, r)
        }

        function xl(e, t, n) {
            var i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || Ks, r)
        }

        function wl(e, t, n) {
            var i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || el, r)
        }

        function bl(e, t, n) {
            var i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(t || tl, r)
        }

        function _l(e, t) {
            var n = this.cache;
            n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
        }

        function Ml(e, t) {
            var n = this.cache;
            ll(n, t) || (e.uniform2iv(this.addr, t), cl(n, t))
        }

        function Tl(e, t) {
            var n = this.cache;
            ll(n, t) || (e.uniform3iv(this.addr, t), cl(n, t))
        }

        function Sl(e, t) {
            var n = this.cache;
            ll(n, t) || (e.uniform4iv(this.addr, t), cl(n, t))
        }

        function El(e, t) {
            var n = this.cache;
            n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
        }

        function Al(e, t) {
            e.uniform1fv(this.addr, t)
        }

        function Cl(e, t) {
            e.uniform1iv(this.addr, t)
        }

        function Ll(e, t) {
            e.uniform2iv(this.addr, t)
        }

        function Pl(e, t) {
            e.uniform3iv(this.addr, t)
        }

        function Rl(e, t) {
            e.uniform4iv(this.addr, t)
        }

        function Ol(e, t) {
            var n = sl(t, this.size, 2);
            e.uniform2fv(this.addr, n)
        }

        function Dl(e, t) {
            var n = sl(t, this.size, 3);
            e.uniform3fv(this.addr, n)
        }

        function kl(e, t) {
            var n = sl(t, this.size, 4);
            e.uniform4fv(this.addr, n)
        }

        function Nl(e, t) {
            var n = sl(t, this.size, 4);
            e.uniformMatrix2fv(this.addr, !1, n)
        }

        function Il(e, t) {
            var n = sl(t, this.size, 9);
            e.uniformMatrix3fv(this.addr, !1, n)
        }

        function zl(e, t) {
            var n = sl(t, this.size, 16);
            e.uniformMatrix4fv(this.addr, !1, n)
        }

        function Fl(e, t, n) {
            var i = t.length,
                r = ul(n, i);
            e.uniform1iv(this.addr, r);
            for (var o = 0; o !== i; ++o) n.safeSetTexture2D(t[o] || Qs, r[o])
        }

        function Hl(e, t, n) {
            var i = t.length,
                r = ul(n, i);
            e.uniform1iv(this.addr, r);
            for (var o = 0; o !== i; ++o) n.safeSetTextureCube(t[o] || tl, r[o])
        }

        function Bl(e, t, n) {
            this.id = e, this.addr = n, this.cache = [], this.setValue = function (e) {
                switch (e) {
                    case 5126:
                        return hl;
                    case 35664:
                        return dl;
                    case 35665:
                        return pl;
                    case 35666:
                        return fl;
                    case 35674:
                        return ml;
                    case 35675:
                        return gl;
                    case 35676:
                        return vl;
                    case 5124:
                    case 35670:
                        return _l;
                    case 35667:
                    case 35671:
                        return Ml;
                    case 35668:
                    case 35672:
                        return Tl;
                    case 35669:
                    case 35673:
                        return Sl;
                    case 5125:
                        return El;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return yl;
                    case 35679:
                    case 36299:
                    case 36307:
                        return wl;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return bl;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return xl
                }
            }(t.type)
        }

        function Ul(e, t, n) {
            this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function (e) {
                switch (e) {
                    case 5126:
                        return Al;
                    case 35664:
                        return Ol;
                    case 35665:
                        return Dl;
                    case 35666:
                        return kl;
                    case 35674:
                        return Nl;
                    case 35675:
                        return Il;
                    case 35676:
                        return zl;
                    case 5124:
                    case 35670:
                        return Cl;
                    case 35667:
                    case 35671:
                        return Ll;
                    case 35668:
                    case 35672:
                        return Pl;
                    case 35669:
                    case 35673:
                        return Rl;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Fl;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Hl
                }
            }(t.type)
        }

        function jl(e) {
            this.id = e, this.seq = [], this.map = {}
        }
        Ul.prototype.updateCache = function (e) {
            var t = this.cache;
            e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), cl(t, e)
        }, jl.prototype.setValue = function (e, t, n) {
            for (var i = this.seq, r = 0, o = i.length; r !== o; ++r) {
                var a = i[r];
                a.setValue(e, t[a.id], n)
            }
        };
        var Gl = /([\w\d_]+)(\])?(\[|\.)?/g;

        function Vl(e, t) {
            e.seq.push(t), e.map[t.id] = t
        }

        function Wl(e, t, n) {
            var i = e.name,
                r = i.length;
            for (Gl.lastIndex = 0; ;) {
                var o = Gl.exec(i),
                    a = Gl.lastIndex,
                    s = o[1],
                    l = "]" === o[2],
                    c = o[3];
                if (l && (s |= 0), void 0 === c || "[" === c && a + 2 === r) {
                    Vl(n, void 0 === c ? new Bl(s, e, t) : new Ul(s, e, t));
                    break
                }
                var u = n.map[s];
                void 0 === u && Vl(n, u = new jl(s)), n = u
            }
        }

        function ql(e, t) {
            this.seq = [], this.map = {};
            for (var n = e.getProgramParameter(t, 35718), i = 0; i < n; ++i) {
                var r = e.getActiveUniform(t, i);
                Wl(r, e.getUniformLocation(t, r.name), this)
            }
        }

        function $l(e, t, n) {
            var i = e.createShader(t);
            return e.shaderSource(i, n), e.compileShader(i), i
        }
        ql.prototype.setValue = function (e, t, n, i) {
            var r = this.map[t];
            void 0 !== r && r.setValue(e, n, i)
        }, ql.prototype.setOptional = function (e, t, n) {
            var i = t[n];
            void 0 !== i && this.setValue(e, n, i)
        }, ql.upload = function (e, t, n, i) {
            for (var r = 0, o = t.length; r !== o; ++r) {
                var a = t[r],
                    s = n[a.id];
                !1 !== s.needsUpdate && a.setValue(e, s.value, i)
            }
        }, ql.seqWithValue = function (e, t) {
            for (var n = [], i = 0, r = e.length; i !== r; ++i) {
                var o = e[i];
                o.id in t && n.push(o)
            }
            return n
        };
        var Xl = 0;

        function Yl(e) {
            switch (e) {
                case Rr:
                    return ["Linear", "( value )"];
                case Or:
                    return ["sRGB", "( value )"];
                case Dr:
                    return ["RGBE", "( value )"];
                case 3004:
                    return ["RGBM", "( value, 7.0 )"];
                case 3005:
                    return ["RGBM", "( value, 16.0 )"];
                case 3006:
                    return ["RGBD", "( value, 256.0 )"];
                case 3007:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                case 3003:
                    return ["LogLuv", "( value )"];
                default:
                    throw new Error("unsupported encoding: " + e)
            }
        }

        function Zl(e, t, n) {
            var i = e.getShaderParameter(t, 35713),
                r = e.getShaderInfoLog(t).trim();
            return i && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function (e) {
                for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
                return t.join("\n")
            }(e.getShaderSource(t))
        }

        function Jl(e, t) {
            var n = Yl(t);
            return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
        }

        function Ql(e, t) {
            var n;
            switch (t) {
                case 1:
                    n = "Linear";
                    break;
                case 2:
                    n = "Reinhard";
                    break;
                case 3:
                    n = "Uncharted2";
                    break;
                case 4:
                    n = "OptimizedCineon";
                    break;
                case 5:
                    n = "ACESFilmic";
                    break;
                default:
                    throw new Error("unsupported toneMapping: " + t)
            }
            return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function Kl(e) {
            return "" !== e
        }

        function ec(e, t) {
            return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
        }

        function tc(e, t) {
            return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
        }
        var nc = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function ic(e) {
            return e.replace(nc, rc)
        }

        function rc(e, t) {
            var n = Is[t];
            if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
            return ic(n)
        }
        var oc = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
            ac = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;

        function sc(e) {
            return e.replace(ac, cc).replace(oc, lc)
        }

        function lc(e, t, n, i) {
            return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), cc(e, t, n, i)
        }

        function cc(e, t, n, i) {
            for (var r = "", o = parseInt(t); o < parseInt(n); o++) r += i.replace(/\[ i \]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
            return r
        }

        function uc(e) {
            var t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
            return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
        }

        function hc(e, t, n) {
            var i, r, o, a, s, l = e.getContext(),
                c = n.defines,
                u = n.vertexShader,
                h = n.fragmentShader,
                d = function (e) {
                    var t = "SHADOWMAP_TYPE_BASIC";
                    return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t
                }(n),
                p = function (e) {
                    var t = "ENVMAP_TYPE_CUBE";
                    if (e.envMap) switch (e.envMapMode) {
                        case 301:
                        case 302:
                            t = "ENVMAP_TYPE_CUBE";
                            break;
                        case ar:
                        case 307:
                            t = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case 303:
                        case 304:
                            t = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case 305:
                            t = "ENVMAP_TYPE_SPHERE"
                    }
                    return t
                }(n),
                f = function (e) {
                    var t = "ENVMAP_MODE_REFLECTION";
                    if (e.envMap) switch (e.envMapMode) {
                        case 302:
                        case 304:
                            t = "ENVMAP_MODE_REFRACTION"
                    }
                    return t
                }(n),
                m = function (e) {
                    var t = "ENVMAP_BLENDING_NONE";
                    if (e.envMap) switch (e.combine) {
                        case 0:
                            t = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case 1:
                            t = "ENVMAP_BLENDING_MIX";
                            break;
                        case 2:
                            t = "ENVMAP_BLENDING_ADD"
                    }
                    return t
                }(n),
                g = e.gammaFactor > 0 ? e.gammaFactor : 1,
                v = n.isWebGL2 ? "" : function (e) {
                    return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Kl).join("\n")
                }(n),
                y = function (e) {
                    var t = [];
                    for (var n in e) {
                        var i = e[n];
                        !1 !== i && t.push("#define " + n + " " + i)
                    }
                    return t.join("\n")
                }(c),
                x = l.createProgram();
            if (n.isRawShaderMaterial ? ((i = [y].filter(Kl).join("\n")).length > 0 && (i += "\n"), (r = [v, y].filter(Kl).join("\n")).length > 0 && (r += "\n")) : (i = [uc(n), "#define SHADER_NAME " + n.shaderName, y, n.instancing ? "#define USE_INSTANCING" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + g, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + f : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Kl).join("\n"), r = [v, uc(n), "#define SHADER_NAME " + n.shaderName, y, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + f : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Is.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Ql("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.outputEncoding || n.mapEncoding || n.matcapEncoding || n.envMapEncoding || n.emissiveMapEncoding || n.lightMapEncoding ? Is.encodings_pars_fragment : "", n.mapEncoding ? Jl("mapTexelToLinear", n.mapEncoding) : "", n.matcapEncoding ? Jl("matcapTexelToLinear", n.matcapEncoding) : "", n.envMapEncoding ? Jl("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMapEncoding ? Jl("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMapEncoding ? Jl("lightMapTexelToLinear", n.lightMapEncoding) : "", n.outputEncoding ? (o = "linearToOutputTexel", a = n.outputEncoding, s = Yl(a), "vec4 " + o + "( vec4 value ) { return LinearTo" + s[0] + s[1] + "; }") : "", n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Kl).join("\n")), u = tc(u = ec(u = ic(u), n), n), h = tc(h = ec(h = ic(h), n), n), u = sc(u), h = sc(h), n.isWebGL2 && !n.isRawShaderMaterial) {
                var w = !1,
                    b = /^\s*#version\s+300\s+es\s*\n/;
                n.isShaderMaterial && null !== u.match(b) && null !== h.match(b) && (w = !0, u = u.replace(b, ""), h = h.replace(b, "")), i = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + i, r = ["#version 300 es\n", "#define varying in", w ? "" : "out highp vec4 pc_fragColor;", w ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + r
            }
            var _, M, T = r + h,
                S = $l(l, 35633, i + u),
                E = $l(l, 35632, T);
            if (l.attachShader(x, S), l.attachShader(x, E), void 0 !== n.index0AttributeName ? l.bindAttribLocation(x, 0, n.index0AttributeName) : !0 === n.morphTargets && l.bindAttribLocation(x, 0, "position"), l.linkProgram(x), e.debug.checkShaderErrors) {
                var A = l.getProgramInfoLog(x).trim(),
                    C = l.getShaderInfoLog(S).trim(),
                    L = l.getShaderInfoLog(E).trim(),
                    P = !0,
                    R = !0;
                if (!1 === l.getProgramParameter(x, 35714)) {
                    P = !1;
                    var O = Zl(l, S, "vertex"),
                        D = Zl(l, E, "fragment");
                    console.error("THREE.WebGLProgram: shader error: ", l.getError(), "35715", l.getProgramParameter(x, 35715), "gl.getProgramInfoLog", A, O, D)
                } else "" !== A ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", A) : "" !== C && "" !== L || (R = !1);
                R && (this.diagnostics = {
                    runnable: P,
                    programLog: A,
                    vertexShader: {
                        log: C,
                        prefix: i
                    },
                    fragmentShader: {
                        log: L,
                        prefix: r
                    }
                })
            }
            return l.detachShader(x, S), l.detachShader(x, E), l.deleteShader(S), l.deleteShader(E), this.getUniforms = function () {
                return void 0 === _ && (_ = new ql(l, x)), _
            }, this.getAttributes = function () {
                return void 0 === M && (M = function (e, t) {
                    for (var n = {}, i = e.getProgramParameter(t, 35721), r = 0; r < i; r++) {
                        var o = e.getActiveAttrib(t, r).name;
                        n[o] = e.getAttribLocation(t, o)
                    }
                    return n
                }(l, x)), M
            }, this.destroy = function () {
                l.deleteProgram(x), this.program = void 0
            }, this.name = n.shaderName, this.id = Xl++, this.cacheKey = t, this.usedTimes = 1, this.program = x, this.vertexShader = S, this.fragmentShader = E, this
        }

        function dc(e, t, n) {
            var i = [],
                r = n.isWebGL2,
                o = n.logarithmicDepthBuffer,
                a = n.floatVertexTextures,
                s = n.precision,
                l = n.maxVertexUniforms,
                c = n.vertexTextures,
                u = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                },
                h = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];

            function d(e) {
                var t;
                return e ? e.isTexture ? t = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding) : t = Rr, t
            }
            this.getParameters = function (i, h, p, f, m, g, v) {
                var y = f.fog,
                    x = i.isMeshStandardMaterial ? f.environment : null,
                    w = i.envMap || x,
                    b = u[i.type],
                    _ = v.isSkinnedMesh ? function (e) {
                        var t = e.skeleton.bones;
                        if (a) return 1024;
                        var n = l,
                            i = Math.floor((n - 20) / 4),
                            r = Math.min(i, t.length);
                        return r < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + r + "."), 0) : r
                    }(v) : 0;
                null !== i.precision && (s = n.getMaxPrecision(i.precision)) !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", s, "instead.");
                var M = function (e, t) {
                    var n;
                    if (t) {
                        var i = zs[t];
                        n = {
                            name: e.type,
                            uniforms: ws.clone(i.uniforms),
                            vertexShader: i.vertexShader,
                            fragmentShader: i.fragmentShader
                        }
                    } else n = {
                        name: e.type,
                        uniforms: e.uniforms,
                        vertexShader: e.vertexShader,
                        fragmentShader: e.fragmentShader
                    };
                    return n
                }(i, b);
                i.onBeforeCompile(M, e);
                var T = e.getRenderTarget();
                return {
                    isWebGL2: r,
                    shaderID: b,
                    shaderName: M.name,
                    uniforms: M.uniforms,
                    vertexShader: M.vertexShader,
                    fragmentShader: M.fragmentShader,
                    defines: i.defines,
                    isRawShaderMaterial: i.isRawShaderMaterial,
                    isShaderMaterial: i.isShaderMaterial,
                    precision: s,
                    instancing: !0 === v.isInstancedMesh,
                    supportsVertexTextures: c,
                    outputEncoding: null !== T ? d(T.texture) : e.outputEncoding,
                    map: !!i.map,
                    mapEncoding: d(i.map),
                    matcap: !!i.matcap,
                    matcapEncoding: d(i.matcap),
                    envMap: !!w,
                    envMapMode: w && w.mapping,
                    envMapEncoding: d(w),
                    envMapCubeUV: !!w && (w.mapping === ar || 307 === w.mapping),
                    lightMap: !!i.lightMap,
                    lightMapEncoding: d(i.lightMap),
                    aoMap: !!i.aoMap,
                    emissiveMap: !!i.emissiveMap,
                    emissiveMapEncoding: d(i.emissiveMap),
                    bumpMap: !!i.bumpMap,
                    normalMap: !!i.normalMap,
                    objectSpaceNormalMap: 1 === i.normalMapType,
                    tangentSpaceNormalMap: 0 === i.normalMapType,
                    clearcoatMap: !!i.clearcoatMap,
                    clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
                    clearcoatNormalMap: !!i.clearcoatNormalMap,
                    displacementMap: !!i.displacementMap,
                    roughnessMap: !!i.roughnessMap,
                    metalnessMap: !!i.metalnessMap,
                    specularMap: !!i.specularMap,
                    alphaMap: !!i.alphaMap,
                    gradientMap: !!i.gradientMap,
                    sheen: !!i.sheen,
                    combine: i.combine,
                    vertexTangents: i.normalMap && i.vertexTangents,
                    vertexColors: i.vertexColors,
                    vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap),
                    uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || !i.displacementMap),
                    fog: !!y,
                    useFog: i.fog,
                    fogExp2: y && y.isFogExp2,
                    flatShading: i.flatShading,
                    sizeAttenuation: i.sizeAttenuation,
                    logarithmicDepthBuffer: o,
                    skinning: i.skinning && _ > 0,
                    maxBones: _,
                    useVertexTexture: a,
                    morphTargets: i.morphTargets,
                    morphNormals: i.morphNormals,
                    maxMorphTargets: e.maxMorphTargets,
                    maxMorphNormals: e.maxMorphNormals,
                    numDirLights: h.directional.length,
                    numPointLights: h.point.length,
                    numSpotLights: h.spot.length,
                    numRectAreaLights: h.rectArea.length,
                    numHemiLights: h.hemi.length,
                    numDirLightShadows: h.directionalShadowMap.length,
                    numPointLightShadows: h.pointShadowMap.length,
                    numSpotLightShadows: h.spotShadowMap.length,
                    numClippingPlanes: m,
                    numClipIntersection: g,
                    dithering: i.dithering,
                    shadowMapEnabled: e.shadowMap.enabled && p.length > 0,
                    shadowMapType: e.shadowMap.type,
                    toneMapping: i.toneMapped ? e.toneMapping : 0,
                    physicallyCorrectLights: e.physicallyCorrectLights,
                    premultipliedAlpha: i.premultipliedAlpha,
                    alphaTest: i.alphaTest,
                    doubleSided: 2 === i.side,
                    flipSided: 1 === i.side,
                    depthPacking: void 0 !== i.depthPacking && i.depthPacking,
                    index0AttributeName: i.index0AttributeName,
                    extensionDerivatives: i.extensions && i.extensions.derivatives,
                    extensionFragDepth: i.extensions && i.extensions.fragDepth,
                    extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
                    extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: r || null !== t.get("EXT_frag_depth"),
                    rendererExtensionDrawBuffers: r || null !== t.get("WEBGL_draw_buffers"),
                    rendererExtensionShaderTextureLod: r || null !== t.get("EXT_shader_texture_lod"),
                    onBeforeCompile: i.onBeforeCompile
                }
            }, this.getProgramCacheKey = function (t) {
                var n = [];
                if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines)
                    for (var i in t.defines) n.push(i), n.push(t.defines[i]);
                if (void 0 === t.isRawShaderMaterial) {
                    for (var r = 0; r < h.length; r++) n.push(t[h[r]]);
                    n.push(e.outputEncoding), n.push(e.gammaFactor)
                }
                return n.push(t.onBeforeCompile.toString()), n.join()
            }, this.acquireProgram = function (t, n) {
                for (var r, o = 0, a = i.length; o < a; o++) {
                    var s = i[o];
                    if (s.cacheKey === n) {
                        ++(r = s).usedTimes;
                        break
                    }
                }
                return void 0 === r && (r = new hc(e, n, t), i.push(r)), r
            }, this.releaseProgram = function (e) {
                if (0 == --e.usedTimes) {
                    var t = i.indexOf(e);
                    i[t] = i[i.length - 1], i.pop(), e.destroy()
                }
            }, this.programs = i
        }

        function pc() {
            var e = new WeakMap;
            return {
                get: function (t) {
                    var n = e.get(t);
                    return void 0 === n && (n = {}, e.set(t, n)), n
                },
                remove: function (t) {
                    e.delete(t)
                },
                update: function (t, n, i) {
                    e.get(t)[n] = i
                },
                dispose: function () {
                    e = new WeakMap
                }
            }
        }

        function fc(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
        }

        function mc(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
        }

        function gc() {
            var e = [],
                t = 0,
                n = [],
                i = [],
                r = {
                    id: -1
                };

            function o(n, i, o, a, s, l) {
                var c = e[t];
                return void 0 === c ? (c = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: o,
                    program: o.program || r,
                    groupOrder: a,
                    renderOrder: n.renderOrder,
                    z: s,
                    group: l
                }, e[t] = c) : (c.id = n.id, c.object = n, c.geometry = i, c.material = o, c.program = o.program || r, c.groupOrder = a, c.renderOrder = n.renderOrder, c.z = s, c.group = l), t++, c
            }
            return {
                opaque: n,
                transparent: i,
                init: function () {
                    t = 0, n.length = 0, i.length = 0
                },
                push: function (e, t, r, a, s, l) {
                    var c = o(e, t, r, a, s, l);
                    (!0 === r.transparent ? i : n).push(c)
                },
                unshift: function (e, t, r, a, s, l) {
                    var c = o(e, t, r, a, s, l);
                    (!0 === r.transparent ? i : n).unshift(c)
                },
                finish: function () {
                    for (var n = t, i = e.length; n < i; n++) {
                        var r = e[n];
                        if (null === r.id) break;
                        r.id = null, r.object = null, r.geometry = null, r.material = null, r.program = null, r.group = null
                    }
                },
                sort: function (e, t) {
                    n.length > 1 && n.sort(e || fc), i.length > 1 && i.sort(t || mc)
                }
            }
        }

        function vc() {
            var e = new WeakMap;

            function t(n) {
                var i = n.target;
                i.removeEventListener("dispose", t), e.delete(i)
            }
            return {
                get: function (n, i) {
                    var r, o = e.get(n);
                    return void 0 === o ? (r = new gc, e.set(n, new WeakMap), e.get(n).set(i, r), n.addEventListener("dispose", t)) : void 0 === (r = o.get(i)) && (r = new gc, o.set(i, r)), r
                },
                dispose: function () {
                    e = new WeakMap
                }
            }
        }

        function yc() {
            var e = {};
            return {
                get: function (t) {
                    if (void 0 !== e[t.id]) return e[t.id];
                    var n;
                    switch (t.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new Kr,
                                color: new va
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new Kr,
                                direction: new Kr,
                                color: new va,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new Kr,
                                color: new va,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new Kr,
                                skyColor: new va,
                                groundColor: new va
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new va,
                                position: new Kr,
                                halfWidth: new Kr,
                                halfHeight: new Kr
                            }
                    }
                    return e[t.id] = n, n
                }
            }
        }
        var xc = 0;

        function wc(e, t) {
            return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
        }

        function bc() {
            for (var e, t = new yc, n = (e = {}, {
                get: function (t) {
                    if (void 0 !== e[t.id]) return e[t.id];
                    var n;
                    switch (t.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            n = {
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new jr
                            };
                            break;
                        case "PointLight":
                            n = {
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new jr,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                    }
                    return e[t.id] = n, n
                }
            }), i = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadow: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            }, r = 0; r < 9; r++) i.probe.push(new Kr);
            var o = new Kr,
                a = new so,
                s = new so;
            return {
                setup: function (e, r, l) {
                    for (var c = 0, u = 0, h = 0, d = 0; d < 9; d++) i.probe[d].set(0, 0, 0);
                    var p = 0,
                        f = 0,
                        m = 0,
                        g = 0,
                        v = 0,
                        y = 0,
                        x = 0,
                        w = 0,
                        b = l.matrixWorldInverse;
                    e.sort(wc), d = 0;
                    for (var _ = e.length; d < _; d++) {
                        var M = e[d],
                            T = M.color,
                            S = M.intensity,
                            E = M.distance,
                            A = M.shadow && M.shadow.map ? M.shadow.map.texture : null;
                        if (M.isAmbientLight) c += T.r * S, u += T.g * S, h += T.b * S;
                        else if (M.isLightProbe)
                            for (var C = 0; C < 9; C++) i.probe[C].addScaledVector(M.sh.coefficients[C], S);
                        else if (M.isDirectionalLight) {
                            if ((R = t.get(M)).color.copy(M.color).multiplyScalar(M.intensity), R.direction.setFromMatrixPosition(M.matrixWorld), o.setFromMatrixPosition(M.target.matrixWorld), R.direction.sub(o), R.direction.transformDirection(b), M.castShadow) {
                                var L = M.shadow;
                                (P = n.get(M)).shadowBias = L.bias, P.shadowRadius = L.radius, P.shadowMapSize = L.mapSize, i.directionalShadow[p] = P, i.directionalShadowMap[p] = A, i.directionalShadowMatrix[p] = M.shadow.matrix, y++
                            }
                            i.directional[p] = R, p++
                        } else if (M.isSpotLight) {
                            if ((R = t.get(M)).position.setFromMatrixPosition(M.matrixWorld), R.position.applyMatrix4(b), R.color.copy(T).multiplyScalar(S), R.distance = E, R.direction.setFromMatrixPosition(M.matrixWorld), o.setFromMatrixPosition(M.target.matrixWorld), R.direction.sub(o), R.direction.transformDirection(b), R.coneCos = Math.cos(M.angle), R.penumbraCos = Math.cos(M.angle * (1 - M.penumbra)), R.decay = M.decay, M.castShadow) {
                                L = M.shadow;
                                (P = n.get(M)).shadowBias = L.bias, P.shadowRadius = L.radius, P.shadowMapSize = L.mapSize, i.spotShadow[m] = P, i.spotShadowMap[m] = A, i.spotShadowMatrix[m] = M.shadow.matrix, w++
                            }
                            i.spot[m] = R, m++
                        } else if (M.isRectAreaLight) {
                            (R = t.get(M)).color.copy(T).multiplyScalar(S), R.position.setFromMatrixPosition(M.matrixWorld), R.position.applyMatrix4(b), s.identity(), a.copy(M.matrixWorld), a.premultiply(b), s.extractRotation(a), R.halfWidth.set(.5 * M.width, 0, 0), R.halfHeight.set(0, .5 * M.height, 0), R.halfWidth.applyMatrix4(s), R.halfHeight.applyMatrix4(s), i.rectArea[g] = R, g++
                        } else if (M.isPointLight) {
                            if ((R = t.get(M)).position.setFromMatrixPosition(M.matrixWorld), R.position.applyMatrix4(b), R.color.copy(M.color).multiplyScalar(M.intensity), R.distance = M.distance, R.decay = M.decay, M.castShadow) {
                                var P;
                                L = M.shadow;
                                (P = n.get(M)).shadowBias = L.bias, P.shadowRadius = L.radius, P.shadowMapSize = L.mapSize, P.shadowCameraNear = L.camera.near, P.shadowCameraFar = L.camera.far, i.pointShadow[f] = P, i.pointShadowMap[f] = A, i.pointShadowMatrix[f] = M.shadow.matrix, x++
                            }
                            i.point[f] = R, f++
                        } else if (M.isHemisphereLight) {
                            var R;
                            (R = t.get(M)).direction.setFromMatrixPosition(M.matrixWorld), R.direction.transformDirection(b), R.direction.normalize(), R.skyColor.copy(M.color).multiplyScalar(S), R.groundColor.copy(M.groundColor).multiplyScalar(S), i.hemi[v] = R, v++
                        }
                    }
                    i.ambient[0] = c, i.ambient[1] = u, i.ambient[2] = h;
                    var O = i.hash;
                    O.directionalLength === p && O.pointLength === f && O.spotLength === m && O.rectAreaLength === g && O.hemiLength === v && O.numDirectionalShadows === y && O.numPointShadows === x && O.numSpotShadows === w || (i.directional.length = p, i.spot.length = m, i.rectArea.length = g, i.point.length = f, i.hemi.length = v, i.directionalShadow.length = y, i.directionalShadowMap.length = y, i.pointShadow.length = x, i.pointShadowMap.length = x, i.spotShadow.length = w, i.spotShadowMap.length = w, i.directionalShadowMatrix.length = y, i.pointShadowMatrix.length = x, i.spotShadowMatrix.length = w, O.directionalLength = p, O.pointLength = f, O.spotLength = m, O.rectAreaLength = g, O.hemiLength = v, O.numDirectionalShadows = y, O.numPointShadows = x, O.numSpotShadows = w, i.version = xc++)
                },
                state: i
            }
        }

        function _c() {
            var e = new bc,
                t = [],
                n = [];
            return {
                init: function () {
                    t.length = 0, n.length = 0
                },
                state: {
                    lightsArray: t,
                    shadowsArray: n,
                    lights: e
                },
                setupLights: function (i) {
                    e.setup(t, n, i)
                },
                pushLight: function (e) {
                    t.push(e)
                },
                pushShadow: function (e) {
                    n.push(e)
                }
            }
        }

        function Mc() {
            var e = new WeakMap;

            function t(n) {
                var i = n.target;
                i.removeEventListener("dispose", t), e.delete(i)
            }
            return {
                get: function (n, i) {
                    var r;
                    return !1 === e.has(n) ? (r = new _c, e.set(n, new WeakMap), e.get(n).set(i, r), n.addEventListener("dispose", t)) : !1 === e.get(n).has(i) ? (r = new _c, e.get(n).set(i, r)) : r = e.get(n).get(i), r
                },
                dispose: function () {
                    e = new WeakMap
                }
            }
        }

        function Tc(e) {
            Ma.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e)
        }

        function Sc(e) {
            Ma.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Kr, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e)
        }
        Tc.prototype = Object.create(Ma.prototype), Tc.prototype.constructor = Tc, Tc.prototype.isMeshDepthMaterial = !0, Tc.prototype.copy = function (e) {
            return Ma.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
        }, Sc.prototype = Object.create(Ma.prototype), Sc.prototype.constructor = Sc, Sc.prototype.isMeshDistanceMaterial = !0, Sc.prototype.copy = function (e) {
            return Ma.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
        };

        function Ec(e, t, n) {
            var i = new Ps,
                r = new jr,
                o = new jr,
                a = new $r,
                s = [],
                l = [],
                c = {},
                u = {
                    0: 1,
                    1: 0,
                    2: 2
                },
                h = new bs({
                    defines: {
                        SAMPLE_RATE: 2 / 8,
                        HALF_SAMPLE_RATE: 1 / 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new jr
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                }),
                d = h.clone();
            d.defines.HORIZONAL_PASS = 1;
            var p = new Wa;
            p.setAttribute("position", new Ea(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            var f = new cs(p, h),
                m = this;

            function g(n, i) {
                var r = t.update(f);
                h.uniforms.shadow_pass.value = n.map.texture, h.uniforms.resolution.value = n.mapSize, h.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(i, null, r, h, f, null), d.uniforms.shadow_pass.value = n.mapPass.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(i, null, r, d, f, null)
            }

            function v(e, t, n) {
                var i = e << 0 | t << 1 | n << 2,
                    r = s[i];
                return void 0 === r && (r = new Tc({
                    depthPacking: 3201,
                    morphTargets: e,
                    skinning: t
                }), s[i] = r), r
            }

            function y(e, t, n) {
                var i = e << 0 | t << 1 | n << 2,
                    r = l[i];
                return void 0 === r && (r = new Sc({
                    morphTargets: e,
                    skinning: t
                }), l[i] = r), r
            }

            function x(t, n, i, r, o, a) {
                var s = t.geometry,
                    l = null,
                    h = v,
                    d = t.customDepthMaterial;
                if (!0 === i.isPointLight && (h = y, d = t.customDistanceMaterial), void 0 === d) {
                    var p = !1;
                    !0 === n.morphTargets && (!0 === s.isBufferGeometry ? p = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : !0 === s.isGeometry && (p = s.morphTargets && s.morphTargets.length > 0));
                    var f = !1;
                    !0 === t.isSkinnedMesh && (!0 === n.skinning ? f = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t)), l = h(p, f, !0 === t.isInstancedMesh)
                } else l = d;
                if (e.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                    var m = l.uuid,
                        g = n.uuid,
                        x = c[m];
                    void 0 === x && (x = {}, c[m] = x);
                    var w = x[g];
                    void 0 === w && (w = l.clone(), x[g] = w), l = w
                }
                return l.visible = n.visible, l.wireframe = n.wireframe, l.side = 3 === a ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : u[n.side], l.clipShadows = n.clipShadows, l.clippingPlanes = n.clippingPlanes, l.clipIntersection = n.clipIntersection, l.wireframeLinewidth = n.wireframeLinewidth, l.linewidth = n.linewidth, !0 === i.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(i.matrixWorld), l.nearDistance = r, l.farDistance = o), l
            }

            function w(n, r, o, a, s) {
                if (!1 !== n.visible) {
                    if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === s) && (!n.frustumCulled || i.intersectsObject(n))) {
                        n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                        var l = t.update(n),
                            c = n.material;
                        if (Array.isArray(c))
                            for (var u = l.groups, h = 0, d = u.length; h < d; h++) {
                                var p = u[h],
                                    f = c[p.materialIndex];
                                if (f && f.visible) {
                                    var m = x(n, f, a, o.near, o.far, s);
                                    e.renderBufferDirect(o, null, l, m, n, p)
                                }
                            } else if (c.visible) {
                                m = x(n, c, a, o.near, o.far, s);
                                e.renderBufferDirect(o, null, l, m, n, null)
                            }
                    }
                    for (var g = n.children, v = 0, y = g.length; v < y; v++) w(g[v], r, o, a, s)
                }
            }
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (t, s, l) {
                if (!1 !== m.enabled && (!1 !== m.autoUpdate || !1 !== m.needsUpdate) && 0 !== t.length) {
                    var c = e.getRenderTarget(),
                        u = e.getActiveCubeFace(),
                        h = e.getActiveMipmapLevel(),
                        d = e.state;
                    d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                    for (var p = 0, f = t.length; p < f; p++) {
                        var v = t[p],
                            y = v.shadow;
                        if (void 0 !== y) {
                            r.copy(y.mapSize);
                            var x = y.getFrameExtents();
                            if (r.multiply(x), o.copy(y.mapSize), (r.x > n || r.y > n) && (console.warn("THREE.WebGLShadowMap:", v, "has shadow exceeding max texture size, reducing"), r.x > n && (o.x = Math.floor(n / x.x), r.x = o.x * x.x, y.mapSize.x = o.x), r.y > n && (o.y = Math.floor(n / x.y), r.y = o.y * x.y, y.mapSize.y = o.y)), null === y.map && !y.isPointLightShadow && 3 === this.type) {
                                var b = {
                                    minFilter: pr,
                                    magFilter: pr,
                                    format: _r
                                };
                                y.map = new Xr(r.x, r.y, b), y.map.texture.name = v.name + ".shadowMap", y.mapPass = new Xr(r.x, r.y, b), y.camera.updateProjectionMatrix()
                            }
                            if (null === y.map) {
                                b = {
                                    minFilter: ur,
                                    magFilter: ur,
                                    format: _r
                                };
                                y.map = new Xr(r.x, r.y, b), y.map.texture.name = v.name + ".shadowMap", y.camera.updateProjectionMatrix()
                            }
                            e.setRenderTarget(y.map), e.clear();
                            for (var _ = y.getViewportCount(), M = 0; M < _; M++) {
                                var T = y.getViewport(M);
                                a.set(o.x * T.x, o.y * T.y, o.x * T.z, o.y * T.w), d.viewport(a), y.updateMatrices(v, M), i = y.getFrustum(), w(s, l, y.camera, v, this.type)
                            }
                            y.isPointLightShadow || 3 !== this.type || g(y, l)
                        } else console.warn("THREE.WebGLShadowMap:", v, "has no shadow.")
                    }
                    m.needsUpdate = !1, e.setRenderTarget(c, u, h)
                }
            }
        }

        function Ac(e, t, n) {
            var i = n.isWebGL2;
            var r = new function () {
                var t = !1,
                    n = new $r,
                    i = null,
                    r = new $r(0, 0, 0, 0);
                return {
                    setMask: function (n) {
                        i === n || t || (e.colorMask(n, n, n, n), i = n)
                    },
                    setLocked: function (e) {
                        t = e
                    },
                    setClear: function (t, i, o, a, s) {
                        !0 === s && (t *= a, i *= a, o *= a), n.set(t, i, o, a), !1 === r.equals(n) && (e.clearColor(t, i, o, a), r.copy(n))
                    },
                    reset: function () {
                        t = !1, i = null, r.set(-1, 0, 0, 0)
                    }
                }
            },
                o = new function () {
                    var t = !1,
                        n = null,
                        i = null,
                        r = null;
                    return {
                        setTest: function (e) {
                            e ? F(2929) : H(2929)
                        },
                        setMask: function (i) {
                            n === i || t || (e.depthMask(i), n = i)
                        },
                        setFunc: function (t) {
                            if (i !== t) {
                                if (t) switch (t) {
                                    case 0:
                                        e.depthFunc(512);
                                        break;
                                    case 1:
                                        e.depthFunc(519);
                                        break;
                                    case 2:
                                        e.depthFunc(513);
                                        break;
                                    case 3:
                                        e.depthFunc(515);
                                        break;
                                    case 4:
                                        e.depthFunc(514);
                                        break;
                                    case 5:
                                        e.depthFunc(518);
                                        break;
                                    case 6:
                                        e.depthFunc(516);
                                        break;
                                    case 7:
                                        e.depthFunc(517);
                                        break;
                                    default:
                                        e.depthFunc(515)
                                } else e.depthFunc(515);
                                i = t
                            }
                        },
                        setLocked: function (e) {
                            t = e
                        },
                        setClear: function (t) {
                            r !== t && (e.clearDepth(t), r = t)
                        },
                        reset: function () {
                            t = !1, n = null, i = null, r = null
                        }
                    }
                },
                a = new function () {
                    var t = !1,
                        n = null,
                        i = null,
                        r = null,
                        o = null,
                        a = null,
                        s = null,
                        l = null,
                        c = null;
                    return {
                        setTest: function (e) {
                            t || (e ? F(2960) : H(2960))
                        },
                        setMask: function (i) {
                            n === i || t || (e.stencilMask(i), n = i)
                        },
                        setFunc: function (t, n, a) {
                            i === t && r === n && o === a || (e.stencilFunc(t, n, a), i = t, r = n, o = a)
                        },
                        setOp: function (t, n, i) {
                            a === t && s === n && l === i || (e.stencilOp(t, n, i), a = t, s = n, l = i)
                        },
                        setLocked: function (e) {
                            t = e
                        },
                        setClear: function (t) {
                            c !== t && (e.clearStencil(t), c = t)
                        },
                        reset: function () {
                            t = !1, n = null, i = null, r = null, o = null, a = null, s = null, l = null, c = null
                        }
                    }
                },
                s = e.getParameter(34921),
                l = new Uint8Array(s),
                c = new Uint8Array(s),
                u = new Uint8Array(s),
                h = {},
                d = null,
                p = null,
                f = null,
                m = null,
                g = null,
                v = null,
                y = null,
                x = null,
                w = null,
                b = !1,
                _ = null,
                M = null,
                T = null,
                S = null,
                E = null,
                A = e.getParameter(35661),
                C = !1,
                L = 0,
                P = e.getParameter(7938); - 1 !== P.indexOf("WebGL") ? (L = parseFloat(/^WebGL\ ([0-9])/.exec(P)[1]), C = L >= 1) : -1 !== P.indexOf("OpenGL ES") && (L = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(P)[1]), C = L >= 2);
            var R = null,
                O = {},
                D = new $r,
                k = new $r;

            function N(t, n, i) {
                var r = new Uint8Array(4),
                    o = e.createTexture();
                e.bindTexture(t, o), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
                for (var a = 0; a < i; a++) e.texImage2D(n + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
                return o
            }
            var I = {};

            function z(n, r) {
                (l[n] = 1, 0 === c[n] && (e.enableVertexAttribArray(n), c[n] = 1), u[n] !== r) && ((i ? e : t.get("ANGLE_instanced_arrays"))[i ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), u[n] = r)
            }

            function F(t) {
                !0 !== h[t] && (e.enable(t), h[t] = !0)
            }

            function H(t) {
                !1 !== h[t] && (e.disable(t), h[t] = !1)
            }
            I[3553] = N(3553, 3553, 1), I[34067] = N(34067, 34069, 6), r.setClear(0, 0, 0, 1), o.setClear(1), a.setClear(0), F(2929), o.setFunc(3), V(!1), W(1), F(2884), G(0);
            var B = {
                [ir]: 32774,
                101: 32778,
                102: 32779
            };
            if (i) B[103] = 32775, B[104] = 32776;
            else {
                var U = t.get("EXT_blend_minmax");
                null !== U && (B[103] = U.MIN_EXT, B[104] = U.MAX_EXT)
            }
            var j = {
                200: 0,
                201: 1,
                202: 768,
                204: 770,
                210: 776,
                208: 774,
                206: 772,
                203: 769,
                205: 771,
                209: 775,
                207: 773
            };

            function G(t, n, i, r, o, a, s, l) {
                if (0 !== t) {
                    if (p || (F(3042), p = !0), 5 === t) o = o || n, a = a || i, s = s || r, n === m && o === y || (e.blendEquationSeparate(B[n], B[o]), m = n, y = o), i === g && r === v && a === x && s === w || (e.blendFuncSeparate(j[i], j[r], j[a], j[s]), g = i, v = r, x = a, w = s), f = t, b = null;
                    else if (t !== f || l !== b) {
                        if (m === ir && y === ir || (e.blendEquation(32774), m = ir, y = ir), l) switch (t) {
                            case 1:
                                e.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case 2:
                                e.blendFunc(1, 1);
                                break;
                            case 3:
                                e.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case 4:
                                e.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                        } else switch (t) {
                            case 1:
                                e.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case 2:
                                e.blendFunc(770, 1);
                                break;
                            case 3:
                                e.blendFunc(0, 769);
                                break;
                            case 4:
                                e.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                        }
                        g = null, v = null, x = null, w = null, f = t, b = l
                    }
                } else p && (H(3042), p = !1)
            }

            function V(t) {
                _ !== t && (t ? e.frontFace(2304) : e.frontFace(2305), _ = t)
            }

            function W(t) {
                0 !== t ? (F(2884), t !== M && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : H(2884), M = t
            }

            function q(t, n, i) {
                t ? (F(32823), S === n && E === i || (e.polygonOffset(n, i), S = n, E = i)) : H(32823)
            }

            function $(t) {
                void 0 === t && (t = 33984 + A - 1), R !== t && (e.activeTexture(t), R = t)
            }
            return {
                buffers: {
                    color: r,
                    depth: o,
                    stencil: a
                },
                initAttributes: function () {
                    for (var e = 0, t = l.length; e < t; e++) l[e] = 0
                },
                enableAttribute: function (e) {
                    z(e, 0)
                },
                enableAttributeAndDivisor: z,
                disableUnusedAttributes: function () {
                    for (var t = 0, n = c.length; t !== n; ++t) c[t] !== l[t] && (e.disableVertexAttribArray(t), c[t] = 0)
                },
                enable: F,
                disable: H,
                useProgram: function (t) {
                    return d !== t && (e.useProgram(t), d = t, !0)
                },
                setBlending: G,
                setMaterial: function (e, t) {
                    2 === e.side ? H(2884) : F(2884);
                    var n = 1 === e.side;
                    t && (n = !n), V(n), 1 === e.blending && !1 === e.transparent ? G(0) : G(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), o.setFunc(e.depthFunc), o.setTest(e.depthTest), o.setMask(e.depthWrite), r.setMask(e.colorWrite);
                    var i = e.stencilWrite;
                    a.setTest(i), i && (a.setMask(e.stencilWriteMask), a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), q(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                },
                setFlipSided: V,
                setCullFace: W,
                setLineWidth: function (t) {
                    t !== T && (C && e.lineWidth(t), T = t)
                },
                setPolygonOffset: q,
                setScissorTest: function (e) {
                    e ? F(3089) : H(3089)
                },
                activeTexture: $,
                bindTexture: function (t, n) {
                    null === R && $();
                    var i = O[R];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    }, O[R] = i), i.type === t && i.texture === n || (e.bindTexture(t, n || I[t]), i.type = t, i.texture = n)
                },
                unbindTexture: function () {
                    var t = O[R];
                    void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                },
                compressedTexImage2D: function () {
                    try {
                        e.compressedTexImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texImage2D: function () {
                    try {
                        e.texImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texImage3D: function () {
                    try {
                        e.texImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                scissor: function (t) {
                    !1 === D.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), D.copy(t))
                },
                viewport: function (t) {
                    !1 === k.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), k.copy(t))
                },
                reset: function () {
                    for (var t = 0; t < c.length; t++) 1 === c[t] && (e.disableVertexAttribArray(t), c[t] = 0);
                    h = {}, R = null, O = {}, d = null, f = null, _ = null, M = null, r.reset(), o.reset(), a.reset()
                }
            }
        }

        function Cc(e, t, n, i, r, o, a) {
            var s, l = r.isWebGL2,
                c = r.maxTextures,
                u = r.maxCubemapSize,
                h = r.maxTextureSize,
                d = r.maxSamples,
                p = new WeakMap,
                f = !1;
            try {
                f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (e) { }

            function m(e, t) {
                return f ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
            }

            function g(e, t, n, i) {
                var r = 1;
                if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)), r < 1 || !0 === t) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                        var o = t ? Ur.floorPowerOfTwo : Math.floor,
                            a = o(r * e.width),
                            l = o(r * e.height);
                        void 0 === s && (s = m(a, l));
                        var c = n ? m(a, l) : s;
                        return c.width = a, c.height = l, c.getContext("2d").drawImage(e, 0, 0, a, l), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + a + "x" + l + ")."), c
                    }
                    return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
                }
                return e
            }

            function v(e) {
                return Ur.isPowerOfTwo(e.width) && Ur.isPowerOfTwo(e.height)
            }

            function y(e, t) {
                return e.generateMipmaps && t && e.minFilter !== ur && e.minFilter !== pr
            }

            function x(t, n, r, o) {
                e.generateMipmap(t), i.get(n).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E
            }

            function w(n, i, r) {
                if (!1 === l) return i;
                if (null !== n) {
                    if (void 0 !== e[n]) return e[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                var o = i;
                return 6403 === i && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 6407 === i && (5126 === r && (o = 34837), 5131 === r && (o = 34843), 5121 === r && (o = 32849)), 6408 === i && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || t.get("EXT_color_buffer_float"), o
            }

            function b(e) {
                return e === ur || e === hr || e === dr ? 9728 : 9729
            }

            function _(t) {
                var n = t.target;
                n.removeEventListener("dispose", _),
                    function (t) {
                        var n = i.get(t);
                        if (void 0 === n.__webglInit) return;
                        e.deleteTexture(n.__webglTexture), i.remove(t)
                    }(n), n.isVideoTexture && p.delete(n), a.memory.textures--
            }

            function M(t) {
                var n = t.target;
                n.removeEventListener("dispose", M),
                    function (t) {
                        var n = i.get(t),
                            r = i.get(t.texture);
                        if (!t) return;
                        void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture);
                        t.depthTexture && t.depthTexture.dispose();
                        if (t.isWebGLCubeRenderTarget)
                            for (var o = 0; o < 6; o++) e.deleteFramebuffer(n.__webglFramebuffer[o]), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[o]);
                        else e.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && e.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                        i.remove(t.texture), i.remove(t)
                    }(n), a.memory.textures--
            }
            var T = 0;

            function S(e, t) {
                var r = i.get(e);
                if (e.isVideoTexture && function (e) {
                    var t = a.render.frame;
                    p.get(e) !== t && (p.set(e, t), e.update())
                }(e), e.version > 0 && r.__version !== e.version) {
                    var o = e.image;
                    if (void 0 === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                    else {
                        if (!1 !== o.complete) return void O(r, e, t);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture)
            }

            function E(t, r) {
                if (6 === t.image.length) {
                    var a = i.get(t);
                    if (t.version > 0 && a.__version !== t.version) {
                        R(a, t), n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture), e.pixelStorei(37440, t.flipY);
                        for (var s = t && (t.isCompressedTexture || t.image[0].isCompressedTexture), c = t.image[0] && t.image[0].isDataTexture, h = [], d = 0; d < 6; d++) h[d] = s || c ? c ? t.image[d].image : t.image[d] : g(t.image[d], !1, !0, u);
                        var p, f = h[0],
                            m = v(f) || l,
                            b = o.convert(t.format),
                            _ = o.convert(t.type),
                            M = w(t.internalFormat, b, _);
                        if (P(34067, t, m), s) {
                            for (d = 0; d < 6; d++) {
                                p = h[d].mipmaps;
                                for (var T = 0; T < p.length; T++) {
                                    var S = p[T];
                                    t.format !== _r && t.format !== br ? null !== b ? n.compressedTexImage2D(34069 + d, T, M, S.width, S.height, 0, S.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + d, T, M, S.width, S.height, 0, b, _, S.data)
                                }
                            }
                            a.__maxMipLevel = p.length - 1
                        } else {
                            p = t.mipmaps;
                            for (d = 0; d < 6; d++)
                                if (c) {
                                    n.texImage2D(34069 + d, 0, M, h[d].width, h[d].height, 0, b, _, h[d].data);
                                    for (T = 0; T < p.length; T++) {
                                        var E = (S = p[T]).image[d].image;
                                        n.texImage2D(34069 + d, T + 1, M, E.width, E.height, 0, b, _, E.data)
                                    }
                                } else {
                                    n.texImage2D(34069 + d, 0, M, b, _, h[d]);
                                    for (T = 0; T < p.length; T++) {
                                        S = p[T];
                                        n.texImage2D(34069 + d, T + 1, M, b, _, S.image[d])
                                    }
                                }
                            a.__maxMipLevel = p.length
                        }
                        y(t, m) && x(34067, t, f.width, f.height), a.__version = t.version, t.onUpdate && t.onUpdate(t)
                    } else n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture)
                }
            }

            function A(e, t) {
                n.activeTexture(33984 + t), n.bindTexture(34067, i.get(e).__webglTexture)
            }
            var C = {
                [sr]: 10497,
                [lr]: 33071,
                [cr]: 33648
            },
                L = {
                    [ur]: 9728,
                    [hr]: 9984,
                    [dr]: 9986,
                    [pr]: 9729,
                    1007: 9985,
                    [fr]: 9987
                };

            function P(n, o, a) {
                a ? (e.texParameteri(n, 10242, C[o.wrapS]), e.texParameteri(n, 10243, C[o.wrapT]), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, C[o.wrapR]), e.texParameteri(n, 10240, L[o.magFilter]), e.texParameteri(n, 10241, L[o.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), o.wrapS === lr && o.wrapT === lr || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, b(o.magFilter)), e.texParameteri(n, 10241, b(o.minFilter)), o.minFilter !== ur && o.minFilter !== pr && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
                var s = t.get("EXT_texture_filter_anisotropic");
                if (s) {
                    if (o.type === yr && null === t.get("OES_texture_float_linear")) return;
                    if (o.type === xr && null === (l || t.get("OES_texture_half_float_linear"))) return;
                    (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (e.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy)
                }
            }

            function R(t, n) {
                void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", _), t.__webglTexture = e.createTexture(), a.memory.textures++)
            }

            function O(t, i, r) {
                var a = 3553;
                i.isDataTexture2DArray && (a = 35866), i.isDataTexture3D && (a = 32879), R(t, i), n.activeTexture(33984 + r), n.bindTexture(a, t.__webglTexture), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment);
                var s = function (e) {
                    return !l && (e.wrapS !== lr || e.wrapT !== lr || e.minFilter !== ur && e.minFilter !== pr)
                }(i) && !1 === v(i.image),
                    c = g(i.image, s, !1, h),
                    u = v(c) || l,
                    d = o.convert(i.format),
                    p = o.convert(i.type),
                    f = w(i.internalFormat, d, p);
                P(a, i, u);
                var m, b = i.mipmaps;
                if (i.isDepthTexture) f = 6402, l ? f = i.type === yr ? 36012 : i.type === vr ? 33190 : i.type === wr ? 35056 : 33189 : i.type === yr && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === Mr && 6402 === f && i.type !== gr && i.type !== vr && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = gr, p = o.convert(i.type)), i.format === Tr && 6402 === f && (f = 34041, i.type !== wr && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = wr, p = o.convert(i.type))), n.texImage2D(3553, 0, f, c.width, c.height, 0, d, p, null);
                else if (i.isDataTexture)
                    if (b.length > 0 && u) {
                        for (var _ = 0, M = b.length; _ < M; _++) m = b[_], n.texImage2D(3553, _, f, m.width, m.height, 0, d, p, m.data);
                        i.generateMipmaps = !1, t.__maxMipLevel = b.length - 1
                    } else n.texImage2D(3553, 0, f, c.width, c.height, 0, d, p, c.data), t.__maxMipLevel = 0;
                else if (i.isCompressedTexture) {
                    for (_ = 0, M = b.length; _ < M; _++) m = b[_], i.format !== _r && i.format !== br ? null !== d ? n.compressedTexImage2D(3553, _, f, m.width, m.height, 0, m.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, _, f, m.width, m.height, 0, d, p, m.data);
                    t.__maxMipLevel = b.length - 1
                } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, f, c.width, c.height, c.depth, 0, d, p, c.data), t.__maxMipLevel = 0;
                else if (i.isDataTexture3D) n.texImage3D(32879, 0, f, c.width, c.height, c.depth, 0, d, p, c.data), t.__maxMipLevel = 0;
                else if (b.length > 0 && u) {
                    for (_ = 0, M = b.length; _ < M; _++) m = b[_], n.texImage2D(3553, _, f, d, p, m);
                    i.generateMipmaps = !1, t.__maxMipLevel = b.length - 1
                } else n.texImage2D(3553, 0, f, d, p, c), t.__maxMipLevel = 0;
                y(i, u) && x(a, i, c.width, c.height), t.__version = i.version, i.onUpdate && i.onUpdate(i)
            }

            function D(t, r, a, s) {
                var l = o.convert(r.texture.format),
                    c = o.convert(r.texture.type),
                    u = w(r.texture.internalFormat, l, c);
                n.texImage2D(s, 0, u, r.width, r.height, 0, l, c, null), e.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, a, s, i.get(r.texture).__webglTexture, 0), e.bindFramebuffer(36160, null)
            }

            function k(t, n, i) {
                if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
                    var r = 33189;
                    if (i) {
                        var a = n.depthTexture;
                        a && a.isDepthTexture && (a.type === yr ? r = 36012 : a.type === vr && (r = 33190));
                        var s = I(n);
                        e.renderbufferStorageMultisample(36161, s, r, n.width, n.height)
                    } else e.renderbufferStorage(36161, r, n.width, n.height);
                    e.framebufferRenderbuffer(36160, 36096, 36161, t)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    if (i) {
                        s = I(n);
                        e.renderbufferStorageMultisample(36161, s, 35056, n.width, n.height)
                    } else e.renderbufferStorage(36161, 34041, n.width, n.height);
                    e.framebufferRenderbuffer(36160, 33306, 36161, t)
                } else {
                    var l = o.convert(n.texture.format),
                        c = o.convert(n.texture.type);
                    r = w(n.texture.internalFormat, l, c);
                    if (i) {
                        s = I(n);
                        e.renderbufferStorageMultisample(36161, s, r, n.width, n.height)
                    } else e.renderbufferStorage(36161, r, n.width, n.height)
                }
                e.bindRenderbuffer(36161, null)
            }

            function N(t) {
                var n = i.get(t),
                    r = !0 === t.isWebGLCubeRenderTarget;
                if (t.depthTexture) {
                    if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                    ! function (t, n) {
                        if (n && n.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (e.bindFramebuffer(36160, t), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), S(n.depthTexture, 0);
                        var r = i.get(n.depthTexture).__webglTexture;
                        if (n.depthTexture.format === Mr) e.framebufferTexture2D(36160, 36096, 3553, r, 0);
                        else {
                            if (n.depthTexture.format !== Tr) throw new Error("Unknown depthTexture format");
                            e.framebufferTexture2D(36160, 33306, 3553, r, 0)
                        }
                    }(n.__webglFramebuffer, t)
                } else if (r) {
                    n.__webglDepthbuffer = [];
                    for (var o = 0; o < 6; o++) e.bindFramebuffer(36160, n.__webglFramebuffer[o]), n.__webglDepthbuffer[o] = e.createRenderbuffer(), k(n.__webglDepthbuffer[o], t, !1)
                } else e.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = e.createRenderbuffer(), k(n.__webglDepthbuffer, t, !1);
                e.bindFramebuffer(36160, null)
            }

            function I(e) {
                return l && e.isWebGLMultisampleRenderTarget ? Math.min(d, e.samples) : 0
            }
            var z = !1,
                F = !1;
            this.allocateTextureUnit = function () {
                var e = T;
                return e >= c && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + c), T += 1, e
            }, this.resetTextureUnits = function () {
                T = 0
            }, this.setTexture2D = S, this.setTexture2DArray = function (e, t) {
                var r = i.get(e);
                e.version > 0 && r.__version !== e.version ? O(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, r.__webglTexture))
            }, this.setTexture3D = function (e, t) {
                var r = i.get(e);
                e.version > 0 && r.__version !== e.version ? O(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, r.__webglTexture))
            }, this.setTextureCube = E, this.setTextureCubeDynamic = A, this.setupRenderTarget = function (t) {
                var r = i.get(t),
                    s = i.get(t.texture);
                t.addEventListener("dispose", M), s.__webglTexture = e.createTexture(), a.memory.textures++;
                var c = !0 === t.isWebGLCubeRenderTarget,
                    u = !0 === t.isWebGLMultisampleRenderTarget,
                    h = v(t) || l;
                if (!l || t.texture.format !== br || t.texture.type !== yr && t.texture.type !== xr || (t.texture.format = _r, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), c) {
                    r.__webglFramebuffer = [];
                    for (var d = 0; d < 6; d++) r.__webglFramebuffer[d] = e.createFramebuffer()
                } else if (r.__webglFramebuffer = e.createFramebuffer(), u)
                    if (l) {
                        r.__webglMultisampledFramebuffer = e.createFramebuffer(), r.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, r.__webglColorRenderbuffer);
                        var p = o.convert(t.texture.format),
                            f = o.convert(t.texture.type),
                            m = w(t.texture.internalFormat, p, f),
                            g = I(t);
                        e.renderbufferStorageMultisample(36161, g, m, t.width, t.height), e.bindFramebuffer(36160, r.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, r.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (r.__webglDepthRenderbuffer = e.createRenderbuffer(), k(r.__webglDepthRenderbuffer, t, !0)), e.bindFramebuffer(36160, null)
                    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                if (c) {
                    n.bindTexture(34067, s.__webglTexture), P(34067, t.texture, h);
                    for (d = 0; d < 6; d++) D(r.__webglFramebuffer[d], t, 36064, 34069 + d);
                    y(t.texture, h) && x(34067, t.texture, t.width, t.height), n.bindTexture(34067, null)
                } else n.bindTexture(3553, s.__webglTexture), P(3553, t.texture, h), D(r.__webglFramebuffer, t, 36064, 3553), y(t.texture, h) && x(3553, t.texture, t.width, t.height), n.bindTexture(3553, null);
                t.depthBuffer && N(t)
            }, this.updateRenderTargetMipmap = function (e) {
                var t = e.texture;
                if (y(t, v(e) || l)) {
                    var r = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                        o = i.get(t).__webglTexture;
                    n.bindTexture(r, o), x(r, t, e.width, e.height), n.bindTexture(r, null)
                }
            }, this.updateMultisampleRenderTarget = function (t) {
                if (t.isWebGLMultisampleRenderTarget)
                    if (l) {
                        var n = i.get(t);
                        e.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, n.__webglFramebuffer);
                        var r = t.width,
                            o = t.height,
                            a = 16384;
                        t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024), e.blitFramebuffer(0, 0, r, o, 0, 0, r, o, a, 9728), e.bindFramebuffer(36160, n.__webglMultisampledFramebuffer)
                    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
            }, this.safeSetTexture2D = function (e, t) {
                e && e.isWebGLRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), z = !0), e = e.texture), S(e, t)
            }, this.safeSetTextureCube = function (e, t) {
                e && e.isWebGLCubeRenderTarget && (!1 === F && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), F = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? E(e, t) : A(e, t)
            }
        }

        function Lc(e, t, n) {
            var i = n.isWebGL2;
            return {
                convert: function (e) {
                    var n;
                    if (e === mr) return 5121;
                    if (1017 === e) return 32819;
                    if (1018 === e) return 32820;
                    if (1019 === e) return 33635;
                    if (1010 === e) return 5120;
                    if (1011 === e) return 5122;
                    if (e === gr) return 5123;
                    if (1013 === e) return 5124;
                    if (e === vr) return 5125;
                    if (e === yr) return 5126;
                    if (e === xr) return i ? 5131 : null !== (n = t.get("OES_texture_half_float")) ? n.HALF_FLOAT_OES : null;
                    if (1021 === e) return 6406;
                    if (e === br) return 6407;
                    if (e === _r) return 6408;
                    if (1024 === e) return 6409;
                    if (1025 === e) return 6410;
                    if (e === Mr) return 6402;
                    if (e === Tr) return 34041;
                    if (1028 === e) return 6403;
                    if (1029 === e) return 36244;
                    if (1030 === e) return 33319;
                    if (1031 === e) return 33320;
                    if (1032 === e) return 36248;
                    if (1033 === e) return 36249;
                    if (33776 === e || 33777 === e || 33778 === e || 33779 === e) {
                        if (null === (n = t.get("WEBGL_compressed_texture_s3tc"))) return null;
                        if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (35840 === e || 35841 === e || 35842 === e || 35843 === e) {
                        if (null === (n = t.get("WEBGL_compressed_texture_pvrtc"))) return null;
                        if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === e) return null !== (n = t.get("WEBGL_compressed_texture_etc1")) ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if ((37492 === e || 37496 === e) && null !== (n = t.get("WEBGL_compressed_texture_etc"))) {
                        if (37492 === e) return n.COMPRESSED_RGB8_ETC2;
                        if (37496 === e) return n.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    return 37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e || 37840 === e || 37841 === e || 37842 === e || 37843 === e || 37844 === e || 37845 === e || 37846 === e || 37847 === e || 37848 === e || 37849 === e || 37850 === e || 37851 === e || 37852 === e || 37853 === e ? null !== (n = t.get("WEBGL_compressed_texture_astc")) ? e : null : 36492 === e ? null !== (n = t.get("EXT_texture_compression_bptc")) ? e : null : e === wr ? i ? 34042 : null !== (n = t.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : null : void 0
                }
            }
        }

        function Pc(e) {
            Ms.call(this), this.cameras = e || []
        }

        function Rc() {
            Eo.call(this), this.type = "Group"
        }

        function Oc(e, t) {
            var n = this,
                i = null,
                r = 1,
                o = null,
                a = "local-floor",
                s = null,
                l = [],
                c = new Map,
                u = new Ms;
            u.layers.enable(1), u.viewport = new $r;
            var h = new Ms;
            h.layers.enable(2), h.viewport = new $r;
            var d = new Pc([u, h]);
            d.layers.enable(1), d.layers.enable(2);
            var p = null,
                f = null;

            function m(e) {
                var t = c.get(e.inputSource);
                t && (t.targetRay && t.targetRay.dispatchEvent({
                    type: e.type
                }), t.grip && t.grip.dispatchEvent({
                    type: e.type
                }))
            }

            function g() {
                c.forEach((function (e, t) {
                    e.targetRay && (e.targetRay.dispatchEvent({
                        type: "disconnected",
                        data: t
                    }), e.targetRay.visible = !1), e.grip && (e.grip.dispatchEvent({
                        type: "disconnected",
                        data: t
                    }), e.grip.visible = !1)
                })), c.clear(), e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), M.stop(), n.isPresenting = !1, n.dispatchEvent({
                    type: "sessionend"
                })
            }

            function v(e) {
                o = e, M.setContext(i), M.start(), n.isPresenting = !0, n.dispatchEvent({
                    type: "sessionstart"
                })
            }

            function y(e) {
                for (var t = i.inputSources, n = 0; n < l.length; n++) c.set(t[n], l[n]);
                for (n = 0; n < e.removed.length; n++) {
                    var r = e.removed[n];
                    (o = c.get(r)) && (o.targetRay && o.targetRay.dispatchEvent({
                        type: "disconnected",
                        data: r
                    }), o.grip && o.grip.dispatchEvent({
                        type: "disconnected",
                        data: r
                    }), c.delete(r))
                }
                for (n = 0; n < e.added.length; n++) {
                    var o;
                    r = e.added[n];
                    (o = c.get(r)) && (o.targetRay && o.targetRay.dispatchEvent({
                        type: "connected",
                        data: r
                    }), o.grip && o.grip.dispatchEvent({
                        type: "connected",
                        data: r
                    }))
                }
            }
            this.enabled = !1, this.isPresenting = !1, this.getController = function (e) {
                var t = l[e];
                return void 0 === t && (t = {}, l[e] = t), void 0 === t.targetRay && (t.targetRay = new Rc, t.targetRay.matrixAutoUpdate = !1, t.targetRay.visible = !1), t.targetRay
            }, this.getControllerGrip = function (e) {
                var t = l[e];
                return void 0 === t && (t = {}, l[e] = t), void 0 === t.grip && (t.grip = new Rc, t.grip.matrixAutoUpdate = !1, t.grip.visible = !1), t.grip
            }, this.setFramebufferScaleFactor = function (e) {
                r = e, 1 == n.isPresenting && console.warn("WebXRManager: Cannot change framebuffer scale while presenting VR content")
            }, this.setReferenceSpaceType = function (e) {
                a = e
            }, this.getReferenceSpace = function () {
                return o
            }, this.getSession = function () {
                return i
            }, this.setSession = function (e) {
                if (null !== (i = e)) {
                    i.addEventListener("select", m), i.addEventListener("selectstart", m), i.addEventListener("selectend", m), i.addEventListener("squeeze", m), i.addEventListener("squeezestart", m), i.addEventListener("squeezeend", m), i.addEventListener("end", g);
                    var n = t.getContextAttributes(),
                        o = {
                            antialias: n.antialias,
                            alpha: n.alpha,
                            depth: n.depth,
                            stencil: n.stencil,
                            framebufferScaleFactor: r
                        },
                        s = new XRWebGLLayer(i, t, o);
                    i.updateRenderState({
                        baseLayer: s
                    }), i.requestReferenceSpace(a).then(v), i.addEventListener("inputsourceschange", y)
                }
            };
            var x = new Kr,
                w = new Kr;

            function b(e, t) {
                null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld)
            }
            this.getCamera = function (e) {
                d.near = h.near = u.near = e.near, d.far = h.far = u.far = e.far, p === d.near && f === d.far || (i.updateRenderState({
                    depthNear: d.near,
                    depthFar: d.far
                }), p = d.near, f = d.far);
                var t = e.parent,
                    n = d.cameras;
                b(d, t);
                for (var r = 0; r < n.length; r++) b(n[r], t);
                e.matrixWorld.copy(d.matrixWorld);
                for (var o = e.children, a = (r = 0, o.length); r < a; r++) o[r].updateMatrixWorld(!0);
                return function (e, t, n) {
                    x.setFromMatrixPosition(t.matrixWorld), w.setFromMatrixPosition(n.matrixWorld);
                    var i = x.distanceTo(w),
                        r = t.projectionMatrix.elements,
                        o = n.projectionMatrix.elements,
                        a = r[14] / (r[10] - 1),
                        s = r[14] / (r[10] + 1),
                        l = (r[9] + 1) / r[5],
                        c = (r[9] - 1) / r[5],
                        u = (r[8] - 1) / r[0],
                        h = (o[8] + 1) / o[0],
                        d = a * u,
                        p = a * h,
                        f = i / (-u + h),
                        m = f * -u;
                    t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld);
                    var g = a + f,
                        v = s + f,
                        y = d - m,
                        b = p + (i - m),
                        _ = l * s / v * g,
                        M = c * s / v * g;
                    e.projectionMatrix.makePerspective(y, b, _, M, g, v)
                }(d, u, h), d
            };
            var _ = null;
            var M = new Os;
            M.setAnimationLoop((function (t, n) {
                if (null !== (s = n.getViewerPose(o))) {
                    var r = s.views,
                        a = i.renderState.baseLayer;
                    e.setFramebuffer(a.framebuffer);
                    for (var c = 0; c < r.length; c++) {
                        var u = r[c],
                            h = a.getViewport(u),
                            p = d.cameras[c];
                        p.matrix.fromArray(u.transform.matrix), p.projectionMatrix.fromArray(u.projectionMatrix), p.viewport.set(h.x, h.y, h.width, h.height), 0 === c && d.matrix.copy(p.matrix)
                    }
                }
                var f = i.inputSources;
                for (c = 0; c < l.length; c++) {
                    var m = l[c],
                        g = f[c],
                        v = null,
                        y = null;
                    g && (m.targetRay && null !== (v = n.getPose(g.targetRaySpace, o)) && (m.targetRay.matrix.fromArray(v.transform.matrix), m.targetRay.matrix.decompose(m.targetRay.position, m.targetRay.rotation, m.targetRay.scale)), m.grip && g.gripSpace && null !== (y = n.getPose(g.gripSpace, o)) && (m.grip.matrix.fromArray(y.transform.matrix), m.grip.matrix.decompose(m.grip.position, m.grip.rotation, m.grip.scale))), m.targetRay && (m.targetRay.visible = null !== v), m.grip && (m.grip.visible = null !== y)
                }
                _ && _(t, n)
            })), this.setAnimationLoop = function (e) {
                _ = e
            }, this.dispose = function () { }
        }

        function Dc(e) {
            var t = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                n = void 0 !== e.context ? e.context : null,
                i = void 0 !== e.alpha && e.alpha,
                r = void 0 === e.depth || e.depth,
                o = void 0 === e.stencil || e.stencil,
                a = void 0 !== e.antialias && e.antialias,
                s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                c = void 0 !== e.powerPreference ? e.powerPreference : "default",
                u = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat,
                h = null,
                d = null;
            this.domElement = t, this.debug = {
                checkShaderErrors: !0
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Rr, this.physicallyCorrectLights = !1, this.toneMapping = 1, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
            var p, f, m, g, v, y, x, w, b, _, M, T, S, E, A, C, L, P, R = this,
                O = !1,
                D = null,
                k = 0,
                N = 0,
                I = null,
                z = null,
                F = -1,
                H = {
                    geometry: null,
                    program: null,
                    wireframe: !1
                },
                B = null,
                U = null,
                j = new $r,
                G = new $r,
                V = null,
                W = t.width,
                q = t.height,
                $ = 1,
                X = null,
                Y = null,
                Z = new $r(0, 0, W, q),
                J = new $r(0, 0, W, q),
                Q = !1,
                K = new Ps,
                ee = new Us,
                te = !1,
                ne = !1,
                ie = new so,
                re = new Kr;

            function oe() {
                return null === I ? $ : 1
            }
            try {
                var ae = {
                    alpha: i,
                    depth: r,
                    stencil: o,
                    antialias: a,
                    premultipliedAlpha: s,
                    preserveDrawingBuffer: l,
                    powerPreference: c,
                    failIfMajorPerformanceCaveat: u,
                    xrCompatible: !0
                };
                if (t.addEventListener("webglcontextlost", ue, !1), t.addEventListener("webglcontextrestored", he, !1), null === (p = n || t.getContext("webgl", ae) || t.getContext("experimental-webgl", ae))) throw null !== t.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                void 0 === p.getShaderPrecisionFormat && (p.getShaderPrecisionFormat = function () {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (e) {
                throw console.error("THREE.WebGLRenderer: " + e.message), e
            }

            function se() {
                f = new js(p), !1 === (m = new Bs(p, f, e)).isWebGL2 && (f.get("WEBGL_depth_texture"), f.get("OES_texture_float"), f.get("OES_texture_half_float"), f.get("OES_texture_half_float_linear"), f.get("OES_standard_derivatives"), f.get("OES_element_index_uint"), f.get("ANGLE_instanced_arrays")), f.get("OES_texture_float_linear"), P = new Lc(p, f, m), (g = new Ac(p, f, m)).scissor(G.copy(J).multiplyScalar($).floor()), g.viewport(j.copy(Z).multiplyScalar($).floor()), v = new Ws(p), y = new pc, x = new Cc(p, f, g, y, m, P, v), w = new Ds(p, m), b = new Gs(p, w, v), _ = new Xs(p, b, w, v), A = new $s(p), M = new dc(R, f, m), T = new vc, S = new Mc, E = new Fs(R, g, _, s), C = new Hs(p, f, v, m), L = new Vs(p, f, v, m), v.programs = M.programs, R.capabilities = m, R.extensions = f, R.properties = y, R.renderLists = T, R.state = g, R.info = v
            }
            se();
            var le = new Oc(R, p);
            this.xr = le;
            var ce = new Ec(R, _, m.maxTextureSize);

            function ue(e) {
                e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), O = !0
            }

            function he() {
                console.log("THREE.WebGLRenderer: Context Restored."), O = !1, se()
            }

            function de(e) {
                var t = e.target;
                t.removeEventListener("dispose", de),
                    function (e) {
                        pe(e), y.remove(e)
                    }(t)
            }

            function pe(e) {
                var t = y.get(e).program;
                e.program = void 0, void 0 !== t && M.releaseProgram(t)
            }
            this.shadowMap = ce, this.getContext = function () {
                return p
            }, this.getContextAttributes = function () {
                return p.getContextAttributes()
            }, this.forceContextLoss = function () {
                var e = f.get("WEBGL_lose_context");
                e && e.loseContext()
            }, this.forceContextRestore = function () {
                var e = f.get("WEBGL_lose_context");
                e && e.restoreContext()
            }, this.getPixelRatio = function () {
                return $
            }, this.setPixelRatio = function (e) {
                void 0 !== e && ($ = e, this.setSize(W, q, !1))
            }, this.getSize = function (e) {
                return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new jr), e.set(W, q)
            }, this.setSize = function (e, n, i) {
                le.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (W = e, q = n, t.width = Math.floor(e * $), t.height = Math.floor(n * $), !1 !== i && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
            }, this.getDrawingBufferSize = function (e) {
                return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new jr), e.set(W * $, q * $).floor()
            }, this.setDrawingBufferSize = function (e, n, i) {
                W = e, q = n, $ = i, t.width = Math.floor(e * i), t.height = Math.floor(n * i), this.setViewport(0, 0, e, n)
            }, this.getCurrentViewport = function (e) {
                return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new $r), e.copy(j)
            }, this.getViewport = function (e) {
                return e.copy(Z)
            }, this.setViewport = function (e, t, n, i) {
                e.isVector4 ? Z.set(e.x, e.y, e.z, e.w) : Z.set(e, t, n, i), g.viewport(j.copy(Z).multiplyScalar($).floor())
            }, this.getScissor = function (e) {
                return e.copy(J)
            }, this.setScissor = function (e, t, n, i) {
                e.isVector4 ? J.set(e.x, e.y, e.z, e.w) : J.set(e, t, n, i), g.scissor(G.copy(J).multiplyScalar($).floor())
            }, this.getScissorTest = function () {
                return Q
            }, this.setScissorTest = function (e) {
                g.setScissorTest(Q = e)
            }, this.setOpaqueSort = function (e) {
                X = e
            }, this.setTransparentSort = function (e) {
                Y = e
            }, this.getClearColor = function () {
                return E.getClearColor()
            }, this.setClearColor = function () {
                E.setClearColor.apply(E, arguments)
            }, this.getClearAlpha = function () {
                return E.getClearAlpha()
            }, this.setClearAlpha = function () {
                E.setClearAlpha.apply(E, arguments)
            }, this.clear = function (e, t, n) {
                var i = 0;
                (void 0 === e || e) && (i |= 16384), (void 0 === t || t) && (i |= 256), (void 0 === n || n) && (i |= 1024), p.clear(i)
            }, this.clearColor = function () {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function () {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function () {
                this.clear(!1, !1, !0)
            }, this.dispose = function () {
                t.removeEventListener("webglcontextlost", ue, !1), t.removeEventListener("webglcontextrestored", he, !1), T.dispose(), S.dispose(), y.dispose(), _.dispose(), le.dispose(), ge.stop(), this.forceContextLoss()
            }, this.renderBufferImmediate = function (e, t) {
                g.initAttributes();
                var n = y.get(e);
                e.hasPositions && !n.position && (n.position = p.createBuffer()), e.hasNormals && !n.normal && (n.normal = p.createBuffer()), e.hasUvs && !n.uv && (n.uv = p.createBuffer()), e.hasColors && !n.color && (n.color = p.createBuffer());
                var i = t.getAttributes();
                e.hasPositions && (p.bindBuffer(34962, n.position), p.bufferData(34962, e.positionArray, 35048), g.enableAttribute(i.position), p.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), e.hasNormals && (p.bindBuffer(34962, n.normal), p.bufferData(34962, e.normalArray, 35048), g.enableAttribute(i.normal), p.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (p.bindBuffer(34962, n.uv), p.bufferData(34962, e.uvArray, 35048), g.enableAttribute(i.uv), p.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), e.hasColors && (p.bindBuffer(34962, n.color), p.bufferData(34962, e.colorArray, 35048), g.enableAttribute(i.color), p.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), g.disableUnusedAttributes(), p.drawArrays(4, 0, e.count), e.count = 0
            };
            var fe = new Ao;
            this.renderBufferDirect = function (e, t, n, i, r, o) {
                null === t && (t = fe);
                var a = r.isMesh && r.matrixWorld.determinant() < 0,
                    s = be(e, t, i, r);
                g.setMaterial(i, a);
                var l = !1;
                H.geometry === n.id && H.program === s.id && H.wireframe === (!0 === i.wireframe) || (H.geometry = n.id, H.program = s.id, H.wireframe = !0 === i.wireframe, l = !0), (i.morphTargets || i.morphNormals) && (A.update(r, n, i, s), l = !0);
                var c = n.index,
                    u = n.attributes.position;
                if (null === c) {
                    if (void 0 === u || 0 === u.count) return
                } else if (0 === c.count) return;
                var h, d = 1;
                !0 === i.wireframe && (c = b.getWireframeAttribute(n), d = 2);
                var v = C;
                null !== c && (h = w.get(c), (v = L).setIndex(h)), l && (! function (e, t, n, i) {
                    if (!1 === m.isWebGL2 && (e.isInstancedMesh || t.isInstancedBufferGeometry) && null === f.get("ANGLE_instanced_arrays")) return;
                    g.initAttributes();
                    var r = t.attributes,
                        o = i.getAttributes(),
                        a = n.defaultAttributeValues;
                    for (var s in o) {
                        var l = o[s];
                        if (l >= 0) {
                            var c = r[s];
                            if (void 0 !== c) {
                                var u = c.normalized,
                                    h = c.itemSize;
                                if (void 0 === (M = w.get(c))) continue;
                                var d = M.buffer,
                                    v = M.type,
                                    y = M.bytesPerElement;
                                if (c.isInterleavedBufferAttribute) {
                                    var x = c.data,
                                        b = x.stride,
                                        _ = c.offset;
                                    x && x.isInstancedInterleavedBuffer ? (g.enableAttributeAndDivisor(l, x.meshPerAttribute), void 0 === t.maxInstancedCount && (t.maxInstancedCount = x.meshPerAttribute * x.count)) : g.enableAttribute(l), p.bindBuffer(34962, d), p.vertexAttribPointer(l, h, v, u, b * y, _ * y)
                                } else c.isInstancedBufferAttribute ? (g.enableAttributeAndDivisor(l, c.meshPerAttribute), void 0 === t.maxInstancedCount && (t.maxInstancedCount = c.meshPerAttribute * c.count)) : g.enableAttribute(l), p.bindBuffer(34962, d), p.vertexAttribPointer(l, h, v, u, 0, 0)
                            } else if ("instanceMatrix" === s) {
                                var M;
                                if (void 0 === (M = w.get(e.instanceMatrix))) continue;
                                d = M.buffer, v = M.type;
                                g.enableAttributeAndDivisor(l + 0, 1), g.enableAttributeAndDivisor(l + 1, 1), g.enableAttributeAndDivisor(l + 2, 1), g.enableAttributeAndDivisor(l + 3, 1), p.bindBuffer(34962, d), p.vertexAttribPointer(l + 0, 4, v, !1, 64, 0), p.vertexAttribPointer(l + 1, 4, v, !1, 64, 16), p.vertexAttribPointer(l + 2, 4, v, !1, 64, 32), p.vertexAttribPointer(l + 3, 4, v, !1, 64, 48)
                            } else if (void 0 !== a) {
                                var T = a[s];
                                if (void 0 !== T) switch (T.length) {
                                    case 2:
                                        p.vertexAttrib2fv(l, T);
                                        break;
                                    case 3:
                                        p.vertexAttrib3fv(l, T);
                                        break;
                                    case 4:
                                        p.vertexAttrib4fv(l, T);
                                        break;
                                    default:
                                        p.vertexAttrib1fv(l, T)
                                }
                            }
                        }
                    }
                    g.disableUnusedAttributes()
                }(r, n, i, s), null !== c && p.bindBuffer(34963, h.buffer));
                var y = null !== c ? c.count : u.count,
                    x = n.drawRange.start * d,
                    _ = n.drawRange.count * d,
                    M = null !== o ? o.start * d : 0,
                    T = null !== o ? o.count * d : 1 / 0,
                    S = Math.max(x, M),
                    E = Math.min(y, x + _, M + T) - 1,
                    P = Math.max(0, E - S + 1);
                if (0 !== P) {
                    if (r.isMesh) !0 === i.wireframe ? (g.setLineWidth(i.wireframeLinewidth * oe()), v.setMode(1)) : v.setMode(4);
                    else if (r.isLine) {
                        var R = i.linewidth;
                        void 0 === R && (R = 1), g.setLineWidth(R * oe()), r.isLineSegments ? v.setMode(1) : r.isLineLoop ? v.setMode(2) : v.setMode(3)
                    } else r.isPoints ? v.setMode(0) : r.isSprite && v.setMode(4);
                    r.isInstancedMesh ? v.renderInstances(n, S, P, r.count) : n.isInstancedBufferGeometry ? v.renderInstances(n, S, P, n.maxInstancedCount) : v.render(S, P)
                }
            }, this.compile = function (e, t) {
                (d = S.get(e, t)).init(), e.traverse((function (e) {
                    e.isLight && (d.pushLight(e), e.castShadow && d.pushShadow(e))
                })), d.setupLights(t);
                var n = {};
                e.traverse((function (t) {
                    if (t.material)
                        if (Array.isArray(t.material))
                            for (var i = 0; i < t.material.length; i++) t.material[i].uuid in n == !1 && (we(t.material[i], e, t), n[t.material[i].uuid] = !0);
                        else t.material.uuid in n == !1 && (we(t.material, e, t), n[t.material.uuid] = !0)
                }))
            };
            var me = null;
            var ge = new Os;

            function ve(e, t, n, i) {
                if (!1 !== e.visible) {
                    if (e.layers.test(t.layers))
                        if (e.isGroup) n = e.renderOrder;
                        else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                        else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);
                        else if (e.isSprite) {
                            if (!e.frustumCulled || K.intersectsSprite(e)) {
                                i && re.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ie);
                                var r = _.update(e);
                                (o = e.material).visible && h.push(e, r, o, n, re.z, null)
                            }
                        } else if (e.isImmediateRenderObject) i && re.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ie), h.push(e, null, e.material, n, re.z, null);
                        else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== v.render.frame && (e.skeleton.update(), e.skeleton.frame = v.render.frame), !e.frustumCulled || K.intersectsObject(e))) {
                            i && re.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ie);
                            r = _.update(e);
                            var o = e.material;
                            if (Array.isArray(o))
                                for (var a = r.groups, s = 0, l = a.length; s < l; s++) {
                                    var c = a[s],
                                        u = o[c.materialIndex];
                                    u && u.visible && h.push(e, r, u, n, re.z, c)
                                } else o.visible && h.push(e, r, o, n, re.z, null)
                        }
                    var p = e.children;
                    for (s = 0, l = p.length; s < l; s++) ve(p[s], t, n, i)
                }
            }

            function ye(e, t, n, i) {
                for (var r = 0, o = e.length; r < o; r++) {
                    var a = e[r],
                        s = a.object,
                        l = a.geometry,
                        c = void 0 === i ? a.material : i,
                        u = a.group;
                    if (n.isArrayCamera) {
                        U = n;
                        for (var h = n.cameras, p = 0, f = h.length; p < f; p++) {
                            var m = h[p];
                            s.layers.test(m.layers) && (g.viewport(j.copy(m.viewport)), d.setupLights(m), xe(s, t, m, l, c, u))
                        }
                    } else U = null, xe(s, t, n, l, c, u)
                }
            }

            function xe(e, t, n, i, r, o) {
                if (e.onBeforeRender(R, t, n, i, r, o), d = S.get(t, U || n), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                    var a = be(n, t, r, e);
                    g.setMaterial(r), H.geometry = null, H.program = null, H.wireframe = !1,
                        function (e, t) {
                            e.render((function (e) {
                                R.renderBufferImmediate(e, t)
                            }))
                        }(e, a)
                } else R.renderBufferDirect(n, t, i, r, e, o);
                e.onAfterRender(R, t, n, i, r, o), d = S.get(t, U || n)
            }

            function we(e, t, n) {
                var i = y.get(e),
                    r = d.state.lights,
                    o = d.state.shadowsArray,
                    a = r.state.version,
                    s = M.getParameters(e, r.state, o, t, ee.numPlanes, ee.numIntersection, n),
                    l = M.getProgramCacheKey(s),
                    c = i.program,
                    u = !0;
                if (void 0 === c) e.addEventListener("dispose", de);
                else if (c.cacheKey !== l) pe(e);
                else if (i.lightsStateVersion !== a) i.lightsStateVersion = a, u = !1;
                else {
                    if (void 0 !== s.shaderID) return;
                    u = !1
                }
                u && (c = M.acquireProgram(s, l), i.program = c, i.uniforms = s.uniforms, i.environment = e.isMeshStandardMaterial ? t.environment : null, i.outputEncoding = R.outputEncoding, e.program = c);
                var h = c.getAttributes();
                if (e.morphTargets) {
                    e.numSupportedMorphTargets = 0;
                    for (var p = 0; p < R.maxMorphTargets; p++) h["morphTarget" + p] >= 0 && e.numSupportedMorphTargets++
                }
                if (e.morphNormals) {
                    e.numSupportedMorphNormals = 0;
                    for (p = 0; p < R.maxMorphNormals; p++) h["morphNormal" + p] >= 0 && e.numSupportedMorphNormals++
                }
                var f = i.uniforms;
                (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (i.numClippingPlanes = ee.numPlanes, i.numIntersection = ee.numIntersection, f.clippingPlanes = ee.uniform), i.fog = t.fog, i.needsLights = function (e) {
                    return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                }(e), i.lightsStateVersion = a, i.needsLights && (f.ambientLightColor.value = r.state.ambient, f.lightProbe.value = r.state.probe, f.directionalLights.value = r.state.directional, f.directionalLightShadows.value = r.state.directionalShadow, f.spotLights.value = r.state.spot, f.spotLightShadows.value = r.state.spotShadow, f.rectAreaLights.value = r.state.rectArea, f.pointLights.value = r.state.point, f.pointLightShadows.value = r.state.pointShadow, f.hemisphereLights.value = r.state.hemi, f.directionalShadowMap.value = r.state.directionalShadowMap, f.directionalShadowMatrix.value = r.state.directionalShadowMatrix, f.spotShadowMap.value = r.state.spotShadowMap, f.spotShadowMatrix.value = r.state.spotShadowMatrix, f.pointShadowMap.value = r.state.pointShadowMap, f.pointShadowMatrix.value = r.state.pointShadowMatrix);
                var m = i.program.getUniforms(),
                    g = ql.seqWithValue(m.seq, f);
                i.uniformsList = g
            }

            function be(e, t, n, i) {
                x.resetTextureUnits();
                var r = t.fog,
                    o = n.isMeshStandardMaterial ? t.environment : null,
                    a = y.get(n),
                    s = d.state.lights;
                if (te && (ne || e !== B)) {
                    var l = e === B && n.id === F;
                    ee.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, a, l)
                }
                n.version === a.__version ? void 0 === a.program || n.fog && a.fog !== r || a.environment !== o || a.needsLights && a.lightsStateVersion !== s.state.version ? we(n, t, i) : void 0 === a.numClippingPlanes || a.numClippingPlanes === ee.numPlanes && a.numIntersection === ee.numIntersection ? a.outputEncoding !== R.outputEncoding && we(n, t, i) : we(n, t, i) : (we(n, t, i), a.__version = n.version);
                var c, u, h = !1,
                    f = !1,
                    v = !1,
                    w = a.program,
                    b = w.getUniforms(),
                    _ = a.uniforms;
                if (g.useProgram(w.program) && (h = !0, f = !0, v = !0), n.id !== F && (F = n.id, f = !0), h || B !== e) {
                    if (b.setValue(p, "projectionMatrix", e.projectionMatrix), m.logarithmicDepthBuffer && b.setValue(p, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), B !== e && (B = e, f = !0, v = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                        var M = b.map.cameraPosition;
                        void 0 !== M && M.setValue(p, re.setFromMatrixPosition(e.matrixWorld))
                    } (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && b.setValue(p, "isOrthographic", !0 === e.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && b.setValue(p, "viewMatrix", e.matrixWorldInverse)
                }
                if (n.skinning) {
                    b.setOptional(p, i, "bindMatrix"), b.setOptional(p, i, "bindMatrixInverse");
                    var T = i.skeleton;
                    if (T) {
                        var S = T.bones;
                        if (m.floatVertexTextures) {
                            if (void 0 === T.boneTexture) {
                                var E = Math.sqrt(4 * S.length);
                                E = Ur.ceilPowerOfTwo(E), E = Math.max(E, 4);
                                var A = new Float32Array(E * E * 4);
                                A.set(T.boneMatrices);
                                var C = new As(A, E, E, _r, yr);
                                T.boneMatrices = A, T.boneTexture = C, T.boneTextureSize = E
                            }
                            b.setValue(p, "boneTexture", T.boneTexture, x), b.setValue(p, "boneTextureSize", T.boneTextureSize)
                        } else b.setOptional(p, T, "boneMatrices")
                    }
                }
                return (f || a.receiveShadow !== i.receiveShadow) && (a.receiveShadow = i.receiveShadow, b.setValue(p, "receiveShadow", i.receiveShadow)), f && (b.setValue(p, "toneMappingExposure", R.toneMappingExposure), b.setValue(p, "toneMappingWhitePoint", R.toneMappingWhitePoint), a.needsLights && (u = v, (c = _).ambientLightColor.needsUpdate = u, c.lightProbe.needsUpdate = u, c.directionalLights.needsUpdate = u, c.directionalLightShadows.needsUpdate = u, c.pointLights.needsUpdate = u, c.pointLightShadows.needsUpdate = u, c.spotLights.needsUpdate = u, c.spotLightShadows.needsUpdate = u, c.rectAreaLights.needsUpdate = u, c.hemisphereLights.needsUpdate = u), r && n.fog && function (e, t) {
                    e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
                }(_, r), n.isMeshBasicMaterial ? _e(_, n) : n.isMeshLambertMaterial ? (_e(_, n), function (e, t) {
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
                }(_, n)) : n.isMeshToonMaterial ? (_e(_, n), function (e, t) {
                    e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.gradientMap && (e.gradientMap.value = t.gradientMap);
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(_, n)) : n.isMeshPhongMaterial ? (_e(_, n), function (e, t) {
                    e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(_, n)) : n.isMeshStandardMaterial ? (_e(_, n, o), n.isMeshPhysicalMaterial ? function (e, t, n) {
                    Me(e, t, n), e.reflectivity.value = t.reflectivity, e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.sheen && e.sheen.value.copy(t.sheen);
                    t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap);
                    t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap);
                    t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, 1 === t.side && e.clearcoatNormalScale.value.negate());
                    e.transparency.value = t.transparency
                }(_, n, o) : Me(_, n, o)) : n.isMeshMatcapMaterial ? (_e(_, n), function (e, t) {
                    t.matcap && (e.matcap.value = t.matcap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(_, n)) : n.isMeshDepthMaterial ? (_e(_, n), function (e, t) {
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(_, n)) : n.isMeshDistanceMaterial ? (_e(_, n), function (e, t) {
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
                    e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
                }(_, n)) : n.isMeshNormalMaterial ? (_e(_, n), function (e, t) {
                    t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(_, n)) : n.isLineBasicMaterial ? (function (e, t) {
                    e.diffuse.value.copy(t.color), e.opacity.value = t.opacity
                }(_, n), n.isLineDashedMaterial && function (e, t) {
                    e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                }(_, n)) : n.isPointsMaterial ? function (e, t) {
                    e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * $, e.scale.value = .5 * q, t.map && (e.map.value = t.map);
                    t.alphaMap && (e.alphaMap.value = t.alphaMap);
                    var n;
                    t.map ? n = t.map : t.alphaMap && (n = t.alphaMap);
                    void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
                }(_, n) : n.isSpriteMaterial ? function (e, t) {
                    e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map);
                    t.alphaMap && (e.alphaMap.value = t.alphaMap);
                    var n;
                    t.map ? n = t.map : t.alphaMap && (n = t.alphaMap);
                    void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
                }(_, n) : n.isShadowMaterial && (_.color.value.copy(n.color), _.opacity.value = n.opacity), void 0 !== _.ltc_1 && (_.ltc_1.value = Rs.LTC_1), void 0 !== _.ltc_2 && (_.ltc_2.value = Rs.LTC_2), ql.upload(p, a.uniformsList, _, x), n.isShaderMaterial && (n.uniformsNeedUpdate = !1)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (ql.upload(p, a.uniformsList, _, x), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && b.setValue(p, "center", i.center), b.setValue(p, "modelViewMatrix", i.modelViewMatrix), b.setValue(p, "normalMatrix", i.normalMatrix), b.setValue(p, "modelMatrix", i.matrixWorld), w
            }

            function _e(e, t, n) {
                e.opacity.value = t.opacity, t.color && e.diffuse.value.copy(t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap);
                var i, r, o = t.envMap || n;
                o && (e.envMap.value = o, e.flipEnvMap.value = o.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = y.get(o).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map ? i = t.map : t.specularMap ? i = t.specularMap : t.displacementMap ? i = t.displacementMap : t.normalMap ? i = t.normalMap : t.bumpMap ? i = t.bumpMap : t.roughnessMap ? i = t.roughnessMap : t.metalnessMap ? i = t.metalnessMap : t.alphaMap ? i = t.alphaMap : t.emissiveMap && (i = t.emissiveMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix)), t.aoMap ? r = t.aoMap : t.lightMap && (r = t.lightMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uv2Transform.value.copy(r.matrix))
            }

            function Me(e, t, n) {
                e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), (t.envMap || n) && (e.envMapIntensity.value = t.envMapIntensity)
            }
            ge.setAnimationLoop((function (e) {
                le.isPresenting || me && me(e)
            })), "undefined" != typeof window && ge.setContext(window), this.setAnimationLoop = function (e) {
                me = e, le.setAnimationLoop(e), ge.start()
            }, this.render = function (e, t) {
                var n, i;
                if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), t && t.isCamera) {
                    if (!O) {
                        H.geometry = null, H.program = null, H.wireframe = !1, F = -1, B = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), le.enabled && le.isPresenting && (t = le.getCamera(t)), (d = S.get(e, t)).init(), e.onBeforeRender(R, e, t, n || I), ie.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), K.setFromProjectionMatrix(ie), ne = this.localClippingEnabled, te = ee.init(this.clippingPlanes, ne, t), (h = T.get(e, t)).init(), ve(e, t, 0, R.sortObjects), h.finish(), !0 === R.sortObjects && h.sort(X, Y), te && ee.beginShadows();
                        var r = d.state.shadowsArray;
                        ce.render(r, e, t), d.setupLights(t), te && ee.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), E.render(h, e, t, i);
                        var o = h.opaque,
                            a = h.transparent;
                        if (e.overrideMaterial) {
                            var s = e.overrideMaterial;
                            o.length && ye(o, e, t, s), a.length && ye(a, e, t, s)
                        } else o.length && ye(o, e, t), a.length && ye(a, e, t);
                        e.onAfterRender(R, e, t), null !== I && (x.updateRenderTargetMipmap(I), x.updateMultisampleRenderTarget(I)), g.buffers.depth.setTest(!0), g.buffers.depth.setMask(!0), g.buffers.color.setMask(!0), g.setPolygonOffset(!1), h = null, d = null
                    }
                } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
            }, this.setFramebuffer = function (e) {
                D !== e && null === I && p.bindFramebuffer(36160, e), D = e
            }, this.getActiveCubeFace = function () {
                return k
            }, this.getActiveMipmapLevel = function () {
                return N
            }, this.getRenderTarget = function () {
                return I
            }, this.setRenderTarget = function (e, t, n) {
                I = e, k = t, N = n, e && void 0 === y.get(e).__webglFramebuffer && x.setupRenderTarget(e);
                var i = D,
                    r = !1;
                if (e) {
                    var o = y.get(e).__webglFramebuffer;
                    e.isWebGLCubeRenderTarget ? (i = o[t || 0], r = !0) : i = e.isWebGLMultisampleRenderTarget ? y.get(e).__webglMultisampledFramebuffer : o, j.copy(e.viewport), G.copy(e.scissor), V = e.scissorTest
                } else j.copy(Z).multiplyScalar($).floor(), G.copy(J).multiplyScalar($).floor(), V = Q;
                if (z !== i && (p.bindFramebuffer(36160, i), z = i), g.viewport(j), g.scissor(G), g.setScissorTest(V), r) {
                    var a = y.get(e.texture);
                    p.framebufferTexture2D(36160, 36064, 34069 + (t || 0), a.__webglTexture, n || 0)
                }
            }, this.readRenderTargetPixels = function (e, t, n, i, r, o, a) {
                if (e && e.isWebGLRenderTarget) {
                    var s = y.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== a && (s = s[a]), s) {
                        var l = !1;
                        s !== z && (p.bindFramebuffer(36160, s), l = !0);
                        try {
                            var c = e.texture,
                                u = c.format,
                                h = c.type;
                            if (u !== _r && P.convert(u) !== p.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (!(h === mr || P.convert(h) === p.getParameter(35738) || h === yr && (m.isWebGL2 || f.get("OES_texture_float") || f.get("WEBGL_color_buffer_float")) || h === xr && (m.isWebGL2 ? f.get("EXT_color_buffer_float") : f.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            36053 === p.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && p.readPixels(t, n, i, r, P.convert(u), P.convert(h), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            l && p.bindFramebuffer(36160, z)
                        }
                    }
                } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
            }, this.copyFramebufferToTexture = function (e, t, n) {
                void 0 === n && (n = 0);
                var i = Math.pow(2, -n),
                    r = Math.floor(t.image.width * i),
                    o = Math.floor(t.image.height * i),
                    a = P.convert(t.format);
                x.setTexture2D(t, 0), p.copyTexImage2D(3553, n, a, e.x, e.y, r, o, 0), g.unbindTexture()
            }, this.copyTextureToTexture = function (e, t, n, i) {
                var r = t.image.width,
                    o = t.image.height,
                    a = P.convert(n.format),
                    s = P.convert(n.type);
                x.setTexture2D(n, 0), t.isDataTexture ? p.texSubImage2D(3553, i || 0, e.x, e.y, r, o, a, s, t.image.data) : p.texSubImage2D(3553, i || 0, e.x, e.y, a, s, t.image), g.unbindTexture()
            }, this.initTexture = function (e) {
                x.setTexture2D(e, 0), g.unbindTexture()
            }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }

        function kc(e, t) {
            this.name = "", this.color = new va(e), this.density = void 0 !== t ? t : 25e-5
        }

        function Nc(e, t, n) {
            this.name = "", this.color = new va(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
        }

        function Ic(e, t) {
            this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = Nr, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }
        Pc.prototype = Object.assign(Object.create(Ms.prototype), {
            constructor: Pc,
            isArrayCamera: !0
        }), Rc.prototype = Object.assign(Object.create(Eo.prototype), {
            constructor: Rc,
            isGroup: !0
        }), Object.assign(Oc.prototype, zr.prototype), Object.assign(kc.prototype, {
            isFogExp2: !0,
            clone: function () {
                return new kc(this.color, this.density)
            },
            toJSON: function () {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }), Object.assign(Nc.prototype, {
            isFog: !0,
            clone: function () {
                return new Nc(this.color, this.near, this.far)
            },
            toJSON: function () {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }), Object.defineProperty(Ic.prototype, "needsUpdate", {
            set: function (e) {
                !0 === e && this.version++
            }
        }), Object.assign(Ic.prototype, {
            isInterleavedBuffer: !0,
            onUploadCallback: function () { },
            setUsage: function (e) {
                return this.usage = e, this
            },
            copy: function (e) {
                return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
            },
            copyAt: function (e, t, n) {
                e *= this.stride, n *= t.stride;
                for (var i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
                return this
            },
            set: function (e, t) {
                return void 0 === t && (t = 0), this.array.set(e, t), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            onUpload: function (e) {
                return this.onUploadCallback = e, this
            }
        });
        var zc, Fc = new Kr;

        function Hc(e, t, n, i) {
            this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === i
        }

        function Bc(e) {
            Ma.call(this), this.type = "SpriteMaterial", this.color = new va(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e)
        }
        Object.defineProperties(Hc.prototype, {
            count: {
                get: function () {
                    return this.data.count
                }
            },
            array: {
                get: function () {
                    return this.data.array
                }
            }
        }), Object.assign(Hc.prototype, {
            isInterleavedBufferAttribute: !0,
            applyMatrix4: function (e) {
                for (var t = 0, n = this.data.count; t < n; t++) Fc.x = this.getX(t), Fc.y = this.getY(t), Fc.z = this.getZ(t), Fc.applyMatrix4(e), this.setXYZ(t, Fc.x, Fc.y, Fc.z);
                return this
            },
            setX: function (e, t) {
                return this.data.array[e * this.data.stride + this.offset] = t, this
            },
            setY: function (e, t) {
                return this.data.array[e * this.data.stride + this.offset + 1] = t, this
            },
            setZ: function (e, t) {
                return this.data.array[e * this.data.stride + this.offset + 2] = t, this
            },
            setW: function (e, t) {
                return this.data.array[e * this.data.stride + this.offset + 3] = t, this
            },
            getX: function (e) {
                return this.data.array[e * this.data.stride + this.offset]
            },
            getY: function (e) {
                return this.data.array[e * this.data.stride + this.offset + 1]
            },
            getZ: function (e) {
                return this.data.array[e * this.data.stride + this.offset + 2]
            },
            getW: function (e) {
                return this.data.array[e * this.data.stride + this.offset + 3]
            },
            setXY: function (e, t, n) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
            },
            setXYZ: function (e, t, n, i) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
            },
            setXYZW: function (e, t, n, i, r) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this
            }
        }), Bc.prototype = Object.create(Ma.prototype), Bc.prototype.constructor = Bc, Bc.prototype.isSpriteMaterial = !0, Bc.prototype.copy = function (e) {
            return Ma.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
        };
        var Uc = new Kr,
            jc = new Kr,
            Gc = new Kr,
            Vc = new jr,
            Wc = new jr,
            qc = new so,
            $c = new Kr,
            Xc = new Kr,
            Yc = new Kr,
            Zc = new jr,
            Jc = new jr,
            Qc = new jr;

        function Kc(e) {
            if (Eo.call(this), this.type = "Sprite", void 0 === zc) {
                zc = new Wa;
                var t = new Ic(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                zc.setIndex([0, 1, 2, 0, 2, 3]), zc.setAttribute("position", new Hc(t, 3, 0, !1)), zc.setAttribute("uv", new Hc(t, 2, 3, !1))
            }
            this.geometry = zc, this.material = void 0 !== e ? e : new Bc, this.center = new jr(.5, .5)
        }

        function eu(e, t, n, i, r, o) {
            Vc.subVectors(e, n).addScalar(.5).multiply(i), void 0 !== r ? (Wc.x = o * Vc.x - r * Vc.y, Wc.y = r * Vc.x + o * Vc.y) : Wc.copy(Vc), e.copy(t), e.x += Wc.x, e.y += Wc.y, e.applyMatrix4(qc)
        }
        Kc.prototype = Object.assign(Object.create(Eo.prototype), {
            constructor: Kc,
            isSprite: !0,
            raycast: function (e, t) {
                null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), jc.setFromMatrixScale(this.matrixWorld), qc.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Gc.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && jc.multiplyScalar(-Gc.z);
                var n, i, r = this.material.rotation;
                0 !== r && (i = Math.cos(r), n = Math.sin(r));
                var o = this.center;
                eu($c.set(-.5, -.5, 0), Gc, o, jc, n, i), eu(Xc.set(.5, -.5, 0), Gc, o, jc, n, i), eu(Yc.set(.5, .5, 0), Gc, o, jc, n, i), Zc.set(0, 0), Jc.set(1, 0), Qc.set(1, 1);
                var a = e.ray.intersectTriangle($c, Xc, Yc, !1, Uc);
                if (null !== a || (eu(Xc.set(-.5, .5, 0), Gc, o, jc, n, i), Jc.set(0, 1), null !== (a = e.ray.intersectTriangle($c, Yc, Xc, !1, Uc)))) {
                    var s = e.ray.origin.distanceTo(Uc);
                    s < e.near || s > e.far || t.push({
                        distance: s,
                        point: Uc.clone(),
                        uv: pa.getUV(Uc, $c, Xc, Yc, Zc, Jc, Qc, new jr),
                        face: null,
                        object: this
                    })
                }
            },
            clone: function () {
                return new this.constructor(this.material).copy(this)
            },
            copy: function (e) {
                return Eo.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this
            }
        });
        var tu = new Kr,
            nu = new Kr;

        function iu() {
            Eo.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                levels: {
                    enumerable: !0,
                    value: []
                }
            }), this.autoUpdate = !0
        }

        function ru(e, t) {
            e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), cs.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new so, this.bindMatrixInverse = new so
        }
        iu.prototype = Object.assign(Object.create(Eo.prototype), {
            constructor: iu,
            isLOD: !0,
            copy: function (e) {
                Eo.prototype.copy.call(this, e, !1);
                for (var t = e.levels, n = 0, i = t.length; n < i; n++) {
                    var r = t[n];
                    this.addLevel(r.object.clone(), r.distance)
                }
                return this.autoUpdate = e.autoUpdate, this
            },
            addLevel: function (e, t) {
                void 0 === t && (t = 0), t = Math.abs(t);
                for (var n = this.levels, i = 0; i < n.length && !(t < n[i].distance); i++);
                return n.splice(i, 0, {
                    distance: t,
                    object: e
                }), this.add(e), this
            },
            getCurrentLevel: function () {
                return this._currentLevel
            },
            getObjectForDistance: function (e) {
                var t = this.levels;
                if (t.length > 0) {
                    for (var n = 1, i = t.length; n < i && !(e < t[n].distance); n++);
                    return t[n - 1].object
                }
                return null
            },
            raycast: function (e, t) {
                if (this.levels.length > 0) {
                    tu.setFromMatrixPosition(this.matrixWorld);
                    var n = e.ray.origin.distanceTo(tu);
                    this.getObjectForDistance(n).raycast(e, t)
                }
            },
            update: function (e) {
                var t = this.levels;
                if (t.length > 1) {
                    tu.setFromMatrixPosition(e.matrixWorld), nu.setFromMatrixPosition(this.matrixWorld);
                    var n = tu.distanceTo(nu) / e.zoom;
                    t[0].object.visible = !0;
                    for (var i = 1, r = t.length; i < r && n >= t[i].distance; i++) t[i - 1].object.visible = !1, t[i].object.visible = !0;
                    for (this._currentLevel = i - 1; i < r; i++) t[i].object.visible = !1
                }
            },
            toJSON: function (e) {
                var t = Eo.prototype.toJSON.call(this, e);
                !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = [];
                for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
                    var o = n[i];
                    t.object.levels.push({
                        object: o.object.uuid,
                        distance: o.distance
                    })
                }
                return t
            }
        }), ru.prototype = Object.assign(Object.create(cs.prototype), {
            constructor: ru,
            isSkinnedMesh: !0,
            bind: function (e, t) {
                this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
            },
            pose: function () {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function () {
                for (var e = new $r, t = this.geometry.attributes.skinWeight, n = 0, i = t.count; n < i; n++) {
                    e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
                    var r = 1 / e.manhattanLength();
                    r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                }
            },
            updateMatrixWorld: function (e) {
                cs.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        });
        var ou = new so,
            au = new so;

        function su(e, t) {
            if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === t) this.calculateInverses();
            else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
            else {
                console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                for (var n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new so)
            }
        }

        function lu() {
            Eo.call(this), this.type = "Bone"
        }
        Object.assign(su.prototype, {
            calculateInverses: function () {
                this.boneInverses = [];
                for (var e = 0, t = this.bones.length; e < t; e++) {
                    var n = new so;
                    this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n)
                }
            },
            pose: function () {
                var e, t, n;
                for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
                for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
            },
            update: function () {
                for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture, r = 0, o = e.length; r < o; r++) {
                    var a = e[r] ? e[r].matrixWorld : au;
                    ou.multiplyMatrices(a, t[r]), ou.toArray(n, 16 * r)
                }
                void 0 !== i && (i.needsUpdate = !0)
            },
            clone: function () {
                return new su(this.bones, this.boneInverses)
            },
            getBoneByName: function (e) {
                for (var t = 0, n = this.bones.length; t < n; t++) {
                    var i = this.bones[t];
                    if (i.name === e) return i
                }
            },
            dispose: function () {
                this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0)
            }
        }), lu.prototype = Object.assign(Object.create(Eo.prototype), {
            constructor: lu,
            isBone: !0
        });
        var cu = new so,
            uu = new so,
            hu = [],
            du = new cs;

        function pu(e, t, n) {
            cs.call(this, e, t), this.instanceMatrix = new Ea(new Float32Array(16 * n), 16), this.count = n, this.frustumCulled = !1
        }

        function fu(e) {
            Ma.call(this), this.type = "LineBasicMaterial", this.color = new va(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e)
        }
        pu.prototype = Object.assign(Object.create(cs.prototype), {
            constructor: pu,
            isInstancedMesh: !0,
            getMatrixAt: function (e, t) {
                t.fromArray(this.instanceMatrix.array, 16 * e)
            },
            raycast: function (e, t) {
                var n = this.matrixWorld,
                    i = this.count;
                if (du.geometry = this.geometry, du.material = this.material, void 0 !== du.material)
                    for (var r = 0; r < i; r++) this.getMatrixAt(r, cu), uu.multiplyMatrices(n, cu), du.matrixWorld = uu, du.raycast(e, hu), hu.length > 0 && (hu[0].instanceId = r, hu[0].object = this, t.push(hu[0]), hu.length = 0)
            },
            setMatrixAt: function (e, t) {
                t.toArray(this.instanceMatrix.array, 16 * e)
            },
            updateMorphTargets: function () { }
        }), fu.prototype = Object.create(Ma.prototype), fu.prototype.constructor = fu, fu.prototype.isLineBasicMaterial = !0, fu.prototype.copy = function (e) {
            return Ma.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
        };
        var mu = new Kr,
            gu = new Kr,
            vu = new so,
            yu = new Qo,
            xu = new Vo;

        function wu(e, t, n) {
            1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), Eo.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new Wa, this.material = void 0 !== t ? t : new fu
        }
        wu.prototype = Object.assign(Object.create(Eo.prototype), {
            constructor: wu,
            isLine: !0,
            computeLineDistances: function () {
                var e = this.geometry;
                if (e.isBufferGeometry)
                    if (null === e.index) {
                        for (var t = e.attributes.position, n = [0], i = 1, r = t.count; i < r; i++) mu.fromBufferAttribute(t, i - 1), gu.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += mu.distanceTo(gu);
                        e.setAttribute("lineDistance", new ka(n, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (e.isGeometry) {
                    var o = e.vertices;
                    (n = e.lineDistances)[0] = 0;
                    for (i = 1, r = o.length; i < r; i++) n[i] = n[i - 1], n[i] += o[i - 1].distanceTo(o[i])
                }
                return this
            },
            raycast: function (e, t) {
                var n = this.geometry,
                    i = this.matrixWorld,
                    r = e.params.Line.threshold;
                if (null === n.boundingSphere && n.computeBoundingSphere(), xu.copy(n.boundingSphere), xu.applyMatrix4(i), xu.radius += r, !1 !== e.ray.intersectsSphere(xu)) {
                    vu.getInverse(i), yu.copy(e.ray).applyMatrix4(vu);
                    var o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        a = o * o,
                        s = new Kr,
                        l = new Kr,
                        c = new Kr,
                        u = new Kr,
                        h = this && this.isLineSegments ? 2 : 1;
                    if (n.isBufferGeometry) {
                        var d = n.index,
                            p = n.attributes.position.array;
                        if (null !== d)
                            for (var f = d.array, m = 0, g = f.length - 1; m < g; m += h) {
                                var v = f[m],
                                    y = f[m + 1];
                                if (s.fromArray(p, 3 * v), l.fromArray(p, 3 * y), !(yu.distanceSqToSegment(s, l, u, c) > a)) u.applyMatrix4(this.matrixWorld), (b = e.ray.origin.distanceTo(u)) < e.near || b > e.far || t.push({
                                    distance: b,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: m,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            } else
                            for (m = 0, g = p.length / 3 - 1; m < g; m += h) {
                                if (s.fromArray(p, 3 * m), l.fromArray(p, 3 * m + 3), !(yu.distanceSqToSegment(s, l, u, c) > a)) u.applyMatrix4(this.matrixWorld), (b = e.ray.origin.distanceTo(u)) < e.near || b > e.far || t.push({
                                    distance: b,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: m,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                    } else if (n.isGeometry) {
                        var x = n.vertices,
                            w = x.length;
                        for (m = 0; m < w - 1; m += h) {
                            var b;
                            if (!(yu.distanceSqToSegment(x[m], x[m + 1], u, c) > a)) u.applyMatrix4(this.matrixWorld), (b = e.ray.origin.distanceTo(u)) < e.near || b > e.far || t.push({
                                distance: b,
                                point: c.clone().applyMatrix4(this.matrixWorld),
                                index: m,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                }
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        });
        var bu = new Kr,
            _u = new Kr;

        function Mu(e, t) {
            wu.call(this, e, t), this.type = "LineSegments"
        }

        function Tu(e, t) {
            wu.call(this, e, t), this.type = "LineLoop"
        }

        function Su(e) {
            Ma.call(this), this.type = "PointsMaterial", this.color = new va(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e)
        }
        Mu.prototype = Object.assign(Object.create(wu.prototype), {
            constructor: Mu,
            isLineSegments: !0,
            computeLineDistances: function () {
                var e = this.geometry;
                if (e.isBufferGeometry)
                    if (null === e.index) {
                        for (var t = e.attributes.position, n = [], i = 0, r = t.count; i < r; i += 2) bu.fromBufferAttribute(t, i), _u.fromBufferAttribute(t, i + 1), n[i] = 0 === i ? 0 : n[i - 1], n[i + 1] = n[i] + bu.distanceTo(_u);
                        e.setAttribute("lineDistance", new ka(n, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (e.isGeometry) {
                    var o = e.vertices;
                    for (n = e.lineDistances, i = 0, r = o.length; i < r; i += 2) bu.copy(o[i]), _u.copy(o[i + 1]), n[i] = 0 === i ? 0 : n[i - 1], n[i + 1] = n[i] + bu.distanceTo(_u)
                }
                return this
            }
        }), Tu.prototype = Object.assign(Object.create(wu.prototype), {
            constructor: Tu,
            isLineLoop: !0
        }), Su.prototype = Object.create(Ma.prototype), Su.prototype.constructor = Su, Su.prototype.isPointsMaterial = !0, Su.prototype.copy = function (e) {
            return Ma.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
        };
        var Eu = new so,
            Au = new Qo,
            Cu = new Vo,
            Lu = new Kr;

        function Pu(e, t) {
            Eo.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new Wa, this.material = void 0 !== t ? t : new Su, this.updateMorphTargets()
        }

        function Ru(e, t, n, i, r, o, a) {
            var s = Au.distanceSqToPoint(e);
            if (s < n) {
                var l = new Kr;
                Au.closestPointToPoint(e, l), l.applyMatrix4(i);
                var c = r.ray.origin.distanceTo(l);
                if (c < r.near || c > r.far) return;
                o.push({
                    distance: c,
                    distanceToRay: Math.sqrt(s),
                    point: l,
                    index: t,
                    face: null,
                    object: a
                })
            }
        }

        function Ou(e, t, n, i, r, o, a, s, l) {
            qr.call(this, e, t, n, i, r, o, a, s, l), this.format = void 0 !== a ? a : br, this.minFilter = void 0 !== o ? o : pr, this.magFilter = void 0 !== r ? r : pr, this.generateMipmaps = !1
        }

        function Du(e, t, n, i, r, o, a, s, l, c, u, h) {
            qr.call(this, null, o, a, s, l, c, i, r, u, h), this.image = {
                width: t,
                height: n
            }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
        }

        function ku(e, t, n, i, r, o, a, s, l) {
            qr.call(this, e, t, n, i, r, o, a, s, l), this.needsUpdate = !0
        }

        function Nu(e, t, n, i, r, o, a, s, l, c) {
            if ((c = void 0 !== c ? c : Mr) !== Mr && c !== Tr) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === n && c === Mr && (n = gr), void 0 === n && c === Tr && (n = wr), qr.call(this, null, i, r, o, a, s, c, n, l), this.image = {
                width: e,
                height: t
            }, this.magFilter = void 0 !== a ? a : ur, this.minFilter = void 0 !== s ? s : ur, this.flipY = !1, this.generateMipmaps = !1
        }

        function Iu(e) {
            Wa.call(this), this.type = "WireframeGeometry";
            var t, n, i, r, o, a, s, l, c, u, h = [],
                d = [0, 0],
                p = {},
                f = ["a", "b", "c"];
            if (e && e.isGeometry) {
                var m = e.faces;
                for (t = 0, i = m.length; t < i; t++) {
                    var g = m[t];
                    for (n = 0; n < 3; n++) s = g[f[n]], l = g[f[(n + 1) % 3]], d[0] = Math.min(s, l), d[1] = Math.max(s, l), void 0 === p[c = d[0] + "," + d[1]] && (p[c] = {
                        index1: d[0],
                        index2: d[1]
                    })
                }
                for (c in p) a = p[c], u = e.vertices[a.index1], h.push(u.x, u.y, u.z), u = e.vertices[a.index2], h.push(u.x, u.y, u.z)
            } else if (e && e.isBufferGeometry) {
                var v, y, x, w, b, _, M;
                if (u = new Kr, null !== e.index) {
                    for (v = e.attributes.position, y = e.index, 0 === (x = e.groups).length && (x = [{
                        start: 0,
                        count: y.count,
                        materialIndex: 0
                    }]), r = 0, o = x.length; r < o; ++r)
                        for (t = b = (w = x[r]).start, i = b + w.count; t < i; t += 3)
                            for (n = 0; n < 3; n++) s = y.getX(t + n), l = y.getX(t + (n + 1) % 3), d[0] = Math.min(s, l), d[1] = Math.max(s, l), void 0 === p[c = d[0] + "," + d[1]] && (p[c] = {
                                index1: d[0],
                                index2: d[1]
                            });
                    for (c in p) a = p[c], u.fromBufferAttribute(v, a.index1), h.push(u.x, u.y, u.z), u.fromBufferAttribute(v, a.index2), h.push(u.x, u.y, u.z)
                } else
                    for (t = 0, i = (v = e.attributes.position).count / 3; t < i; t++)
                        for (n = 0; n < 3; n++) _ = 3 * t + n, u.fromBufferAttribute(v, _), h.push(u.x, u.y, u.z), M = 3 * t + (n + 1) % 3, u.fromBufferAttribute(v, M), h.push(u.x, u.y, u.z)
            }
            this.setAttribute("position", new ka(h, 3))
        }

        function zu(e, t, n) {
            gs.call(this), this.type = "ParametricGeometry", this.parameters = {
                func: e,
                slices: t,
                stacks: n
            }, this.fromBufferGeometry(new Fu(e, t, n)), this.mergeVertices()
        }

        function Fu(e, t, n) {
            Wa.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                func: e,
                slices: t,
                stacks: n
            };
            var i, r, o = [],
                a = [],
                s = [],
                l = [],
                c = 1e-5,
                u = new Kr,
                h = new Kr,
                d = new Kr,
                p = new Kr,
                f = new Kr;
            e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
            var m = t + 1;
            for (i = 0; i <= n; i++) {
                var g = i / n;
                for (r = 0; r <= t; r++) {
                    var v = r / t;
                    e(v, g, h), a.push(h.x, h.y, h.z), v - c >= 0 ? (e(v - c, g, d), p.subVectors(h, d)) : (e(v + c, g, d), p.subVectors(d, h)), g - c >= 0 ? (e(v, g - c, d), f.subVectors(h, d)) : (e(v, g + c, d), f.subVectors(d, h)), u.crossVectors(p, f).normalize(), s.push(u.x, u.y, u.z), l.push(v, g)
                }
            }
            for (i = 0; i < n; i++)
                for (r = 0; r < t; r++) {
                    var y = i * m + r,
                        x = i * m + r + 1,
                        w = (i + 1) * m + r + 1,
                        b = (i + 1) * m + r;
                    o.push(y, x, b), o.push(x, w, b)
                }
            this.setIndex(o), this.setAttribute("position", new ka(a, 3)), this.setAttribute("normal", new ka(s, 3)), this.setAttribute("uv", new ka(l, 2))
        }

        function Hu(e, t, n, i) {
            gs.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                vertices: e,
                indices: t,
                radius: n,
                detail: i
            }, this.fromBufferGeometry(new Bu(e, t, n, i)), this.mergeVertices()
        }

        function Bu(e, t, n, i) {
            Wa.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                vertices: e,
                indices: t,
                radius: n,
                detail: i
            }, n = n || 1;
            var r = [],
                o = [];

            function a(e, t, n, i) {
                var r, o, a = Math.pow(2, i),
                    l = [];
                for (r = 0; r <= a; r++) {
                    l[r] = [];
                    var c = e.clone().lerp(n, r / a),
                        u = t.clone().lerp(n, r / a),
                        h = a - r;
                    for (o = 0; o <= h; o++) l[r][o] = 0 === o && r === a ? c : c.clone().lerp(u, o / h)
                }
                for (r = 0; r < a; r++)
                    for (o = 0; o < 2 * (a - r) - 1; o++) {
                        var d = Math.floor(o / 2);
                        o % 2 == 0 ? (s(l[r][d + 1]), s(l[r + 1][d]), s(l[r][d])) : (s(l[r][d + 1]), s(l[r + 1][d + 1]), s(l[r + 1][d]))
                    }
            }

            function s(e) {
                r.push(e.x, e.y, e.z)
            }

            function l(t, n) {
                var i = 3 * t;
                n.x = e[i + 0], n.y = e[i + 1], n.z = e[i + 2]
            }

            function c(e, t, n, i) {
                i < 0 && 1 === e.x && (o[t] = e.x - 1), 0 === n.x && 0 === n.z && (o[t] = i / 2 / Math.PI + .5)
            }

            function u(e) {
                return Math.atan2(e.z, -e.x)
            } ! function (e) {
                for (var n = new Kr, i = new Kr, r = new Kr, o = 0; o < t.length; o += 3) l(t[o + 0], n), l(t[o + 1], i), l(t[o + 2], r), a(n, i, r, e)
            }(i = i || 0),
                function (e) {
                    for (var t = new Kr, n = 0; n < r.length; n += 3) t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2], t.normalize().multiplyScalar(e), r[n + 0] = t.x, r[n + 1] = t.y, r[n + 2] = t.z
                }(n),
                function () {
                    for (var e = new Kr, t = 0; t < r.length; t += 3) {
                        e.x = r[t + 0], e.y = r[t + 1], e.z = r[t + 2];
                        var n = u(e) / 2 / Math.PI + .5,
                            i = (a = e, Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5);
                        o.push(n, 1 - i)
                    }
                    var a;
                    (function () {
                        for (var e = new Kr, t = new Kr, n = new Kr, i = new Kr, a = new jr, s = new jr, l = new jr, h = 0, d = 0; h < r.length; h += 9, d += 6) {
                            e.set(r[h + 0], r[h + 1], r[h + 2]), t.set(r[h + 3], r[h + 4], r[h + 5]), n.set(r[h + 6], r[h + 7], r[h + 8]), a.set(o[d + 0], o[d + 1]), s.set(o[d + 2], o[d + 3]), l.set(o[d + 4], o[d + 5]), i.copy(e).add(t).add(n).divideScalar(3);
                            var p = u(i);
                            c(a, d + 0, e, p), c(s, d + 2, t, p), c(l, d + 4, n, p)
                        }
                    })(),
                        function () {
                            for (var e = 0; e < o.length; e += 6) {
                                var t = o[e + 0],
                                    n = o[e + 2],
                                    i = o[e + 4],
                                    r = Math.max(t, n, i),
                                    a = Math.min(t, n, i);
                                r > .9 && a < .1 && (t < .2 && (o[e + 0] += 1), n < .2 && (o[e + 2] += 1), i < .2 && (o[e + 4] += 1))
                            }
                        }()
                }(), this.setAttribute("position", new ka(r, 3)), this.setAttribute("normal", new ka(r.slice(), 3)), this.setAttribute("uv", new ka(o, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
        }

        function Uu(e, t) {
            gs.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            }, this.fromBufferGeometry(new ju(e, t)), this.mergeVertices()
        }

        function ju(e, t) {
            Bu.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
                radius: e,
                detail: t
            }
        }

        function Gu(e, t) {
            gs.call(this), this.type = "OctahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            }, this.fromBufferGeometry(new Vu(e, t)), this.mergeVertices()
        }

        function Vu(e, t) {
            Bu.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
                radius: e,
                detail: t
            }
        }

        function Wu(e, t) {
            gs.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            }, this.fromBufferGeometry(new qu(e, t)), this.mergeVertices()
        }

        function qu(e, t) {
            var n = (1 + Math.sqrt(5)) / 2,
                i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
            Bu.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
                radius: e,
                detail: t
            }
        }

        function $u(e, t) {
            gs.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            }, this.fromBufferGeometry(new Xu(e, t)), this.mergeVertices()
        }

        function Xu(e, t) {
            var n = (1 + Math.sqrt(5)) / 2,
                i = 1 / n,
                r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i];
            Bu.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
                radius: e,
                detail: t
            }
        }

        function Yu(e, t, n, i, r, o) {
            gs.call(this), this.type = "TubeGeometry", this.parameters = {
                path: e,
                tubularSegments: t,
                radius: n,
                radialSegments: i,
                closed: r
            }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
            var a = new Zu(e, t, n, i, r);
            this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
        }

        function Zu(e, t, n, i, r) {
            Wa.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                path: e,
                tubularSegments: t,
                radius: n,
                radialSegments: i,
                closed: r
            }, t = t || 64, n = n || 1, i = i || 8, r = r || !1;
            var o = e.computeFrenetFrames(t, r);
            this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
            var a, s, l = new Kr,
                c = new Kr,
                u = new jr,
                h = new Kr,
                d = [],
                p = [],
                f = [],
                m = [];

            function g(r) {
                h = e.getPointAt(r / t, h);
                var a = o.normals[r],
                    u = o.binormals[r];
                for (s = 0; s <= i; s++) {
                    var f = s / i * Math.PI * 2,
                        m = Math.sin(f),
                        g = -Math.cos(f);
                    c.x = g * a.x + m * u.x, c.y = g * a.y + m * u.y, c.z = g * a.z + m * u.z, c.normalize(), p.push(c.x, c.y, c.z), l.x = h.x + n * c.x, l.y = h.y + n * c.y, l.z = h.z + n * c.z, d.push(l.x, l.y, l.z)
                }
            } ! function () {
                for (a = 0; a < t; a++) g(a);
                g(!1 === r ? t : 0),
                    function () {
                        for (a = 0; a <= t; a++)
                            for (s = 0; s <= i; s++) u.x = a / t, u.y = s / i, f.push(u.x, u.y)
                    }(),
                    function () {
                        for (s = 1; s <= t; s++)
                            for (a = 1; a <= i; a++) {
                                var e = (i + 1) * (s - 1) + (a - 1),
                                    n = (i + 1) * s + (a - 1),
                                    r = (i + 1) * s + a,
                                    o = (i + 1) * (s - 1) + a;
                                m.push(e, n, o), m.push(n, r, o)
                            }
                    }()
            }(), this.setIndex(m), this.setAttribute("position", new ka(d, 3)), this.setAttribute("normal", new ka(p, 3)), this.setAttribute("uv", new ka(f, 2))
        }

        function Ju(e, t, n, i, r, o, a) {
            gs.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                radius: e,
                tube: t,
                tubularSegments: n,
                radialSegments: i,
                p: r,
                q: o
            }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Qu(e, t, n, i, r, o)), this.mergeVertices()
        }

        function Qu(e, t, n, i, r, o) {
            Wa.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                radius: e,
                tube: t,
                tubularSegments: n,
                radialSegments: i,
                p: r,
                q: o
            }, e = e || 1, t = t || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, o = o || 3;
            var a, s, l = [],
                c = [],
                u = [],
                h = [],
                d = new Kr,
                p = new Kr,
                f = new Kr,
                m = new Kr,
                g = new Kr,
                v = new Kr,
                y = new Kr;
            for (a = 0; a <= n; ++a) {
                var x = a / n * r * Math.PI * 2;
                for (A(x, r, o, e, f), A(x + .01, r, o, e, m), v.subVectors(m, f), y.addVectors(m, f), g.crossVectors(v, y), y.crossVectors(g, v), g.normalize(), y.normalize(), s = 0; s <= i; ++s) {
                    var w = s / i * Math.PI * 2,
                        b = -t * Math.cos(w),
                        _ = t * Math.sin(w);
                    d.x = f.x + (b * y.x + _ * g.x), d.y = f.y + (b * y.y + _ * g.y), d.z = f.z + (b * y.z + _ * g.z), c.push(d.x, d.y, d.z), p.subVectors(d, f).normalize(), u.push(p.x, p.y, p.z), h.push(a / n), h.push(s / i)
                }
            }
            for (s = 1; s <= n; s++)
                for (a = 1; a <= i; a++) {
                    var M = (i + 1) * (s - 1) + (a - 1),
                        T = (i + 1) * s + (a - 1),
                        S = (i + 1) * s + a,
                        E = (i + 1) * (s - 1) + a;
                    l.push(M, T, E), l.push(T, S, E)
                }

            function A(e, t, n, i, r) {
                var o = Math.cos(e),
                    a = Math.sin(e),
                    s = n / t * e,
                    l = Math.cos(s);
                r.x = i * (2 + l) * .5 * o, r.y = i * (2 + l) * a * .5, r.z = i * Math.sin(s) * .5
            }
            this.setIndex(l), this.setAttribute("position", new ka(c, 3)), this.setAttribute("normal", new ka(u, 3)), this.setAttribute("uv", new ka(h, 2))
        }

        function Ku(e, t, n, i, r) {
            gs.call(this), this.type = "TorusGeometry", this.parameters = {
                radius: e,
                tube: t,
                radialSegments: n,
                tubularSegments: i,
                arc: r
            }, this.fromBufferGeometry(new eh(e, t, n, i, r)), this.mergeVertices()
        }

        function eh(e, t, n, i, r) {
            Wa.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                radius: e,
                tube: t,
                radialSegments: n,
                tubularSegments: i,
                arc: r
            }, e = e || 1, t = t || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI;
            var o, a, s = [],
                l = [],
                c = [],
                u = [],
                h = new Kr,
                d = new Kr,
                p = new Kr;
            for (o = 0; o <= n; o++)
                for (a = 0; a <= i; a++) {
                    var f = a / i * r,
                        m = o / n * Math.PI * 2;
                    d.x = (e + t * Math.cos(m)) * Math.cos(f), d.y = (e + t * Math.cos(m)) * Math.sin(f), d.z = t * Math.sin(m), l.push(d.x, d.y, d.z), h.x = e * Math.cos(f), h.y = e * Math.sin(f), p.subVectors(d, h).normalize(), c.push(p.x, p.y, p.z), u.push(a / i), u.push(o / n)
                }
            for (o = 1; o <= n; o++)
                for (a = 1; a <= i; a++) {
                    var g = (i + 1) * o + a - 1,
                        v = (i + 1) * (o - 1) + a - 1,
                        y = (i + 1) * (o - 1) + a,
                        x = (i + 1) * o + a;
                    s.push(g, v, x), s.push(v, y, x)
                }
            this.setIndex(s), this.setAttribute("position", new ka(l, 3)), this.setAttribute("normal", new ka(c, 3)), this.setAttribute("uv", new ka(u, 2))
        }
        Pu.prototype = Object.assign(Object.create(Eo.prototype), {
            constructor: Pu,
            isPoints: !0,
            raycast: function (e, t) {
                var n = this.geometry,
                    i = this.matrixWorld,
                    r = e.params.Points.threshold;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Cu.copy(n.boundingSphere), Cu.applyMatrix4(i), Cu.radius += r, !1 !== e.ray.intersectsSphere(Cu)) {
                    Eu.getInverse(i), Au.copy(e.ray).applyMatrix4(Eu);
                    var o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        a = o * o;
                    if (n.isBufferGeometry) {
                        var s = n.index,
                            l = n.attributes.position.array;
                        if (null !== s)
                            for (var c = s.array, u = 0, h = c.length; u < h; u++) {
                                var d = c[u];
                                Lu.fromArray(l, 3 * d), Ru(Lu, d, a, i, e, t, this)
                            } else {
                            u = 0;
                            for (var p = l.length / 3; u < p; u++) Lu.fromArray(l, 3 * u), Ru(Lu, u, a, i, e, t, this)
                        }
                    } else {
                        var f = n.vertices;
                        for (u = 0, p = f.length; u < p; u++) Ru(f[u], u, a, i, e, t, this)
                    }
                }
            },
            updateMorphTargets: function () {
                var e, t, n, i = this.geometry;
                if (i.isBufferGeometry) {
                    var r = i.morphAttributes,
                        o = Object.keys(r);
                    if (o.length > 0) {
                        var a = r[o[0]];
                        if (void 0 !== a)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = a.length; e < t; e++) n = a[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                    }
                } else {
                    var s = i.morphTargets;
                    void 0 !== s && s.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), Ou.prototype = Object.assign(Object.create(qr.prototype), {
            constructor: Ou,
            isVideoTexture: !0,
            update: function () {
                var e = this.image;
                e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }), Du.prototype = Object.create(qr.prototype), Du.prototype.constructor = Du, Du.prototype.isCompressedTexture = !0, ku.prototype = Object.create(qr.prototype), ku.prototype.constructor = ku, ku.prototype.isCanvasTexture = !0, Nu.prototype = Object.create(qr.prototype), Nu.prototype.constructor = Nu, Nu.prototype.isDepthTexture = !0, Iu.prototype = Object.create(Wa.prototype), Iu.prototype.constructor = Iu, zu.prototype = Object.create(gs.prototype), zu.prototype.constructor = zu, Fu.prototype = Object.create(Wa.prototype), Fu.prototype.constructor = Fu, Hu.prototype = Object.create(gs.prototype), Hu.prototype.constructor = Hu, Bu.prototype = Object.create(Wa.prototype), Bu.prototype.constructor = Bu, Uu.prototype = Object.create(gs.prototype), Uu.prototype.constructor = Uu, ju.prototype = Object.create(Bu.prototype), ju.prototype.constructor = ju, Gu.prototype = Object.create(gs.prototype), Gu.prototype.constructor = Gu, Vu.prototype = Object.create(Bu.prototype), Vu.prototype.constructor = Vu, Wu.prototype = Object.create(gs.prototype), Wu.prototype.constructor = Wu, qu.prototype = Object.create(Bu.prototype), qu.prototype.constructor = qu, $u.prototype = Object.create(gs.prototype), $u.prototype.constructor = $u, Xu.prototype = Object.create(Bu.prototype), Xu.prototype.constructor = Xu, Yu.prototype = Object.create(gs.prototype), Yu.prototype.constructor = Yu, Zu.prototype = Object.create(Wa.prototype), Zu.prototype.constructor = Zu, Zu.prototype.toJSON = function () {
            var e = Wa.prototype.toJSON.call(this);
            return e.path = this.parameters.path.toJSON(), e
        }, Ju.prototype = Object.create(gs.prototype), Ju.prototype.constructor = Ju, Qu.prototype = Object.create(Wa.prototype), Qu.prototype.constructor = Qu, Ku.prototype = Object.create(gs.prototype), Ku.prototype.constructor = Ku, eh.prototype = Object.create(Wa.prototype), eh.prototype.constructor = eh;
        var th = function (e, t, n) {
            n = n || 2;
            var i, r, o, a, s, l, c, u = t && t.length,
                h = u ? t[0] * n : e.length,
                d = nh(e, 0, h, n, !0),
                p = [];
            if (!d || d.next === d.prev) return p;
            if (u && (d = function (e, t, n, i) {
                var r, o, a, s = [];
                for (r = 0, o = t.length; r < o; r++)(a = nh(e, t[r] * i, r < o - 1 ? t[r + 1] * i : e.length, i, !1)) === a.next && (a.steiner = !0), s.push(dh(a));
                for (s.sort(ch), r = 0; r < s.length; r++) uh(s[r], n), n = ih(n, n.next);
                return n
            }(e, t, d, n)), e.length > 80 * n) {
                i = o = e[0], r = a = e[1];
                for (var f = n; f < h; f += n)(s = e[f]) < i && (i = s), (l = e[f + 1]) < r && (r = l), s > o && (o = s), l > a && (a = l);
                c = 0 !== (c = Math.max(o - i, a - r)) ? 1 / c : 0
            }
            return rh(d, p, n, i, r, c), p
        };

        function nh(e, t, n, i, r) {
            var o, a;
            if (r === function (e, t, n, i) {
                for (var r = 0, o = t, a = n - i; o < n; o += i) r += (e[a] - e[o]) * (e[o + 1] + e[a + 1]), a = o;
                return r
            }(e, t, n, i) > 0)
                for (o = t; o < n; o += i) a = wh(o, e[o], e[o + 1], a);
            else
                for (o = n - i; o >= t; o -= i) a = wh(o, e[o], e[o + 1], a);
            return a && gh(a, a.next) && (bh(a), a = a.next), a
        }

        function ih(e, t) {
            if (!e) return e;
            t || (t = e);
            var n, i = e;
            do {
                if (n = !1, i.steiner || !gh(i, i.next) && 0 !== mh(i.prev, i, i.next)) i = i.next;
                else {
                    if (bh(i), (i = t = i.prev) === i.next) break;
                    n = !0
                }
            } while (n || i !== t);
            return t
        }

        function rh(e, t, n, i, r, o, a) {
            if (e) {
                !a && o && function (e, t, n, i) {
                    var r = e;
                    do {
                        null === r.z && (r.z = hh(r.x, r.y, t, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                    } while (r !== e);
                    r.prevZ.nextZ = null, r.prevZ = null,
                        function (e) {
                            var t, n, i, r, o, a, s, l, c = 1;
                            do {
                                for (n = e, e = null, o = null, a = 0; n;) {
                                    for (a++, i = n, s = 0, t = 0; t < c && (s++, i = i.nextZ); t++);
                                    for (l = c; s > 0 || l > 0 && i;) 0 !== s && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, s--) : (r = i, i = i.nextZ, l--), o ? o.nextZ = r : e = r, r.prevZ = o, o = r;
                                    n = i
                                }
                                o.nextZ = null, c *= 2
                            } while (a > 1)
                        }(r)
                }(e, i, r, o);
                for (var s, l, c = e; e.prev !== e.next;)
                    if (s = e.prev, l = e.next, o ? ah(e, i, r, o) : oh(e)) t.push(s.i / n), t.push(e.i / n), t.push(l.i / n), bh(e), e = l.next, c = l.next;
                    else if ((e = l) === c) {
                        a ? 1 === a ? rh(e = sh(e, t, n), t, n, i, r, o, 2) : 2 === a && lh(e, t, n, i, r, o) : rh(ih(e), t, n, i, r, o, 1);
                        break
                    }
            }
        }

        function oh(e) {
            var t = e.prev,
                n = e,
                i = e.next;
            if (mh(t, n, i) >= 0) return !1;
            for (var r = e.next.next; r !== e.prev;) {
                if (ph(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) && mh(r.prev, r, r.next) >= 0) return !1;
                r = r.next
            }
            return !0
        }

        function ah(e, t, n, i) {
            var r = e.prev,
                o = e,
                a = e.next;
            if (mh(r, o, a) >= 0) return !1;
            for (var s = r.x < o.x ? r.x < a.x ? r.x : a.x : o.x < a.x ? o.x : a.x, l = r.y < o.y ? r.y < a.y ? r.y : a.y : o.y < a.y ? o.y : a.y, c = r.x > o.x ? r.x > a.x ? r.x : a.x : o.x > a.x ? o.x : a.x, u = r.y > o.y ? r.y > a.y ? r.y : a.y : o.y > a.y ? o.y : a.y, h = hh(s, l, t, n, i), d = hh(c, u, t, n, i), p = e.prevZ, f = e.nextZ; p && p.z >= h && f && f.z <= d;) {
                if (p !== e.prev && p !== e.next && ph(r.x, r.y, o.x, o.y, a.x, a.y, p.x, p.y) && mh(p.prev, p, p.next) >= 0) return !1;
                if (p = p.prevZ, f !== e.prev && f !== e.next && ph(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && mh(f.prev, f, f.next) >= 0) return !1;
                f = f.nextZ
            }
            for (; p && p.z >= h;) {
                if (p !== e.prev && p !== e.next && ph(r.x, r.y, o.x, o.y, a.x, a.y, p.x, p.y) && mh(p.prev, p, p.next) >= 0) return !1;
                p = p.prevZ
            }
            for (; f && f.z <= d;) {
                if (f !== e.prev && f !== e.next && ph(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && mh(f.prev, f, f.next) >= 0) return !1;
                f = f.nextZ
            }
            return !0
        }

        function sh(e, t, n) {
            var i = e;
            do {
                var r = i.prev,
                    o = i.next.next;
                !gh(r, o) && vh(r, i, i.next, o) && yh(r, o) && yh(o, r) && (t.push(r.i / n), t.push(i.i / n), t.push(o.i / n), bh(i), bh(i.next), i = e = o), i = i.next
            } while (i !== e);
            return i
        }

        function lh(e, t, n, i, r, o) {
            var a = e;
            do {
                for (var s = a.next.next; s !== a.prev;) {
                    if (a.i !== s.i && fh(a, s)) {
                        var l = xh(a, s);
                        return a = ih(a, a.next), l = ih(l, l.next), rh(a, t, n, i, r, o), void rh(l, t, n, i, r, o)
                    }
                    s = s.next
                }
                a = a.next
            } while (a !== e)
        }

        function ch(e, t) {
            return e.x - t.x
        }

        function uh(e, t) {
            if (t = function (e, t) {
                var n, i = t,
                    r = e.x,
                    o = e.y,
                    a = -1 / 0;
                do {
                    if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
                        var s = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                        if (s <= r && s > a) {
                            if (a = s, s === r) {
                                if (o === i.y) return i;
                                if (o === i.next.y) return i.next
                            }
                            n = i.x < i.next.x ? i : i.next
                        }
                    }
                    i = i.next
                } while (i !== t);
                if (!n) return null;
                if (r === a) return n.prev;
                var l, c = n,
                    u = n.x,
                    h = n.y,
                    d = 1 / 0;
                i = n.next;
                for (; i !== c;) r >= i.x && i.x >= u && r !== i.x && ph(o < h ? r : a, o, u, h, o < h ? a : r, o, i.x, i.y) && ((l = Math.abs(o - i.y) / (r - i.x)) < d || l === d && i.x > n.x) && yh(i, e) && (n = i, d = l), i = i.next;
                return n
            }(e, t)) {
                var n = xh(t, e);
                ih(n, n.next)
            }
        }

        function hh(e, t, n, i, r) {
            return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }

        function dh(e) {
            var t = e,
                n = e;
            do {
                (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next
            } while (t !== e);
            return n
        }

        function ph(e, t, n, i, r, o, a, s) {
            return (r - a) * (t - s) - (e - a) * (o - s) >= 0 && (e - a) * (i - s) - (n - a) * (t - s) >= 0 && (n - a) * (o - s) - (r - a) * (i - s) >= 0
        }

        function fh(e, t) {
            return e.next.i !== t.i && e.prev.i !== t.i && ! function (e, t) {
                var n = e;
                do {
                    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && vh(n, n.next, e, t)) return !0;
                    n = n.next
                } while (n !== e);
                return !1
            }(e, t) && yh(e, t) && yh(t, e) && function (e, t) {
                var n = e,
                    i = !1,
                    r = (e.x + t.x) / 2,
                    o = (e.y + t.y) / 2;
                do {
                    n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                } while (n !== e);
                return i
            }(e, t)
        }

        function mh(e, t, n) {
            return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
        }

        function gh(e, t) {
            return e.x === t.x && e.y === t.y
        }

        function vh(e, t, n, i) {
            return !!(gh(e, n) && gh(t, i) || gh(e, i) && gh(n, t)) || mh(e, t, n) > 0 != mh(e, t, i) > 0 && mh(n, i, e) > 0 != mh(n, i, t) > 0
        }

        function yh(e, t) {
            return mh(e.prev, e, e.next) < 0 ? mh(e, t, e.next) >= 0 && mh(e, e.prev, t) >= 0 : mh(e, t, e.prev) < 0 || mh(e, e.next, t) < 0
        }

        function xh(e, t) {
            var n = new _h(e.i, e.x, e.y),
                i = new _h(t.i, t.x, t.y),
                r = e.next,
                o = t.prev;
            return e.next = t, t.prev = e, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i
        }

        function wh(e, t, n, i) {
            var r = new _h(e, t, n);
            return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
        }

        function bh(e) {
            e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
        }

        function _h(e, t, n) {
            this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }
        var Mh = {
            area: function (e) {
                for (var t = e.length, n = 0, i = t - 1, r = 0; r < t; i = r++) n += e[i].x * e[r].y - e[r].x * e[i].y;
                return .5 * n
            },
            isClockWise: function (e) {
                return Mh.area(e) < 0
            },
            triangulateShape: function (e, t) {
                var n = [],
                    i = [],
                    r = [];
                Th(e), Sh(n, e);
                var o = e.length;
                t.forEach(Th);
                for (var a = 0; a < t.length; a++) i.push(o), o += t[a].length, Sh(n, t[a]);
                var s = th(n, i);
                for (a = 0; a < s.length; a += 3) r.push(s.slice(a, a + 3));
                return r
            }
        };

        function Th(e) {
            var t = e.length;
            t > 2 && e[t - 1].equals(e[0]) && e.pop()
        }

        function Sh(e, t) {
            for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
        }

        function Eh(e, t) {
            gs.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                shapes: e,
                options: t
            }, this.fromBufferGeometry(new Ah(e, t)), this.mergeVertices()
        }

        function Ah(e, t) {
            Wa.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                shapes: e,
                options: t
            }, e = Array.isArray(e) ? e : [e];
            for (var n = this, i = [], r = [], o = 0, a = e.length; o < a; o++) {
                s(e[o])
            }

            function s(e) {
                var o = [],
                    a = void 0 !== t.curveSegments ? t.curveSegments : 12,
                    s = void 0 !== t.steps ? t.steps : 1,
                    l = void 0 !== t.depth ? t.depth : 100,
                    c = void 0 === t.bevelEnabled || t.bevelEnabled,
                    u = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
                    h = void 0 !== t.bevelSize ? t.bevelSize : u - 2,
                    d = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                    p = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                    f = t.extrudePath,
                    m = void 0 !== t.UVGenerator ? t.UVGenerator : Ch;
                void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = t.amount);
                var g, v, y, x, w, b, _, M, T = !1;
                f && (g = f.getSpacedPoints(s), T = !0, c = !1, v = f.computeFrenetFrames(s, !1), y = new Kr, x = new Kr, w = new Kr), c || (p = 0, u = 0, h = 0, d = 0);
                var S = e.extractPoints(a),
                    E = S.shape,
                    A = S.holes;
                if (!Mh.isClockWise(E))
                    for (E = E.reverse(), _ = 0, M = A.length; _ < M; _++) b = A[_], Mh.isClockWise(b) && (A[_] = b.reverse());
                var C = Mh.triangulateShape(E, A),
                    L = E;
                for (_ = 0, M = A.length; _ < M; _++) b = A[_], E = E.concat(b);

                function P(e, t, n) {
                    return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
                }
                var R, O, D, k, N, I, z = E.length,
                    F = C.length;

                function H(e, t, n) {
                    var i, r, o, a = e.x - t.x,
                        s = e.y - t.y,
                        l = n.x - e.x,
                        c = n.y - e.y,
                        u = a * a + s * s,
                        h = a * c - s * l;
                    if (Math.abs(h) > Number.EPSILON) {
                        var d = Math.sqrt(u),
                            p = Math.sqrt(l * l + c * c),
                            f = t.x - s / d,
                            m = t.y + a / d,
                            g = ((n.x - c / p - f) * c - (n.y + l / p - m) * l) / (a * c - s * l),
                            v = (i = f + a * g - e.x) * i + (r = m + s * g - e.y) * r;
                        if (v <= 2) return new jr(i, r);
                        o = Math.sqrt(v / 2)
                    } else {
                        var y = !1;
                        a > Number.EPSILON ? l > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(c) && (y = !0), y ? (i = -s, r = a, o = Math.sqrt(u)) : (i = a, r = s, o = Math.sqrt(u / 2))
                    }
                    return new jr(i / o, r / o)
                }
                for (var B = [], U = 0, j = L.length, G = j - 1, V = U + 1; U < j; U++, G++, V++) G === j && (G = 0), V === j && (V = 0), B[U] = H(L[U], L[G], L[V]);
                var W, q, $ = [],
                    X = B.concat();
                for (_ = 0, M = A.length; _ < M; _++) {
                    for (b = A[_], W = [], U = 0, G = (j = b.length) - 1, V = U + 1; U < j; U++, G++, V++) G === j && (G = 0), V === j && (V = 0), W[U] = H(b[U], b[G], b[V]);
                    $.push(W), X = X.concat(W)
                }
                for (R = 0; R < p; R++) {
                    for (D = R / p, k = u * Math.cos(D * Math.PI / 2), O = h * Math.sin(D * Math.PI / 2) + d, U = 0, j = L.length; U < j; U++) Z((N = P(L[U], B[U], O)).x, N.y, -k);
                    for (_ = 0, M = A.length; _ < M; _++)
                        for (b = A[_], W = $[_], U = 0, j = b.length; U < j; U++) Z((N = P(b[U], W[U], O)).x, N.y, -k)
                }
                for (O = h + d, U = 0; U < z; U++) N = c ? P(E[U], X[U], O) : E[U], T ? (x.copy(v.normals[0]).multiplyScalar(N.x), y.copy(v.binormals[0]).multiplyScalar(N.y), w.copy(g[0]).add(x).add(y), Z(w.x, w.y, w.z)) : Z(N.x, N.y, 0);
                for (q = 1; q <= s; q++)
                    for (U = 0; U < z; U++) N = c ? P(E[U], X[U], O) : E[U], T ? (x.copy(v.normals[q]).multiplyScalar(N.x), y.copy(v.binormals[q]).multiplyScalar(N.y), w.copy(g[q]).add(x).add(y), Z(w.x, w.y, w.z)) : Z(N.x, N.y, l / s * q);
                for (R = p - 1; R >= 0; R--) {
                    for (D = R / p, k = u * Math.cos(D * Math.PI / 2), O = h * Math.sin(D * Math.PI / 2) + d, U = 0, j = L.length; U < j; U++) Z((N = P(L[U], B[U], O)).x, N.y, l + k);
                    for (_ = 0, M = A.length; _ < M; _++)
                        for (b = A[_], W = $[_], U = 0, j = b.length; U < j; U++) N = P(b[U], W[U], O), T ? Z(N.x, N.y + g[s - 1].y, g[s - 1].x + k) : Z(N.x, N.y, l + k)
                }

                function Y(e, t) {
                    var n, i;
                    for (U = e.length; --U >= 0;) {
                        n = U, (i = U - 1) < 0 && (i = e.length - 1);
                        var r = 0,
                            o = s + 2 * p;
                        for (r = 0; r < o; r++) {
                            var a = z * r,
                                l = z * (r + 1);
                            Q(t + n + a, t + i + a, t + i + l, t + n + l)
                        }
                    }
                }

                function Z(e, t, n) {
                    o.push(e), o.push(t), o.push(n)
                }

                function J(e, t, r) {
                    K(e), K(t), K(r);
                    var o = i.length / 3,
                        a = m.generateTopUV(n, i, o - 3, o - 2, o - 1);
                    ee(a[0]), ee(a[1]), ee(a[2])
                }

                function Q(e, t, r, o) {
                    K(e), K(t), K(o), K(t), K(r), K(o);
                    var a = i.length / 3,
                        s = m.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
                    ee(s[0]), ee(s[1]), ee(s[3]), ee(s[1]), ee(s[2]), ee(s[3])
                }

                function K(e) {
                    i.push(o[3 * e + 0]), i.push(o[3 * e + 1]), i.push(o[3 * e + 2])
                }

                function ee(e) {
                    r.push(e.x), r.push(e.y)
                } ! function () {
                    var e = i.length / 3;
                    if (c) {
                        var t = 0,
                            r = z * t;
                        for (U = 0; U < F; U++) J((I = C[U])[2] + r, I[1] + r, I[0] + r);
                        for (r = z * (t = s + 2 * p), U = 0; U < F; U++) J((I = C[U])[0] + r, I[1] + r, I[2] + r)
                    } else {
                        for (U = 0; U < F; U++) J((I = C[U])[2], I[1], I[0]);
                        for (U = 0; U < F; U++) J((I = C[U])[0] + z * s, I[1] + z * s, I[2] + z * s)
                    }
                    n.addGroup(e, i.length / 3 - e, 0)
                }(),
                    function () {
                        var e = i.length / 3,
                            t = 0;
                        for (Y(L, t), t += L.length, _ = 0, M = A.length; _ < M; _++) Y(b = A[_], t), t += b.length;
                        n.addGroup(e, i.length / 3 - e, 1)
                    }()
            }
            this.setAttribute("position", new ka(i, 3)), this.setAttribute("uv", new ka(r, 2)), this.computeVertexNormals()
        }
        Eh.prototype = Object.create(gs.prototype), Eh.prototype.constructor = Eh, Eh.prototype.toJSON = function () {
            var e = gs.prototype.toJSON.call(this);
            return Lh(this.parameters.shapes, this.parameters.options, e)
        }, Ah.prototype = Object.create(Wa.prototype), Ah.prototype.constructor = Ah, Ah.prototype.toJSON = function () {
            var e = Wa.prototype.toJSON.call(this);
            return Lh(this.parameters.shapes, this.parameters.options, e)
        };
        var Ch = {
            generateTopUV: function (e, t, n, i, r) {
                var o = t[3 * n],
                    a = t[3 * n + 1],
                    s = t[3 * i],
                    l = t[3 * i + 1],
                    c = t[3 * r],
                    u = t[3 * r + 1];
                return [new jr(o, a), new jr(s, l), new jr(c, u)]
            },
            generateSideWallUV: function (e, t, n, i, r, o) {
                var a = t[3 * n],
                    s = t[3 * n + 1],
                    l = t[3 * n + 2],
                    c = t[3 * i],
                    u = t[3 * i + 1],
                    h = t[3 * i + 2],
                    d = t[3 * r],
                    p = t[3 * r + 1],
                    f = t[3 * r + 2],
                    m = t[3 * o],
                    g = t[3 * o + 1],
                    v = t[3 * o + 2];
                return Math.abs(s - u) < .01 ? [new jr(a, 1 - l), new jr(c, 1 - h), new jr(d, 1 - f), new jr(m, 1 - v)] : [new jr(s, 1 - l), new jr(u, 1 - h), new jr(p, 1 - f), new jr(g, 1 - v)]
            }
        };

        function Lh(e, t, n) {
            if (n.shapes = [], Array.isArray(e))
                for (var i = 0, r = e.length; i < r; i++) {
                    var o = e[i];
                    n.shapes.push(o.uuid)
                } else n.shapes.push(e.uuid);
            return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
        }

        function Ph(e, t) {
            gs.call(this), this.type = "TextGeometry", this.parameters = {
                text: e,
                parameters: t
            }, this.fromBufferGeometry(new Rh(e, t)), this.mergeVertices()
        }

        function Rh(e, t) {
            var n = (t = t || {}).font;
            if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new gs;
            var i = n.generateShapes(e, t.size);
            t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), Ah.call(this, i, t), this.type = "TextBufferGeometry"
        }

        function Oh(e, t, n, i, r, o, a) {
            gs.call(this), this.type = "SphereGeometry", this.parameters = {
                radius: e,
                widthSegments: t,
                heightSegments: n,
                phiStart: i,
                phiLength: r,
                thetaStart: o,
                thetaLength: a
            }, this.fromBufferGeometry(new Dh(e, t, n, i, r, o, a)), this.mergeVertices()
        }

        function Dh(e, t, n, i, r, o, a) {
            Wa.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                radius: e,
                widthSegments: t,
                heightSegments: n,
                phiStart: i,
                phiLength: r,
                thetaStart: o,
                thetaLength: a
            }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
            var s, l, c = Math.min(o + a, Math.PI),
                u = 0,
                h = [],
                d = new Kr,
                p = new Kr,
                f = [],
                m = [],
                g = [],
                v = [];
            for (l = 0; l <= n; l++) {
                var y = [],
                    x = l / n,
                    w = 0;
                for (0 == l && 0 == o ? w = .5 / t : l == n && c == Math.PI && (w = -.5 / t), s = 0; s <= t; s++) {
                    var b = s / t;
                    d.x = -e * Math.cos(i + b * r) * Math.sin(o + x * a), d.y = e * Math.cos(o + x * a), d.z = e * Math.sin(i + b * r) * Math.sin(o + x * a), m.push(d.x, d.y, d.z), p.copy(d).normalize(), g.push(p.x, p.y, p.z), v.push(b + w, 1 - x), y.push(u++)
                }
                h.push(y)
            }
            for (l = 0; l < n; l++)
                for (s = 0; s < t; s++) {
                    var _ = h[l][s + 1],
                        M = h[l][s],
                        T = h[l + 1][s],
                        S = h[l + 1][s + 1];
                    (0 !== l || o > 0) && f.push(_, M, S), (l !== n - 1 || c < Math.PI) && f.push(M, T, S)
                }
            this.setIndex(f), this.setAttribute("position", new ka(m, 3)), this.setAttribute("normal", new ka(g, 3)), this.setAttribute("uv", new ka(v, 2))
        }

        function kh(e, t, n, i, r, o) {
            gs.call(this), this.type = "RingGeometry", this.parameters = {
                innerRadius: e,
                outerRadius: t,
                thetaSegments: n,
                phiSegments: i,
                thetaStart: r,
                thetaLength: o
            }, this.fromBufferGeometry(new Nh(e, t, n, i, r, o)), this.mergeVertices()
        }

        function Nh(e, t, n, i, r, o) {
            Wa.call(this), this.type = "RingBufferGeometry", this.parameters = {
                innerRadius: e,
                outerRadius: t,
                thetaSegments: n,
                phiSegments: i,
                thetaStart: r,
                thetaLength: o
            }, e = e || .5, t = t || 1, r = void 0 !== r ? r : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
            var a, s, l, c = [],
                u = [],
                h = [],
                d = [],
                p = e,
                f = (t - e) / (i = void 0 !== i ? Math.max(1, i) : 1),
                m = new Kr,
                g = new jr;
            for (s = 0; s <= i; s++) {
                for (l = 0; l <= n; l++) a = r + l / n * o, m.x = p * Math.cos(a), m.y = p * Math.sin(a), u.push(m.x, m.y, m.z), h.push(0, 0, 1), g.x = (m.x / t + 1) / 2, g.y = (m.y / t + 1) / 2, d.push(g.x, g.y);
                p += f
            }
            for (s = 0; s < i; s++) {
                var v = s * (n + 1);
                for (l = 0; l < n; l++) {
                    var y = a = l + v,
                        x = a + n + 1,
                        w = a + n + 2,
                        b = a + 1;
                    c.push(y, x, b), c.push(x, w, b)
                }
            }
            this.setIndex(c), this.setAttribute("position", new ka(u, 3)), this.setAttribute("normal", new ka(h, 3)), this.setAttribute("uv", new ka(d, 2))
        }

        function Ih(e, t, n, i) {
            gs.call(this), this.type = "LatheGeometry", this.parameters = {
                points: e,
                segments: t,
                phiStart: n,
                phiLength: i
            }, this.fromBufferGeometry(new zh(e, t, n, i)), this.mergeVertices()
        }

        function zh(e, t, n, i) {
            Wa.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                points: e,
                segments: t,
                phiStart: n,
                phiLength: i
            }, t = Math.floor(t) || 12, n = n || 0, i = i || 2 * Math.PI, i = Ur.clamp(i, 0, 2 * Math.PI);
            var r, o, a, s = [],
                l = [],
                c = [],
                u = 1 / t,
                h = new Kr,
                d = new jr;
            for (o = 0; o <= t; o++) {
                var p = n + o * u * i,
                    f = Math.sin(p),
                    m = Math.cos(p);
                for (a = 0; a <= e.length - 1; a++) h.x = e[a].x * f, h.y = e[a].y, h.z = e[a].x * m, l.push(h.x, h.y, h.z), d.x = o / t, d.y = a / (e.length - 1), c.push(d.x, d.y)
            }
            for (o = 0; o < t; o++)
                for (a = 0; a < e.length - 1; a++) {
                    var g = r = a + o * e.length,
                        v = r + e.length,
                        y = r + e.length + 1,
                        x = r + 1;
                    s.push(g, v, x), s.push(v, y, x)
                }
            if (this.setIndex(s), this.setAttribute("position", new ka(l, 3)), this.setAttribute("uv", new ka(c, 2)), this.computeVertexNormals(), i === 2 * Math.PI) {
                var w = this.attributes.normal.array,
                    b = new Kr,
                    _ = new Kr,
                    M = new Kr;
                for (r = t * e.length * 3, o = 0, a = 0; o < e.length; o++, a += 3) b.x = w[a + 0], b.y = w[a + 1], b.z = w[a + 2], _.x = w[r + a + 0], _.y = w[r + a + 1], _.z = w[r + a + 2], M.addVectors(b, _).normalize(), w[a + 0] = w[r + a + 0] = M.x, w[a + 1] = w[r + a + 1] = M.y, w[a + 2] = w[r + a + 2] = M.z
            }
        }

        function Fh(e, t) {
            gs.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
                shapes: e,
                curveSegments: t
            }, this.fromBufferGeometry(new Hh(e, t)), this.mergeVertices()
        }

        function Hh(e, t) {
            Wa.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                shapes: e,
                curveSegments: t
            }, t = t || 12;
            var n = [],
                i = [],
                r = [],
                o = [],
                a = 0,
                s = 0;
            if (!1 === Array.isArray(e)) c(e);
            else
                for (var l = 0; l < e.length; l++) c(e[l]), this.addGroup(a, s, l), a += s, s = 0;

            function c(e) {
                var a, l, c, u = i.length / 3,
                    h = e.extractPoints(t),
                    d = h.shape,
                    p = h.holes;
                for (!1 === Mh.isClockWise(d) && (d = d.reverse()), a = 0, l = p.length; a < l; a++) c = p[a], !0 === Mh.isClockWise(c) && (p[a] = c.reverse());
                var f = Mh.triangulateShape(d, p);
                for (a = 0, l = p.length; a < l; a++) c = p[a], d = d.concat(c);
                for (a = 0, l = d.length; a < l; a++) {
                    var m = d[a];
                    i.push(m.x, m.y, 0), r.push(0, 0, 1), o.push(m.x, m.y)
                }
                for (a = 0, l = f.length; a < l; a++) {
                    var g = f[a],
                        v = g[0] + u,
                        y = g[1] + u,
                        x = g[2] + u;
                    n.push(v, y, x), s += 3
                }
            }
            this.setIndex(n), this.setAttribute("position", new ka(i, 3)), this.setAttribute("normal", new ka(r, 3)), this.setAttribute("uv", new ka(o, 2))
        }

        function Bh(e, t) {
            if (t.shapes = [], Array.isArray(e))
                for (var n = 0, i = e.length; n < i; n++) {
                    var r = e[n];
                    t.shapes.push(r.uuid)
                } else t.shapes.push(e.uuid);
            return t
        }

        function Uh(e, t) {
            Wa.call(this), this.type = "EdgesGeometry", this.parameters = {
                thresholdAngle: t
            }, t = void 0 !== t ? t : 1;
            var n, i, r, o, a = [],
                s = Math.cos(Ur.DEG2RAD * t),
                l = [0, 0],
                c = {},
                u = ["a", "b", "c"];
            e.isBufferGeometry ? (o = new gs).fromBufferGeometry(e) : o = e.clone(), o.mergeVertices(), o.computeFaceNormals();
            for (var h = o.vertices, d = o.faces, p = 0, f = d.length; p < f; p++)
                for (var m = d[p], g = 0; g < 3; g++) n = m[u[g]], i = m[u[(g + 1) % 3]], l[0] = Math.min(n, i), l[1] = Math.max(n, i), void 0 === c[r = l[0] + "," + l[1]] ? c[r] = {
                    index1: l[0],
                    index2: l[1],
                    face1: p,
                    face2: void 0
                } : c[r].face2 = p;
            for (r in c) {
                var v = c[r];
                if (void 0 === v.face2 || d[v.face1].normal.dot(d[v.face2].normal) <= s) {
                    var y = h[v.index1];
                    a.push(y.x, y.y, y.z), y = h[v.index2], a.push(y.x, y.y, y.z)
                }
            }
            this.setAttribute("position", new ka(a, 3))
        }

        function jh(e, t, n, i, r, o, a, s) {
            gs.call(this), this.type = "CylinderGeometry", this.parameters = {
                radiusTop: e,
                radiusBottom: t,
                height: n,
                radialSegments: i,
                heightSegments: r,
                openEnded: o,
                thetaStart: a,
                thetaLength: s
            }, this.fromBufferGeometry(new Gh(e, t, n, i, r, o, a, s)), this.mergeVertices()
        }

        function Gh(e, t, n, i, r, o, a, s) {
            Wa.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                radiusTop: e,
                radiusBottom: t,
                height: n,
                radialSegments: i,
                heightSegments: r,
                openEnded: o,
                thetaStart: a,
                thetaLength: s
            };
            var l = this;
            e = void 0 !== e ? e : 1, t = void 0 !== t ? t : 1, n = n || 1, i = Math.floor(i) || 8, r = Math.floor(r) || 1, o = void 0 !== o && o, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI;
            var c = [],
                u = [],
                h = [],
                d = [],
                p = 0,
                f = [],
                m = n / 2,
                g = 0;

            function v(n) {
                var r, o, f, v = new jr,
                    y = new Kr,
                    x = 0,
                    w = !0 === n ? e : t,
                    b = !0 === n ? 1 : -1;
                for (o = p, r = 1; r <= i; r++) u.push(0, m * b, 0), h.push(0, b, 0), d.push(.5, .5), p++;
                for (f = p, r = 0; r <= i; r++) {
                    var _ = r / i * s + a,
                        M = Math.cos(_),
                        T = Math.sin(_);
                    y.x = w * T, y.y = m * b, y.z = w * M, u.push(y.x, y.y, y.z), h.push(0, b, 0), v.x = .5 * M + .5, v.y = .5 * T * b + .5, d.push(v.x, v.y), p++
                }
                for (r = 0; r < i; r++) {
                    var S = o + r,
                        E = f + r;
                    !0 === n ? c.push(E, E + 1, S) : c.push(E + 1, E, S), x += 3
                }
                l.addGroup(g, x, !0 === n ? 1 : 2), g += x
            } ! function () {
                var o, v, y = new Kr,
                    x = new Kr,
                    w = 0,
                    b = (t - e) / n;
                for (v = 0; v <= r; v++) {
                    var _ = [],
                        M = v / r,
                        T = M * (t - e) + e;
                    for (o = 0; o <= i; o++) {
                        var S = o / i,
                            E = S * s + a,
                            A = Math.sin(E),
                            C = Math.cos(E);
                        x.x = T * A, x.y = -M * n + m, x.z = T * C, u.push(x.x, x.y, x.z), y.set(A, b, C).normalize(), h.push(y.x, y.y, y.z), d.push(S, 1 - M), _.push(p++)
                    }
                    f.push(_)
                }
                for (o = 0; o < i; o++)
                    for (v = 0; v < r; v++) {
                        var L = f[v][o],
                            P = f[v + 1][o],
                            R = f[v + 1][o + 1],
                            O = f[v][o + 1];
                        c.push(L, P, O), c.push(P, R, O), w += 6
                    }
                l.addGroup(g, w, 0), g += w
            }(), !1 === o && (e > 0 && v(!0), t > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new ka(u, 3)), this.setAttribute("normal", new ka(h, 3)), this.setAttribute("uv", new ka(d, 2))
        }

        function Vh(e, t, n, i, r, o, a) {
            jh.call(this, 0, e, t, n, i, r, o, a), this.type = "ConeGeometry", this.parameters = {
                radius: e,
                height: t,
                radialSegments: n,
                heightSegments: i,
                openEnded: r,
                thetaStart: o,
                thetaLength: a
            }
        }

        function Wh(e, t, n, i, r, o, a) {
            Gh.call(this, 0, e, t, n, i, r, o, a), this.type = "ConeBufferGeometry", this.parameters = {
                radius: e,
                height: t,
                radialSegments: n,
                heightSegments: i,
                openEnded: r,
                thetaStart: o,
                thetaLength: a
            }
        }

        function qh(e, t, n, i) {
            gs.call(this), this.type = "CircleGeometry", this.parameters = {
                radius: e,
                segments: t,
                thetaStart: n,
                thetaLength: i
            }, this.fromBufferGeometry(new $h(e, t, n, i)), this.mergeVertices()
        }

        function $h(e, t, n, i) {
            Wa.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                radius: e,
                segments: t,
                thetaStart: n,
                thetaLength: i
            }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, i = void 0 !== i ? i : 2 * Math.PI;
            var r, o, a = [],
                s = [],
                l = [],
                c = [],
                u = new Kr,
                h = new jr;
            for (s.push(0, 0, 0), l.push(0, 0, 1), c.push(.5, .5), o = 0, r = 3; o <= t; o++, r += 3) {
                var d = n + o / t * i;
                u.x = e * Math.cos(d), u.y = e * Math.sin(d), s.push(u.x, u.y, u.z), l.push(0, 0, 1), h.x = (s[r] / e + 1) / 2, h.y = (s[r + 1] / e + 1) / 2, c.push(h.x, h.y)
            }
            for (r = 1; r <= t; r++) a.push(r, r + 1, 0);
            this.setIndex(a), this.setAttribute("position", new ka(s, 3)), this.setAttribute("normal", new ka(l, 3)), this.setAttribute("uv", new ka(c, 2))
        }
        Ph.prototype = Object.create(gs.prototype), Ph.prototype.constructor = Ph, Rh.prototype = Object.create(Ah.prototype), Rh.prototype.constructor = Rh, Oh.prototype = Object.create(gs.prototype), Oh.prototype.constructor = Oh, Dh.prototype = Object.create(Wa.prototype), Dh.prototype.constructor = Dh, kh.prototype = Object.create(gs.prototype), kh.prototype.constructor = kh, Nh.prototype = Object.create(Wa.prototype), Nh.prototype.constructor = Nh, Ih.prototype = Object.create(gs.prototype), Ih.prototype.constructor = Ih, zh.prototype = Object.create(Wa.prototype), zh.prototype.constructor = zh, Fh.prototype = Object.create(gs.prototype), Fh.prototype.constructor = Fh, Fh.prototype.toJSON = function () {
            var e = gs.prototype.toJSON.call(this);
            return Bh(this.parameters.shapes, e)
        }, Hh.prototype = Object.create(Wa.prototype), Hh.prototype.constructor = Hh, Hh.prototype.toJSON = function () {
            var e = Wa.prototype.toJSON.call(this);
            return Bh(this.parameters.shapes, e)
        }, Uh.prototype = Object.create(Wa.prototype), Uh.prototype.constructor = Uh, jh.prototype = Object.create(gs.prototype), jh.prototype.constructor = jh, Gh.prototype = Object.create(Wa.prototype), Gh.prototype.constructor = Gh, Vh.prototype = Object.create(jh.prototype), Vh.prototype.constructor = Vh, Wh.prototype = Object.create(Gh.prototype), Wh.prototype.constructor = Wh, qh.prototype = Object.create(gs.prototype), qh.prototype.constructor = qh, $h.prototype = Object.create(Wa.prototype), $h.prototype.constructor = $h;
        var Xh = Object.freeze({
            __proto__: null,
            WireframeGeometry: Iu,
            ParametricGeometry: zu,
            ParametricBufferGeometry: Fu,
            TetrahedronGeometry: Uu,
            TetrahedronBufferGeometry: ju,
            OctahedronGeometry: Gu,
            OctahedronBufferGeometry: Vu,
            IcosahedronGeometry: Wu,
            IcosahedronBufferGeometry: qu,
            DodecahedronGeometry: $u,
            DodecahedronBufferGeometry: Xu,
            PolyhedronGeometry: Hu,
            PolyhedronBufferGeometry: Bu,
            TubeGeometry: Yu,
            TubeBufferGeometry: Zu,
            TorusKnotGeometry: Ju,
            TorusKnotBufferGeometry: Qu,
            TorusGeometry: Ku,
            TorusBufferGeometry: eh,
            TextGeometry: Ph,
            TextBufferGeometry: Rh,
            SphereGeometry: Oh,
            SphereBufferGeometry: Dh,
            RingGeometry: kh,
            RingBufferGeometry: Nh,
            PlaneGeometry: ks,
            PlaneBufferGeometry: Ns,
            LatheGeometry: Ih,
            LatheBufferGeometry: zh,
            ShapeGeometry: Fh,
            ShapeBufferGeometry: Hh,
            ExtrudeGeometry: Eh,
            ExtrudeBufferGeometry: Ah,
            EdgesGeometry: Uh,
            ConeGeometry: Vh,
            ConeBufferGeometry: Wh,
            CylinderGeometry: jh,
            CylinderBufferGeometry: Gh,
            CircleGeometry: qh,
            CircleBufferGeometry: $h,
            BoxGeometry: class extends gs {
                constructor(e, t, n, i, r, o) {
                    super(), this.type = "BoxGeometry", this.parameters = {
                        width: e,
                        height: t,
                        depth: n,
                        widthSegments: i,
                        heightSegments: r,
                        depthSegments: o
                    }, this.fromBufferGeometry(new vs(e, t, n, i, r, o)), this.mergeVertices()
                }
            },
            BoxBufferGeometry: vs
        });

        function Yh(e) {
            Ma.call(this), this.type = "ShadowMaterial", this.color = new va(0), this.transparent = !0, this.setValues(e)
        }

        function Zh(e) {
            bs.call(this, e), this.type = "RawShaderMaterial"
        }

        function Jh(e) {
            Ma.call(this), this.defines = {
                STANDARD: ""
            }, this.type = "MeshStandardMaterial", this.color = new va(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new va(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new jr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(e)
        }

        function Qh(e) {
            Jh.call(this), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new jr(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, this.sheen = null, this.transparency = 0, this.setValues(e)
        }

        function Kh(e) {
            Ma.call(this), this.type = "MeshPhongMaterial", this.color = new va(16777215), this.specular = new va(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new va(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new jr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
        }

        function ed(e) {
            Ma.call(this), this.defines = {
                TOON: ""
            }, this.type = "MeshToonMaterial", this.color = new va(16777215), this.specular = new va(1118481), this.shininess = 30, this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new va(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new jr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
        }

        function td(e) {
            Ma.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new jr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
        }

        function nd(e) {
            Ma.call(this), this.type = "MeshLambertMaterial", this.color = new va(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new va(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
        }

        function id(e) {
            Ma.call(this), this.defines = {
                MATCAP: ""
            }, this.type = "MeshMatcapMaterial", this.color = new va(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new jr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
        }

        function rd(e) {
            fu.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
        }
        Yh.prototype = Object.create(Ma.prototype), Yh.prototype.constructor = Yh, Yh.prototype.isShadowMaterial = !0, Yh.prototype.copy = function (e) {
            return Ma.prototype.copy.call(this, e), this.color.copy(e.color), this
        }, Zh.prototype = Object.create(bs.prototype), Zh.prototype.constructor = Zh, Zh.prototype.isRawShaderMaterial = !0, Jh.prototype = Object.create(Ma.prototype), Jh.prototype.constructor = Jh, Jh.prototype.isMeshStandardMaterial = !0, Jh.prototype.copy = function (e) {
            return Ma.prototype.copy.call(this, e), this.defines = {
                STANDARD: ""
            }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.vertexTangents = e.vertexTangents, this
        }, Qh.prototype = Object.create(Jh.prototype), Qh.prototype.constructor = Qh, Qh.prototype.isMeshPhysicalMaterial = !0, Qh.prototype.copy = function (e) {
            return Jh.prototype.copy.call(this, e), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.reflectivity = e.reflectivity, e.sheen ? this.sheen = (this.sheen || new va).copy(e.sheen) : this.sheen = null, this.transparency = e.transparency, this
        }, Kh.prototype = Object.create(Ma.prototype), Kh.prototype.constructor = Kh, Kh.prototype.isMeshPhongMaterial = !0, Kh.prototype.copy = function (e) {
            return Ma.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
        }, ed.prototype = Object.create(Ma.prototype), ed.prototype.constructor = ed, ed.prototype.isMeshToonMaterial = !0, ed.prototype.copy = function (e) {
            return Ma.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
        }, td.prototype = Object.create(Ma.prototype), td.prototype.constructor = td, td.prototype.isMeshNormalMaterial = !0, td.prototype.copy = function (e) {
            return Ma.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
        }, nd.prototype = Object.create(Ma.prototype), nd.prototype.constructor = nd, nd.prototype.isMeshLambertMaterial = !0, nd.prototype.copy = function (e) {
            return Ma.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
        }, id.prototype = Object.create(Ma.prototype), id.prototype.constructor = id, id.prototype.isMeshMatcapMaterial = !0, id.prototype.copy = function (e) {
            return Ma.prototype.copy.call(this, e), this.defines = {
                MATCAP: ""
            }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
        }, rd.prototype = Object.create(fu.prototype), rd.prototype.constructor = rd, rd.prototype.isLineDashedMaterial = !0, rd.prototype.copy = function (e) {
            return fu.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
        };
        var od = Object.freeze({
            __proto__: null,
            ShadowMaterial: Yh,
            SpriteMaterial: Bc,
            RawShaderMaterial: Zh,
            ShaderMaterial: bs,
            PointsMaterial: Su,
            MeshPhysicalMaterial: Qh,
            MeshStandardMaterial: Jh,
            MeshPhongMaterial: Kh,
            MeshToonMaterial: ed,
            MeshNormalMaterial: td,
            MeshLambertMaterial: nd,
            MeshDepthMaterial: Tc,
            MeshDistanceMaterial: Sc,
            MeshBasicMaterial: Ta,
            MeshMatcapMaterial: id,
            LineDashedMaterial: rd,
            LineBasicMaterial: fu,
            Material: Ma
        }),
            ad = {
                arraySlice: function (e, t, n) {
                    return ad.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
                },
                convertArray: function (e, t, n) {
                    return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
                },
                isTypedArray: function (e) {
                    return ArrayBuffer.isView(e) && !(e instanceof DataView)
                },
                getKeyframeOrder: function (e) {
                    for (var t = e.length, n = new Array(t), i = 0; i !== t; ++i) n[i] = i;
                    return n.sort((function (t, n) {
                        return e[t] - e[n]
                    })), n
                },
                sortedArray: function (e, t, n) {
                    for (var i = e.length, r = new e.constructor(i), o = 0, a = 0; a !== i; ++o)
                        for (var s = n[o] * t, l = 0; l !== t; ++l) r[a++] = e[s + l];
                    return r
                },
                flattenJSON: function (e, t, n, i) {
                    for (var r = 1, o = e[0]; void 0 !== o && void 0 === o[i];) o = e[r++];
                    if (void 0 !== o) {
                        var a = o[i];
                        if (void 0 !== a)
                            if (Array.isArray(a))
                                do {
                                    void 0 !== (a = o[i]) && (t.push(o.time), n.push.apply(n, a)), o = e[r++]
                                } while (void 0 !== o);
                            else if (void 0 !== a.toArray)
                                do {
                                    void 0 !== (a = o[i]) && (t.push(o.time), a.toArray(n, n.length)), o = e[r++]
                                } while (void 0 !== o);
                            else
                                do {
                                    void 0 !== (a = o[i]) && (t.push(o.time), n.push(a)), o = e[r++]
                                } while (void 0 !== o)
                    }
                },
                subclip: function (e, t, n, i, r) {
                    r = r || 30;
                    var o = e.clone();
                    o.name = t;
                    for (var a = [], s = 0; s < o.tracks.length; ++s) {
                        for (var l = o.tracks[s], c = l.getValueSize(), u = [], h = [], d = 0; d < l.times.length; ++d) {
                            var p = l.times[d] * r;
                            if (!(p < n || p >= i)) {
                                u.push(l.times[d]);
                                for (var f = 0; f < c; ++f) h.push(l.values[d * c + f])
                            }
                        }
                        0 !== u.length && (l.times = ad.convertArray(u, l.times.constructor), l.values = ad.convertArray(h, l.values.constructor), a.push(l))
                    }
                    o.tracks = a;
                    var m = 1 / 0;
                    for (s = 0; s < o.tracks.length; ++s) m > o.tracks[s].times[0] && (m = o.tracks[s].times[0]);
                    for (s = 0; s < o.tracks.length; ++s) o.tracks[s].shift(-1 * m);
                    return o.resetDuration(), o
                }
            };

        function sd(e, t, n, i) {
            this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n
        }

        function ld(e, t, n, i) {
            sd.call(this, e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
        }

        function cd(e, t, n, i) {
            sd.call(this, e, t, n, i)
        }

        function ud(e, t, n, i) {
            sd.call(this, e, t, n, i)
        }

        function hd(e, t, n, i) {
            if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
            this.name = e, this.times = ad.convertArray(t, this.TimeBufferType), this.values = ad.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
        }

        function dd(e, t, n) {
            hd.call(this, e, t, n)
        }

        function pd(e, t, n, i) {
            hd.call(this, e, t, n, i)
        }

        function fd(e, t, n, i) {
            hd.call(this, e, t, n, i)
        }

        function md(e, t, n, i) {
            sd.call(this, e, t, n, i)
        }

        function gd(e, t, n, i) {
            hd.call(this, e, t, n, i)
        }

        function vd(e, t, n, i) {
            hd.call(this, e, t, n, i)
        }

        function yd(e, t, n, i) {
            hd.call(this, e, t, n, i)
        }

        function xd(e, t, n) {
            this.name = e, this.tracks = n, this.duration = void 0 !== t ? t : -1, this.uuid = Ur.generateUUID(), this.duration < 0 && this.resetDuration()
        }

        function wd(e) {
            if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            var t = function (e) {
                switch (e.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return fd;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return yd;
                    case "color":
                        return pd;
                    case "quaternion":
                        return gd;
                    case "bool":
                    case "boolean":
                        return dd;
                    case "string":
                        return vd
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
            }(e.type);
            if (void 0 === e.times) {
                var n = [],
                    i = [];
                ad.flattenJSON(e.keys, n, i, "value"), e.times = n, e.values = i
            }
            return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
        }
        Object.assign(sd.prototype, {
            evaluate: function (e) {
                var t = this.parameterPositions,
                    n = this._cachedIndex,
                    i = t[n],
                    r = t[n - 1];
                e: {
                    t: {
                        var o; n: {
                            i: if (!(e < i)) {
                                for (var a = n + 2; ;) {
                                    if (void 0 === i) {
                                        if (e < r) break i;
                                        return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, r)
                                    }
                                    if (n === a) break;
                                    if (r = i, e < (i = t[++n])) break t
                                }
                                o = t.length;
                                break n
                            } if (e >= r) break e;
                            var s = t[1]; e < s && (n = 2, r = s);
                            for (a = n - 2; ;) {
                                if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
                                if (n === a) break;
                                if (i = r, e >= (r = t[--n - 1])) break t
                            }
                            o = n,
                                n = 0
                        }
                        for (; n < o;) {
                            var l = n + o >>> 1;
                            e < t[l] ? o = l : n = l + 1
                        }
                        if (i = t[n], void 0 === (r = t[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
                        if (void 0 === i) return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, e)
                    }
                    this._cachedIndex = n,
                        this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, e, i)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function () {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function (e) {
                for (var t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i, o = 0; o !== i; ++o) t[o] = n[r + o];
                return t
            },
            interpolate_: function () {
                throw new Error("call to abstract method")
            },
            intervalChanged_: function () { }
        }), Object.assign(sd.prototype, {
            beforeStart_: sd.prototype.copySampleValue_,
            afterEnd_: sd.prototype.copySampleValue_
        }), ld.prototype = Object.assign(Object.create(sd.prototype), {
            constructor: ld,
            DefaultSettings_: {
                endingStart: Cr,
                endingEnd: Cr
            },
            intervalChanged_: function (e, t, n) {
                var i = this.parameterPositions,
                    r = e - 2,
                    o = e + 1,
                    a = i[r],
                    s = i[o];
                if (void 0 === a) switch (this.getSettings_().endingStart) {
                    case Lr:
                        r = e, a = 2 * t - n;
                        break;
                    case Pr:
                        a = t + i[r = i.length - 2] - i[r + 1];
                        break;
                    default:
                        r = e, a = n
                }
                if (void 0 === s) switch (this.getSettings_().endingEnd) {
                    case Lr:
                        o = e, s = 2 * n - t;
                        break;
                    case Pr:
                        o = 1, s = n + i[1] - i[0];
                        break;
                    default:
                        o = e - 1, s = t
                }
                var l = .5 * (n - t),
                    c = this.valueSize;
                this._weightPrev = l / (t - a), this._weightNext = l / (s - n), this._offsetPrev = r * c, this._offsetNext = o * c
            },
            interpolate_: function (e, t, n, i) {
                for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, l = s - a, c = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (n - t) / (i - t), f = p * p, m = f * p, g = -h * m + 2 * h * f - h * p, v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, x = d * m - d * f, w = 0; w !== a; ++w) r[w] = g * o[c + w] + v * o[l + w] + y * o[s + w] + x * o[u + w];
                return r
            }
        }), cd.prototype = Object.assign(Object.create(sd.prototype), {
            constructor: cd,
            interpolate_: function (e, t, n, i) {
                for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, l = s - a, c = (n - t) / (i - t), u = 1 - c, h = 0; h !== a; ++h) r[h] = o[l + h] * u + o[s + h] * c;
                return r
            }
        }), ud.prototype = Object.assign(Object.create(sd.prototype), {
            constructor: ud,
            interpolate_: function (e) {
                return this.copySampleValue_(e - 1)
            }
        }), Object.assign(hd, {
            toJSON: function (e) {
                var t, n = e.constructor;
                if (void 0 !== n.toJSON) t = n.toJSON(e);
                else {
                    t = {
                        name: e.name,
                        times: ad.convertArray(e.times, Array),
                        values: ad.convertArray(e.values, Array)
                    };
                    var i = e.getInterpolation();
                    i !== e.DefaultInterpolation && (t.interpolation = i)
                }
                return t.type = e.ValueTypeName, t
            }
        }), Object.assign(hd.prototype, {
            constructor: hd,
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: Er,
            InterpolantFactoryMethodDiscrete: function (e) {
                return new ud(this.times, this.values, this.getValueSize(), e)
            },
            InterpolantFactoryMethodLinear: function (e) {
                return new cd(this.times, this.values, this.getValueSize(), e)
            },
            InterpolantFactoryMethodSmooth: function (e) {
                return new ld(this.times, this.values, this.getValueSize(), e)
            },
            setInterpolation: function (e) {
                var t;
                switch (e) {
                    case Sr:
                        t = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case Er:
                        t = this.InterpolantFactoryMethodLinear;
                        break;
                    case Ar:
                        t = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === t) {
                    var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (e === this.DefaultInterpolation) throw new Error(n);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", n), this
                }
                return this.createInterpolant = t, this
            },
            getInterpolation: function () {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return Sr;
                    case this.InterpolantFactoryMethodLinear:
                        return Er;
                    case this.InterpolantFactoryMethodSmooth:
                        return Ar
                }
            },
            getValueSize: function () {
                return this.values.length / this.times.length
            },
            shift: function (e) {
                if (0 !== e)
                    for (var t = this.times, n = 0, i = t.length; n !== i; ++n) t[n] += e;
                return this
            },
            scale: function (e) {
                if (1 !== e)
                    for (var t = this.times, n = 0, i = t.length; n !== i; ++n) t[n] *= e;
                return this
            },
            trim: function (e, t) {
                for (var n = this.times, i = n.length, r = 0, o = i - 1; r !== i && n[r] < e;) ++r;
                for (; - 1 !== o && n[o] > t;) --o;
                if (++o, 0 !== r || o !== i) {
                    r >= o && (r = (o = Math.max(o, 1)) - 1);
                    var a = this.getValueSize();
                    this.times = ad.arraySlice(n, r, o), this.values = ad.arraySlice(this.values, r * a, o * a)
                }
                return this
            },
            validate: function () {
                var e = !0,
                    t = this.getValueSize();
                t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                var n = this.times,
                    i = this.values,
                    r = n.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                for (var o = null, a = 0; a !== r; a++) {
                    var s = n[a];
                    if ("number" == typeof s && isNaN(s)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), e = !1;
                        break
                    }
                    if (null !== o && o > s) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), e = !1;
                        break
                    }
                    o = s
                }
                if (void 0 !== i && ad.isTypedArray(i)) {
                    a = 0;
                    for (var l = i.length; a !== l; ++a) {
                        var c = i[a];
                        if (isNaN(c)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1;
                            break
                        }
                    }
                }
                return e
            },
            optimize: function () {
                for (var e = ad.arraySlice(this.times), t = ad.arraySlice(this.values), n = this.getValueSize(), i = this.getInterpolation() === Ar, r = 1, o = e.length - 1, a = 1; a < o; ++a) {
                    var s = !1,
                        l = e[a];
                    if (l !== e[a + 1] && (1 !== a || l !== l[0]))
                        if (i) s = !0;
                        else
                            for (var c = a * n, u = c - n, h = c + n, d = 0; d !== n; ++d) {
                                var p = t[c + d];
                                if (p !== t[u + d] || p !== t[h + d]) {
                                    s = !0;
                                    break
                                }
                            }
                    if (s) {
                        if (a !== r) {
                            e[r] = e[a];
                            var f = a * n,
                                m = r * n;
                            for (d = 0; d !== n; ++d) t[m + d] = t[f + d]
                        } ++r
                    }
                }
                if (o > 0) {
                    e[r] = e[o];
                    for (f = o * n, m = r * n, d = 0; d !== n; ++d) t[m + d] = t[f + d];
                    ++r
                }
                return r !== e.length ? (this.times = ad.arraySlice(e, 0, r), this.values = ad.arraySlice(t, 0, r * n)) : (this.times = e, this.values = t), this
            },
            clone: function () {
                var e = ad.arraySlice(this.times, 0),
                    t = ad.arraySlice(this.values, 0),
                    n = new (0, this.constructor)(this.name, e, t);
                return n.createInterpolant = this.createInterpolant, n
            }
        }), dd.prototype = Object.assign(Object.create(hd.prototype), {
            constructor: dd,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: Sr,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), pd.prototype = Object.assign(Object.create(hd.prototype), {
            constructor: pd,
            ValueTypeName: "color"
        }), fd.prototype = Object.assign(Object.create(hd.prototype), {
            constructor: fd,
            ValueTypeName: "number"
        }), md.prototype = Object.assign(Object.create(sd.prototype), {
            constructor: md,
            interpolate_: function (e, t, n, i) {
                for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, l = (n - t) / (i - t), c = s + a; s !== c; s += 4) Zr.slerpFlat(r, 0, o, s - a, o, s, l);
                return r
            }
        }), gd.prototype = Object.assign(Object.create(hd.prototype), {
            constructor: gd,
            ValueTypeName: "quaternion",
            DefaultInterpolation: Er,
            InterpolantFactoryMethodLinear: function (e) {
                return new md(this.times, this.values, this.getValueSize(), e)
            },
            InterpolantFactoryMethodSmooth: void 0
        }), vd.prototype = Object.assign(Object.create(hd.prototype), {
            constructor: vd,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: Sr,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), yd.prototype = Object.assign(Object.create(hd.prototype), {
            constructor: yd,
            ValueTypeName: "vector"
        }), Object.assign(xd, {
            parse: function (e) {
                for (var t = [], n = e.tracks, i = 1 / (e.fps || 1), r = 0, o = n.length; r !== o; ++r) t.push(wd(n[r]).scale(i));
                return new xd(e.name, e.duration, t)
            },
            toJSON: function (e) {
                for (var t = [], n = e.tracks, i = {
                    name: e.name,
                    duration: e.duration,
                    tracks: t,
                    uuid: e.uuid
                }, r = 0, o = n.length; r !== o; ++r) t.push(hd.toJSON(n[r]));
                return i
            },
            CreateFromMorphTargetSequence: function (e, t, n, i) {
                for (var r = t.length, o = [], a = 0; a < r; a++) {
                    var s = [],
                        l = [];
                    s.push((a + r - 1) % r, a, (a + 1) % r), l.push(0, 1, 0);
                    var c = ad.getKeyframeOrder(s);
                    s = ad.sortedArray(s, 1, c), l = ad.sortedArray(l, 1, c), i || 0 !== s[0] || (s.push(r), l.push(l[0])), o.push(new fd(".morphTargetInfluences[" + t[a].name + "]", s, l).scale(1 / n))
                }
                return new xd(e, -1, o)
            },
            findByName: function (e, t) {
                var n = e;
                if (!Array.isArray(e)) {
                    var i = e;
                    n = i.geometry && i.geometry.animations || i.animations
                }
                for (var r = 0; r < n.length; r++)
                    if (n[r].name === t) return n[r];
                return null
            },
            CreateClipsFromMorphTargetSequences: function (e, t, n) {
                for (var i = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = e.length; o < a; o++) {
                    var s = e[o],
                        l = s.name.match(r);
                    if (l && l.length > 1) {
                        var c = i[h = l[1]];
                        c || (i[h] = c = []), c.push(s)
                    }
                }
                var u = [];
                for (var h in i) u.push(xd.CreateFromMorphTargetSequence(h, i[h], t, n));
                return u
            },
            parseAnimation: function (e, t) {
                if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                for (var n = function (e, t, n, i, r) {
                    if (0 !== n.length) {
                        var o = [],
                            a = [];
                        ad.flattenJSON(n, o, a, i), 0 !== o.length && r.push(new e(t, o, a))
                    }
                }, i = [], r = e.name || "default", o = e.length || -1, a = e.fps || 30, s = e.hierarchy || [], l = 0; l < s.length; l++) {
                    var c = s[l].keys;
                    if (c && 0 !== c.length)
                        if (c[0].morphTargets) {
                            for (var u = {}, h = 0; h < c.length; h++)
                                if (c[h].morphTargets)
                                    for (var d = 0; d < c[h].morphTargets.length; d++) u[c[h].morphTargets[d]] = -1;
                            for (var p in u) {
                                var f = [],
                                    m = [];
                                for (d = 0; d !== c[h].morphTargets.length; ++d) {
                                    var g = c[h];
                                    f.push(g.time), m.push(g.morphTarget === p ? 1 : 0)
                                }
                                i.push(new fd(".morphTargetInfluence[" + p + "]", f, m))
                            }
                            o = u.length * (a || 1)
                        } else {
                            var v = ".bones[" + t[l].name + "]";
                            n(yd, v + ".position", c, "pos", i), n(gd, v + ".quaternion", c, "rot", i), n(yd, v + ".scale", c, "scl", i)
                        }
                }
                return 0 === i.length ? null : new xd(r, o, i)
            }
        }), Object.assign(xd.prototype, {
            resetDuration: function () {
                for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) {
                    var i = this.tracks[t];
                    e = Math.max(e, i.times[i.times.length - 1])
                }
                return this.duration = e, this
            },
            trim: function () {
                for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                return this
            },
            validate: function () {
                for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                return e
            },
            optimize: function () {
                for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                return this
            },
            clone: function () {
                for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                return new xd(this.name, this.duration, e)
            }
        });
        var bd = {
            enabled: !1,
            files: {},
            add: function (e, t) {
                !1 !== this.enabled && (this.files[e] = t)
            },
            get: function (e) {
                if (!1 !== this.enabled) return this.files[e]
            },
            remove: function (e) {
                delete this.files[e]
            },
            clear: function () {
                this.files = {}
            }
        };

        function _d(e, t, n) {
            var i = this,
                r = !1,
                o = 0,
                a = 0,
                s = void 0,
                l = [];
            this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) {
                a++, !1 === r && void 0 !== i.onStart && i.onStart(e, o, a), r = !0
            }, this.itemEnd = function (e) {
                o++, void 0 !== i.onProgress && i.onProgress(e, o, a), o === a && (r = !1, void 0 !== i.onLoad && i.onLoad())
            }, this.itemError = function (e) {
                void 0 !== i.onError && i.onError(e)
            }, this.resolveURL = function (e) {
                return s ? s(e) : e
            }, this.setURLModifier = function (e) {
                return s = e, this
            }, this.addHandler = function (e, t) {
                return l.push(e, t), this
            }, this.removeHandler = function (e) {
                var t = l.indexOf(e);
                return -1 !== t && l.splice(t, 2), this
            }, this.getHandler = function (e) {
                for (var t = 0, n = l.length; t < n; t += 2) {
                    var i = l[t],
                        r = l[t + 1];
                    if (i.global && (i.lastIndex = 0), i.test(e)) return r
                }
                return null
            }
        }
        var Md = new _d;

        function Td(e) {
            this.manager = void 0 !== e ? e : Md, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = ""
        }
        Object.assign(Td.prototype, {
            load: function () { },
            parse: function () { },
            setCrossOrigin: function (e) {
                return this.crossOrigin = e, this
            },
            setPath: function (e) {
                return this.path = e, this
            },
            setResourcePath: function (e) {
                return this.resourcePath = e, this
            }
        });
        var Sd = {};

        function Ed(e) {
            Td.call(this, e)
        }

        function Ad(e) {
            Td.call(this, e)
        }

        function Cd(e) {
            Td.call(this, e)
        }

        function Ld(e) {
            Td.call(this, e)
        }

        function Pd(e) {
            Td.call(this, e)
        }

        function Rd(e) {
            Td.call(this, e)
        }

        function Od(e) {
            Td.call(this, e)
        }

        function Dd() {
            this.type = "Curve", this.arcLengthDivisions = 200
        }

        function kd(e, t, n, i, r, o, a, s) {
            Dd.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
        }

        function Nd(e, t, n, i, r, o) {
            kd.call(this, e, t, n, n, i, r, o), this.type = "ArcCurve"
        }

        function Id() {
            var e = 0,
                t = 0,
                n = 0,
                i = 0;

            function r(r, o, a, s) {
                e = r, t = a, n = -3 * r + 3 * o - 2 * a - s, i = 2 * r - 2 * o + a + s
            }
            return {
                initCatmullRom: function (e, t, n, i, o) {
                    r(t, n, o * (n - e), o * (i - t))
                },
                initNonuniformCatmullRom: function (e, t, n, i, o, a, s) {
                    var l = (t - e) / o - (n - e) / (o + a) + (n - t) / a,
                        c = (n - t) / a - (i - t) / (a + s) + (i - n) / s;
                    r(t, n, l *= a, c *= a)
                },
                calc: function (r) {
                    var o = r * r;
                    return e + t * r + n * o + i * (o * r)
                }
            }
        }
        Ed.prototype = Object.assign(Object.create(Td.prototype), {
            constructor: Ed,
            load: function (e, t, n, i) {
                void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                var r = this,
                    o = bd.get(e);
                if (void 0 !== o) return r.manager.itemStart(e), setTimeout((function () {
                    t && t(o), r.manager.itemEnd(e)
                }), 0), o;
                if (void 0 === Sd[e]) {
                    var a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
                    if (a) {
                        var s = a[1],
                            l = !!a[2],
                            c = a[3];
                        c = decodeURIComponent(c), l && (c = atob(c));
                        try {
                            var u, h = (this.responseType || "").toLowerCase();
                            switch (h) {
                                case "arraybuffer":
                                case "blob":
                                    for (var d = new Uint8Array(c.length), p = 0; p < c.length; p++) d[p] = c.charCodeAt(p);
                                    u = "blob" === h ? new Blob([d.buffer], {
                                        type: s
                                    }) : d.buffer;
                                    break;
                                case "document":
                                    var f = new DOMParser;
                                    u = f.parseFromString(c, s);
                                    break;
                                case "json":
                                    u = JSON.parse(c);
                                    break;
                                default:
                                    u = c
                            }
                            setTimeout((function () {
                                t && t(u), r.manager.itemEnd(e)
                            }), 0)
                        } catch (t) {
                            setTimeout((function () {
                                i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                            }), 0)
                        }
                    } else {
                        Sd[e] = [], Sd[e].push({
                            onLoad: t,
                            onProgress: n,
                            onError: i
                        });
                        var m = new XMLHttpRequest;
                        for (var g in m.open("GET", e, !0), m.addEventListener("load", (function (t) {
                            var n = this.response,
                                i = Sd[e];
                            if (delete Sd[e], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), bd.add(e, n);
                                for (var o = 0, a = i.length; o < a; o++) {
                                    (s = i[o]).onLoad && s.onLoad(n)
                                }
                                r.manager.itemEnd(e)
                            } else {
                                for (o = 0, a = i.length; o < a; o++) {
                                    var s;
                                    (s = i[o]).onError && s.onError(t)
                                }
                                r.manager.itemError(e), r.manager.itemEnd(e)
                            }
                        }), !1), m.addEventListener("progress", (function (t) {
                            for (var n = Sd[e], i = 0, r = n.length; i < r; i++) {
                                var o = n[i];
                                o.onProgress && o.onProgress(t)
                            }
                        }), !1), m.addEventListener("error", (function (t) {
                            var n = Sd[e];
                            delete Sd[e];
                            for (var i = 0, o = n.length; i < o; i++) {
                                var a = n[i];
                                a.onError && a.onError(t)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }), !1), m.addEventListener("abort", (function (t) {
                            var n = Sd[e];
                            delete Sd[e];
                            for (var i = 0, o = n.length; i < o; i++) {
                                var a = n[i];
                                a.onError && a.onError(t)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }), !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(g, this.requestHeader[g]);
                        m.send(null)
                    }
                    return r.manager.itemStart(e), m
                }
                Sd[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: i
                })
            },
            setResponseType: function (e) {
                return this.responseType = e, this
            },
            setWithCredentials: function (e) {
                return this.withCredentials = e, this
            },
            setMimeType: function (e) {
                return this.mimeType = e, this
            },
            setRequestHeader: function (e) {
                return this.requestHeader = e, this
            }
        }), Ad.prototype = Object.assign(Object.create(Td.prototype), {
            constructor: Ad,
            load: function (e, t, n, i) {
                var r = this,
                    o = new Ed(r.manager);
                o.setPath(r.path), o.load(e, (function (e) {
                    t(r.parse(JSON.parse(e)))
                }), n, i)
            },
            parse: function (e) {
                for (var t = [], n = 0; n < e.length; n++) {
                    var i = xd.parse(e[n]);
                    t.push(i)
                }
                return t
            }
        }), Cd.prototype = Object.assign(Object.create(Td.prototype), {
            constructor: Cd,
            load: function (e, t, n, i) {
                var r = this,
                    o = [],
                    a = new Du;
                a.image = o;
                var s = new Ed(this.manager);

                function l(l) {
                    s.load(e[l], (function (e) {
                        var n = r.parse(e, !0);
                        o[l] = {
                            width: n.width,
                            height: n.height,
                            format: n.format,
                            mipmaps: n.mipmaps
                        }, 6 === (c += 1) && (1 === n.mipmapCount && (a.minFilter = pr), a.format = n.format, a.needsUpdate = !0, t && t(a))
                    }), n, i)
                }
                if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(e))
                    for (var c = 0, u = 0, h = e.length; u < h; ++u) l(u);
                else s.load(e, (function (e) {
                    var n = r.parse(e, !0);
                    if (n.isCubemap)
                        for (var i = n.mipmaps.length / n.mipmapCount, s = 0; s < i; s++) {
                            o[s] = {
                                mipmaps: []
                            };
                            for (var l = 0; l < n.mipmapCount; l++) o[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + l]), o[s].format = n.format, o[s].width = n.width, o[s].height = n.height
                        } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
                    1 === n.mipmapCount && (a.minFilter = pr), a.format = n.format, a.needsUpdate = !0, t && t(a)
                }), n, i);
                return a
            }
        }), Ld.prototype = Object.assign(Object.create(Td.prototype), {
            constructor: Ld,
            load: function (e, t, n, i) {
                var r = this,
                    o = new As,
                    a = new Ed(this.manager);
                return a.setResponseType("arraybuffer"), a.setPath(this.path), a.load(e, (function (e) {
                    var n = r.parse(e);
                    n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : lr, o.wrapT = void 0 !== n.wrapT ? n.wrapT : lr, o.magFilter = void 0 !== n.magFilter ? n.magFilter : pr, o.minFilter = void 0 !== n.minFilter ? n.minFilter : pr, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps, o.minFilter = fr), 1 === n.mipmapCount && (o.minFilter = pr), o.needsUpdate = !0, t && t(o, n))
                }), n, i), o
            }
        }), Pd.prototype = Object.assign(Object.create(Td.prototype), {
            constructor: Pd,
            load: function (e, t, n, i) {
                void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                var r = this,
                    o = bd.get(e);
                if (void 0 !== o) return r.manager.itemStart(e), setTimeout((function () {
                    t && t(o), r.manager.itemEnd(e)
                }), 0), o;
                var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                function s() {
                    a.removeEventListener("load", s, !1), a.removeEventListener("error", l, !1), bd.add(e, this), t && t(this), r.manager.itemEnd(e)
                }

                function l(t) {
                    a.removeEventListener("load", s, !1), a.removeEventListener("error", l, !1), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                }
                return a.addEventListener("load", s, !1), a.addEventListener("error", l, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a
            }
        }), Rd.prototype = Object.assign(Object.create(Td.prototype), {
            constructor: Rd,
            load: function (e, t, n, i) {
                var r = new Ys,
                    o = new Pd(this.manager);
                o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                var a = 0;

                function s(n) {
                    o.load(e[n], (function (e) {
                        r.images[n] = e, 6 === ++a && (r.needsUpdate = !0, t && t(r))
                    }), void 0, i)
                }
                for (var l = 0; l < e.length; ++l) s(l);
                return r
            }
        }), Od.prototype = Object.assign(Object.create(Td.prototype), {
            constructor: Od,
            load: function (e, t, n, i) {
                var r = new qr,
                    o = new Pd(this.manager);
                return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, (function (n) {
                    r.image = n;
                    var i = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                    r.format = i ? br : _r, r.needsUpdate = !0, void 0 !== t && t(r)
                }), n, i), r
            }
        }), Object.assign(Dd.prototype, {
            getPoint: function () {
                return console.warn("THREE.Curve: .getPoint() not implemented."), null
            },
            getPointAt: function (e, t) {
                var n = this.getUtoTmapping(e);
                return this.getPoint(n, t)
            },
            getPoints: function (e) {
                void 0 === e && (e = 5);
                for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                return t
            },
            getSpacedPoints: function (e) {
                void 0 === e && (e = 5);
                for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                return t
            },
            getLength: function () {
                var e = this.getLengths();
                return e[e.length - 1]
            },
            getLengths: function (e) {
                if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                var t, n, i = [],
                    r = this.getPoint(0),
                    o = 0;
                for (i.push(0), n = 1; n <= e; n++) o += (t = this.getPoint(n / e)).distanceTo(r), i.push(o), r = t;
                return this.cacheArcLengths = i, i
            },
            updateArcLengths: function () {
                this.needsUpdate = !0, this.getLengths()
            },
            getUtoTmapping: function (e, t) {
                var n, i = this.getLengths(),
                    r = 0,
                    o = i.length;
                n = t || e * i[o - 1];
                for (var a, s = 0, l = o - 1; s <= l;)
                    if ((a = i[r = Math.floor(s + (l - s) / 2)] - n) < 0) s = r + 1;
                    else {
                        if (!(a > 0)) {
                            l = r;
                            break
                        }
                        l = r - 1
                    }
                if (i[r = l] === n) return r / (o - 1);
                var c = i[r];
                return (r + (n - c) / (i[r + 1] - c)) / (o - 1)
            },
            getTangent: function (e) {
                var t = 1e-4,
                    n = e - t,
                    i = e + t;
                n < 0 && (n = 0), i > 1 && (i = 1);
                var r = this.getPoint(n);
                return this.getPoint(i).clone().sub(r).normalize()
            },
            getTangentAt: function (e) {
                var t = this.getUtoTmapping(e);
                return this.getTangent(t)
            },
            computeFrenetFrames: function (e, t) {
                var n, i, r, o = new Kr,
                    a = [],
                    s = [],
                    l = [],
                    c = new Kr,
                    u = new so;
                for (n = 0; n <= e; n++) i = n / e, a[n] = this.getTangentAt(i), a[n].normalize();
                s[0] = new Kr, l[0] = new Kr;
                var h = Number.MAX_VALUE,
                    d = Math.abs(a[0].x),
                    p = Math.abs(a[0].y),
                    f = Math.abs(a[0].z);
                for (d <= h && (h = d, o.set(1, 0, 0)), p <= h && (h = p, o.set(0, 1, 0)), f <= h && o.set(0, 0, 1), c.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], c), l[0].crossVectors(a[0], s[0]), n = 1; n <= e; n++) s[n] = s[n - 1].clone(), l[n] = l[n - 1].clone(), c.crossVectors(a[n - 1], a[n]), c.length() > Number.EPSILON && (c.normalize(), r = Math.acos(Ur.clamp(a[n - 1].dot(a[n]), -1, 1)), s[n].applyMatrix4(u.makeRotationAxis(c, r))), l[n].crossVectors(a[n], s[n]);
                if (!0 === t)
                    for (r = Math.acos(Ur.clamp(s[0].dot(s[e]), -1, 1)), r /= e, a[0].dot(c.crossVectors(s[0], s[e])) > 0 && (r = -r), n = 1; n <= e; n++) s[n].applyMatrix4(u.makeRotationAxis(a[n], r * n)), l[n].crossVectors(a[n], s[n]);
                return {
                    tangents: a,
                    normals: s,
                    binormals: l
                }
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.arcLengthDivisions = e.arcLengthDivisions, this
            },
            toJSON: function () {
                var e = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
            },
            fromJSON: function (e) {
                return this.arcLengthDivisions = e.arcLengthDivisions, this
            }
        }), kd.prototype = Object.create(Dd.prototype), kd.prototype.constructor = kd, kd.prototype.isEllipseCurve = !0, kd.prototype.getPoint = function (e, t) {
            for (var n = t || new jr, i = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; r < 0;) r += i;
            for (; r > i;) r -= i;
            r < Number.EPSILON && (r = o ? 0 : i), !0 !== this.aClockwise || o || (r === i ? r = -i : r -= i);
            var a = this.aStartAngle + e * r,
                s = this.aX + this.xRadius * Math.cos(a),
                l = this.aY + this.yRadius * Math.sin(a);
            if (0 !== this.aRotation) {
                var c = Math.cos(this.aRotation),
                    u = Math.sin(this.aRotation),
                    h = s - this.aX,
                    d = l - this.aY;
                s = h * c - d * u + this.aX, l = h * u + d * c + this.aY
            }
            return n.set(s, l)
        }, kd.prototype.copy = function (e) {
            return Dd.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
        }, kd.prototype.toJSON = function () {
            var e = Dd.prototype.toJSON.call(this);
            return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
        }, kd.prototype.fromJSON = function (e) {
            return Dd.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
        }, Nd.prototype = Object.create(kd.prototype), Nd.prototype.constructor = Nd, Nd.prototype.isArcCurve = !0;
        var zd = new Kr,
            Fd = new Id,
            Hd = new Id,
            Bd = new Id;

        function Ud(e, t, n, i) {
            Dd.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = n || "centripetal", this.tension = i || .5
        }

        function jd(e, t, n, i, r) {
            var o = .5 * (i - t),
                a = .5 * (r - n),
                s = e * e;
            return (2 * n - 2 * i + o + a) * (e * s) + (-3 * n + 3 * i - 2 * o - a) * s + o * e + n
        }

        function Gd(e, t, n, i) {
            return function (e, t) {
                var n = 1 - e;
                return n * n * t
            }(e, t) + function (e, t) {
                return 2 * (1 - e) * e * t
            }(e, n) + function (e, t) {
                return e * e * t
            }(e, i)
        }

        function Vd(e, t, n, i, r) {
            return function (e, t) {
                var n = 1 - e;
                return n * n * n * t
            }(e, t) + function (e, t) {
                var n = 1 - e;
                return 3 * n * n * e * t
            }(e, n) + function (e, t) {
                return 3 * (1 - e) * e * e * t
            }(e, i) + function (e, t) {
                return e * e * e * t
            }(e, r)
        }

        function Wd(e, t, n, i) {
            Dd.call(this), this.type = "CubicBezierCurve", this.v0 = e || new jr, this.v1 = t || new jr, this.v2 = n || new jr, this.v3 = i || new jr
        }

        function qd(e, t, n, i) {
            Dd.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new Kr, this.v1 = t || new Kr, this.v2 = n || new Kr, this.v3 = i || new Kr
        }

        function $d(e, t) {
            Dd.call(this), this.type = "LineCurve", this.v1 = e || new jr, this.v2 = t || new jr
        }

        function Xd(e, t) {
            Dd.call(this), this.type = "LineCurve3", this.v1 = e || new Kr, this.v2 = t || new Kr
        }

        function Yd(e, t, n) {
            Dd.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new jr, this.v1 = t || new jr, this.v2 = n || new jr
        }

        function Zd(e, t, n) {
            Dd.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new Kr, this.v1 = t || new Kr, this.v2 = n || new Kr
        }

        function Jd(e) {
            Dd.call(this), this.type = "SplineCurve", this.points = e || []
        }
        Ud.prototype = Object.create(Dd.prototype), Ud.prototype.constructor = Ud, Ud.prototype.isCatmullRomCurve3 = !0, Ud.prototype.getPoint = function (e, t) {
            var n, i, r, o, a = t || new Kr,
                s = this.points,
                l = s.length,
                c = (l - (this.closed ? 0 : 1)) * e,
                u = Math.floor(c),
                h = c - u;
            if (this.closed ? u += u > 0 ? 0 : (Math.floor(Math.abs(u) / l) + 1) * l : 0 === h && u === l - 1 && (u = l - 2, h = 1), this.closed || u > 0 ? n = s[(u - 1) % l] : (zd.subVectors(s[0], s[1]).add(s[0]), n = zd), i = s[u % l], r = s[(u + 1) % l], this.closed || u + 2 < l ? o = s[(u + 2) % l] : (zd.subVectors(s[l - 1], s[l - 2]).add(s[l - 1]), o = zd), "centripetal" === this.curveType || "chordal" === this.curveType) {
                var d = "chordal" === this.curveType ? .5 : .25,
                    p = Math.pow(n.distanceToSquared(i), d),
                    f = Math.pow(i.distanceToSquared(r), d),
                    m = Math.pow(r.distanceToSquared(o), d);
                f < 1e-4 && (f = 1), p < 1e-4 && (p = f), m < 1e-4 && (m = f), Fd.initNonuniformCatmullRom(n.x, i.x, r.x, o.x, p, f, m), Hd.initNonuniformCatmullRom(n.y, i.y, r.y, o.y, p, f, m), Bd.initNonuniformCatmullRom(n.z, i.z, r.z, o.z, p, f, m)
            } else "catmullrom" === this.curveType && (Fd.initCatmullRom(n.x, i.x, r.x, o.x, this.tension), Hd.initCatmullRom(n.y, i.y, r.y, o.y, this.tension), Bd.initCatmullRom(n.z, i.z, r.z, o.z, this.tension));
            return a.set(Fd.calc(h), Hd.calc(h), Bd.calc(h)), a
        }, Ud.prototype.copy = function (e) {
            Dd.prototype.copy.call(this, e), this.points = [];
            for (var t = 0, n = e.points.length; t < n; t++) {
                var i = e.points[t];
                this.points.push(i.clone())
            }
            return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
        }, Ud.prototype.toJSON = function () {
            var e = Dd.prototype.toJSON.call(this);
            e.points = [];
            for (var t = 0, n = this.points.length; t < n; t++) {
                var i = this.points[t];
                e.points.push(i.toArray())
            }
            return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
        }, Ud.prototype.fromJSON = function (e) {
            Dd.prototype.fromJSON.call(this, e), this.points = [];
            for (var t = 0, n = e.points.length; t < n; t++) {
                var i = e.points[t];
                this.points.push((new Kr).fromArray(i))
            }
            return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
        }, Wd.prototype = Object.create(Dd.prototype), Wd.prototype.constructor = Wd, Wd.prototype.isCubicBezierCurve = !0, Wd.prototype.getPoint = function (e, t) {
            var n = t || new jr,
                i = this.v0,
                r = this.v1,
                o = this.v2,
                a = this.v3;
            return n.set(Vd(e, i.x, r.x, o.x, a.x), Vd(e, i.y, r.y, o.y, a.y)), n
        }, Wd.prototype.copy = function (e) {
            return Dd.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
        }, Wd.prototype.toJSON = function () {
            var e = Dd.prototype.toJSON.call(this);
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
        }, Wd.prototype.fromJSON = function (e) {
            return Dd.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
        }, qd.prototype = Object.create(Dd.prototype), qd.prototype.constructor = qd, qd.prototype.isCubicBezierCurve3 = !0, qd.prototype.getPoint = function (e, t) {
            var n = t || new Kr,
                i = this.v0,
                r = this.v1,
                o = this.v2,
                a = this.v3;
            return n.set(Vd(e, i.x, r.x, o.x, a.x), Vd(e, i.y, r.y, o.y, a.y), Vd(e, i.z, r.z, o.z, a.z)), n
        }, qd.prototype.copy = function (e) {
            return Dd.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
        }, qd.prototype.toJSON = function () {
            var e = Dd.prototype.toJSON.call(this);
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
        }, qd.prototype.fromJSON = function (e) {
            return Dd.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
        }, $d.prototype = Object.create(Dd.prototype), $d.prototype.constructor = $d, $d.prototype.isLineCurve = !0, $d.prototype.getPoint = function (e, t) {
            var n = t || new jr;
            return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
        }, $d.prototype.getPointAt = function (e, t) {
            return this.getPoint(e, t)
        }, $d.prototype.getTangent = function () {
            return this.v2.clone().sub(this.v1).normalize()
        }, $d.prototype.copy = function (e) {
            return Dd.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
        }, $d.prototype.toJSON = function () {
            var e = Dd.prototype.toJSON.call(this);
            return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
        }, $d.prototype.fromJSON = function (e) {
            return Dd.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
        }, Xd.prototype = Object.create(Dd.prototype), Xd.prototype.constructor = Xd, Xd.prototype.isLineCurve3 = !0, Xd.prototype.getPoint = function (e, t) {
            var n = t || new Kr;
            return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
        }, Xd.prototype.getPointAt = function (e, t) {
            return this.getPoint(e, t)
        }, Xd.prototype.copy = function (e) {
            return Dd.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
        }, Xd.prototype.toJSON = function () {
            var e = Dd.prototype.toJSON.call(this);
            return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
        }, Xd.prototype.fromJSON = function (e) {
            return Dd.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
        }, Yd.prototype = Object.create(Dd.prototype), Yd.prototype.constructor = Yd, Yd.prototype.isQuadraticBezierCurve = !0, Yd.prototype.getPoint = function (e, t) {
            var n = t || new jr,
                i = this.v0,
                r = this.v1,
                o = this.v2;
            return n.set(Gd(e, i.x, r.x, o.x), Gd(e, i.y, r.y, o.y)), n
        }, Yd.prototype.copy = function (e) {
            return Dd.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
        }, Yd.prototype.toJSON = function () {
            var e = Dd.prototype.toJSON.call(this);
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
        }, Yd.prototype.fromJSON = function (e) {
            return Dd.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
        }, Zd.prototype = Object.create(Dd.prototype), Zd.prototype.constructor = Zd, Zd.prototype.isQuadraticBezierCurve3 = !0, Zd.prototype.getPoint = function (e, t) {
            var n = t || new Kr,
                i = this.v0,
                r = this.v1,
                o = this.v2;
            return n.set(Gd(e, i.x, r.x, o.x), Gd(e, i.y, r.y, o.y), Gd(e, i.z, r.z, o.z)), n
        }, Zd.prototype.copy = function (e) {
            return Dd.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
        }, Zd.prototype.toJSON = function () {
            var e = Dd.prototype.toJSON.call(this);
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
        }, Zd.prototype.fromJSON = function (e) {
            return Dd.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
        }, Jd.prototype = Object.create(Dd.prototype), Jd.prototype.constructor = Jd, Jd.prototype.isSplineCurve = !0, Jd.prototype.getPoint = function (e, t) {
            var n = t || new jr,
                i = this.points,
                r = (i.length - 1) * e,
                o = Math.floor(r),
                a = r - o,
                s = i[0 === o ? o : o - 1],
                l = i[o],
                c = i[o > i.length - 2 ? i.length - 1 : o + 1],
                u = i[o > i.length - 3 ? i.length - 1 : o + 2];
            return n.set(jd(a, s.x, l.x, c.x, u.x), jd(a, s.y, l.y, c.y, u.y)), n
        }, Jd.prototype.copy = function (e) {
            Dd.prototype.copy.call(this, e), this.points = [];
            for (var t = 0, n = e.points.length; t < n; t++) {
                var i = e.points[t];
                this.points.push(i.clone())
            }
            return this
        }, Jd.prototype.toJSON = function () {
            var e = Dd.prototype.toJSON.call(this);
            e.points = [];
            for (var t = 0, n = this.points.length; t < n; t++) {
                var i = this.points[t];
                e.points.push(i.toArray())
            }
            return e
        }, Jd.prototype.fromJSON = function (e) {
            Dd.prototype.fromJSON.call(this, e), this.points = [];
            for (var t = 0, n = e.points.length; t < n; t++) {
                var i = e.points[t];
                this.points.push((new jr).fromArray(i))
            }
            return this
        };
        var Qd = Object.freeze({
            __proto__: null,
            ArcCurve: Nd,
            CatmullRomCurve3: Ud,
            CubicBezierCurve: Wd,
            CubicBezierCurve3: qd,
            EllipseCurve: kd,
            LineCurve: $d,
            LineCurve3: Xd,
            QuadraticBezierCurve: Yd,
            QuadraticBezierCurve3: Zd,
            SplineCurve: Jd
        });

        function Kd() {
            Dd.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
        }

        function ep(e) {
            Kd.call(this), this.type = "Path", this.currentPoint = new jr, e && this.setFromPoints(e)
        }

        function tp(e) {
            ep.call(this, e), this.uuid = Ur.generateUUID(), this.type = "Shape", this.holes = []
        }

        function np(e, t) {
            Eo.call(this), this.type = "Light", this.color = new va(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
        }

        function ip(e, t, n) {
            np.call(this, e, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Eo.DefaultUp), this.updateMatrix(), this.groundColor = new va(t)
        }

        function rp(e) {
            this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new jr(512, 512), this.map = null, this.mapPass = null, this.matrix = new so, this._frustum = new Ps, this._frameExtents = new jr(1, 1), this._viewportCount = 1, this._viewports = [new $r(0, 0, 1, 1)]
        }

        function op() {
            rp.call(this, new Ms(50, 1, .5, 500))
        }

        function ap(e, t, n, i, r, o) {
            np.call(this, e, t), this.type = "SpotLight", this.position.copy(Eo.DefaultUp), this.updateMatrix(), this.target = new Eo, Object.defineProperty(this, "power", {
                get: function () {
                    return this.intensity * Math.PI
                },
                set: function (e) {
                    this.intensity = e / Math.PI
                }
            }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new op
        }

        function sp() {
            rp.call(this, new Ms(90, 1, .5, 500)), this._frameExtents = new jr(4, 2), this._viewportCount = 6, this._viewports = [new $r(2, 1, 1, 1), new $r(0, 1, 1, 1), new $r(3, 1, 1, 1), new $r(1, 1, 1, 1), new $r(3, 0, 1, 1), new $r(1, 0, 1, 1)], this._cubeDirections = [new Kr(1, 0, 0), new Kr(-1, 0, 0), new Kr(0, 0, 1), new Kr(0, 0, -1), new Kr(0, 1, 0), new Kr(0, -1, 0)], this._cubeUps = [new Kr(0, 1, 0), new Kr(0, 1, 0), new Kr(0, 1, 0), new Kr(0, 1, 0), new Kr(0, 0, 1), new Kr(0, 0, -1)]
        }

        function lp(e, t, n, i) {
            np.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
                get: function () {
                    return 4 * this.intensity * Math.PI
                },
                set: function (e) {
                    this.intensity = e / (4 * Math.PI)
                }
            }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new sp
        }

        function cp(e, t, n, i, r, o) {
            _s.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
        }

        function up() {
            rp.call(this, new cp(-5, 5, 5, -5, .5, 500))
        }

        function hp(e, t) {
            np.call(this, e, t), this.type = "DirectionalLight", this.position.copy(Eo.DefaultUp), this.updateMatrix(), this.target = new Eo, this.shadow = new up
        }

        function dp(e, t) {
            np.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
        }

        function pp(e, t, n, i) {
            np.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10
        }

        function fp(e) {
            Td.call(this, e), this.textures = {}
        }
        Kd.prototype = Object.assign(Object.create(Dd.prototype), {
            constructor: Kd,
            add: function (e) {
                this.curves.push(e)
            },
            closePath: function () {
                var e = this.curves[0].getPoint(0),
                    t = this.curves[this.curves.length - 1].getPoint(1);
                e.equals(t) || this.curves.push(new $d(t, e))
            },
            getPoint: function (e) {
                for (var t = e * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length;) {
                    if (n[i] >= t) {
                        var r = n[i] - t,
                            o = this.curves[i],
                            a = o.getLength(),
                            s = 0 === a ? 0 : 1 - r / a;
                        return o.getPointAt(s)
                    }
                    i++
                }
                return null
            },
            getLength: function () {
                var e = this.getCurveLengths();
                return e[e.length - 1]
            },
            updateArcLengths: function () {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            },
            getCurveLengths: function () {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                for (var e = [], t = 0, n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t);
                return this.cacheLengths = e, e
            },
            getSpacedPoints: function (e) {
                void 0 === e && (e = 40);
                for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                return this.autoClose && t.push(t[0]), t
            },
            getPoints: function (e) {
                e = e || 12;
                for (var t, n = [], i = 0, r = this.curves; i < r.length; i++)
                    for (var o = r[i], a = o && o.isEllipseCurve ? 2 * e : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? e * o.points.length : e, s = o.getPoints(a), l = 0; l < s.length; l++) {
                        var c = s[l];
                        t && t.equals(c) || (n.push(c), t = c)
                    }
                return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
            },
            copy: function (e) {
                Dd.prototype.copy.call(this, e), this.curves = [];
                for (var t = 0, n = e.curves.length; t < n; t++) {
                    var i = e.curves[t];
                    this.curves.push(i.clone())
                }
                return this.autoClose = e.autoClose, this
            },
            toJSON: function () {
                var e = Dd.prototype.toJSON.call(this);
                e.autoClose = this.autoClose, e.curves = [];
                for (var t = 0, n = this.curves.length; t < n; t++) {
                    var i = this.curves[t];
                    e.curves.push(i.toJSON())
                }
                return e
            },
            fromJSON: function (e) {
                Dd.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
                for (var t = 0, n = e.curves.length; t < n; t++) {
                    var i = e.curves[t];
                    this.curves.push((new Qd[i.type]).fromJSON(i))
                }
                return this
            }
        }), ep.prototype = Object.assign(Object.create(Kd.prototype), {
            constructor: ep,
            setFromPoints: function (e) {
                this.moveTo(e[0].x, e[0].y);
                for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
                return this
            },
            moveTo: function (e, t) {
                return this.currentPoint.set(e, t), this
            },
            lineTo: function (e, t) {
                var n = new $d(this.currentPoint.clone(), new jr(e, t));
                return this.curves.push(n), this.currentPoint.set(e, t), this
            },
            quadraticCurveTo: function (e, t, n, i) {
                var r = new Yd(this.currentPoint.clone(), new jr(e, t), new jr(n, i));
                return this.curves.push(r), this.currentPoint.set(n, i), this
            },
            bezierCurveTo: function (e, t, n, i, r, o) {
                var a = new Wd(this.currentPoint.clone(), new jr(e, t), new jr(n, i), new jr(r, o));
                return this.curves.push(a), this.currentPoint.set(r, o), this
            },
            splineThru: function (e) {
                var t = new Jd([this.currentPoint.clone()].concat(e));
                return this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this
            },
            arc: function (e, t, n, i, r, o) {
                var a = this.currentPoint.x,
                    s = this.currentPoint.y;
                return this.absarc(e + a, t + s, n, i, r, o), this
            },
            absarc: function (e, t, n, i, r, o) {
                return this.absellipse(e, t, n, n, i, r, o), this
            },
            ellipse: function (e, t, n, i, r, o, a, s) {
                var l = this.currentPoint.x,
                    c = this.currentPoint.y;
                return this.absellipse(e + l, t + c, n, i, r, o, a, s), this
            },
            absellipse: function (e, t, n, i, r, o, a, s) {
                var l = new kd(e, t, n, i, r, o, a, s);
                if (this.curves.length > 0) {
                    var c = l.getPoint(0);
                    c.equals(this.currentPoint) || this.lineTo(c.x, c.y)
                }
                this.curves.push(l);
                var u = l.getPoint(1);
                return this.currentPoint.copy(u), this
            },
            copy: function (e) {
                return Kd.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
            },
            toJSON: function () {
                var e = Kd.prototype.toJSON.call(this);
                return e.currentPoint = this.currentPoint.toArray(), e
            },
            fromJSON: function (e) {
                return Kd.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
            }
        }), tp.prototype = Object.assign(Object.create(ep.prototype), {
            constructor: tp,
            getPointsHoles: function (e) {
                for (var t = [], n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
                return t
            },
            extractPoints: function (e) {
                return {
                    shape: this.getPoints(e),
                    holes: this.getPointsHoles(e)
                }
            },
            copy: function (e) {
                ep.prototype.copy.call(this, e), this.holes = [];
                for (var t = 0, n = e.holes.length; t < n; t++) {
                    var i = e.holes[t];
                    this.holes.push(i.clone())
                }
                return this
            },
            toJSON: function () {
                var e = ep.prototype.toJSON.call(this);
                e.uuid = this.uuid, e.holes = [];
                for (var t = 0, n = this.holes.length; t < n; t++) {
                    var i = this.holes[t];
                    e.holes.push(i.toJSON())
                }
                return e
            },
            fromJSON: function (e) {
                ep.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
                for (var t = 0, n = e.holes.length; t < n; t++) {
                    var i = e.holes[t];
                    this.holes.push((new ep).fromJSON(i))
                }
                return this
            }
        }), np.prototype = Object.assign(Object.create(Eo.prototype), {
            constructor: np,
            isLight: !0,
            copy: function (e) {
                return Eo.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
            },
            toJSON: function (e) {
                var t = Eo.prototype.toJSON.call(this, e);
                return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
            }
        }), ip.prototype = Object.assign(Object.create(np.prototype), {
            constructor: ip,
            isHemisphereLight: !0,
            copy: function (e) {
                return np.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
            }
        }), Object.assign(rp.prototype, {
            _projScreenMatrix: new so,
            _lightPositionWorld: new Kr,
            _lookTarget: new Kr,
            getViewportCount: function () {
                return this._viewportCount
            },
            getFrustum: function () {
                return this._frustum
            },
            updateMatrices: function (e) {
                var t = this.camera,
                    n = this.matrix,
                    i = this._projScreenMatrix,
                    r = this._lookTarget,
                    o = this._lightPositionWorld;
                o.setFromMatrixPosition(e.matrixWorld), t.position.copy(o), r.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(r), t.updateMatrixWorld(), i.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(i), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
            },
            getViewport: function (e) {
                return this._viewports[e]
            },
            getFrameExtents: function () {
                return this._frameExtents
            },
            copy: function (e) {
                return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            toJSON: function () {
                var e = {};
                return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
            }
        }), op.prototype = Object.assign(Object.create(rp.prototype), {
            constructor: op,
            isSpotLightShadow: !0,
            updateMatrices: function (e) {
                var t = this.camera,
                    n = 2 * Ur.RAD2DEG * e.angle,
                    i = this.mapSize.width / this.mapSize.height,
                    r = e.distance || t.far;
                n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), rp.prototype.updateMatrices.call(this, e)
            }
        }), ap.prototype = Object.assign(Object.create(np.prototype), {
            constructor: ap,
            isSpotLight: !0,
            copy: function (e) {
                return np.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
        }), sp.prototype = Object.assign(Object.create(rp.prototype), {
            constructor: sp,
            isPointLightShadow: !0,
            updateMatrices: function (e, t) {
                void 0 === t && (t = 0);
                var n = this.camera,
                    i = this.matrix,
                    r = this._lightPositionWorld,
                    o = this._lookTarget,
                    a = this._projScreenMatrix;
                r.setFromMatrixPosition(e.matrixWorld), n.position.copy(r), o.copy(n.position), o.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(o), n.updateMatrixWorld(), i.makeTranslation(-r.x, -r.y, -r.z), a.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(a)
            }
        }), lp.prototype = Object.assign(Object.create(np.prototype), {
            constructor: lp,
            isPointLight: !0,
            copy: function (e) {
                return np.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
            }
        }), cp.prototype = Object.assign(Object.create(_s.prototype), {
            constructor: cp,
            isOrthographicCamera: !0,
            copy: function (e, t) {
                return _s.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
            },
            setViewOffset: function (e, t, n, i, r, o) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
            },
            clearViewOffset: function () {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function () {
                var e = (this.right - this.left) / (2 * this.zoom),
                    t = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    i = (this.top + this.bottom) / 2,
                    r = n - e,
                    o = n + e,
                    a = i + t,
                    s = i - t;
                if (null !== this.view && this.view.enabled) {
                    var l = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    o = (r += l * this.view.offsetX) + l * this.view.width, s = (a -= c * this.view.offsetY) - c * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, o, a, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
            },
            toJSON: function (e) {
                var t = Eo.prototype.toJSON.call(this, e);
                return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
            }
        }), up.prototype = Object.assign(Object.create(rp.prototype), {
            constructor: up,
            isDirectionalLightShadow: !0,
            updateMatrices: function (e) {
                rp.prototype.updateMatrices.call(this, e)
            }
        }), hp.prototype = Object.assign(Object.create(np.prototype), {
            constructor: hp,
            isDirectionalLight: !0,
            copy: function (e) {
                return np.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
        }), dp.prototype = Object.assign(Object.create(np.prototype), {
            constructor: dp,
            isAmbientLight: !0
        }), pp.prototype = Object.assign(Object.create(np.prototype), {
            constructor: pp,
            isRectAreaLight: !0,
            copy: function (e) {
                return np.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
            },
            toJSON: function (e) {
                var t = np.prototype.toJSON.call(this, e);
                return t.object.width = this.width, t.object.height = this.height, t
            }
        }), fp.prototype = Object.assign(Object.create(Td.prototype), {
            constructor: fp,
            load: function (e, t, n, i) {
                var r = this,
                    o = new Ed(r.manager);
                o.setPath(r.path), o.load(e, (function (e) {
                    t(r.parse(JSON.parse(e)))
                }), n, i)
            },
            parse: function (e) {
                var t = this.textures;

                function n(e) {
                    return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e]
                }
                var i = new od[e.type];
                if (void 0 !== e.uuid && (i.uuid = e.uuid), void 0 !== e.name && (i.name = e.name), void 0 !== e.color && i.color.setHex(e.color), void 0 !== e.roughness && (i.roughness = e.roughness), void 0 !== e.metalness && (i.metalness = e.metalness), void 0 !== e.sheen && (i.sheen = (new va).setHex(e.sheen)), void 0 !== e.emissive && i.emissive.setHex(e.emissive), void 0 !== e.specular && i.specular.setHex(e.specular), void 0 !== e.shininess && (i.shininess = e.shininess), void 0 !== e.clearcoat && (i.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (i.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.fog && (i.fog = e.fog), void 0 !== e.flatShading && (i.flatShading = e.flatShading), void 0 !== e.blending && (i.blending = e.blending), void 0 !== e.combine && (i.combine = e.combine), void 0 !== e.side && (i.side = e.side), void 0 !== e.opacity && (i.opacity = e.opacity), void 0 !== e.transparent && (i.transparent = e.transparent), void 0 !== e.alphaTest && (i.alphaTest = e.alphaTest), void 0 !== e.depthTest && (i.depthTest = e.depthTest), void 0 !== e.depthWrite && (i.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (i.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (i.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (i.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (i.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (i.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (i.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (i.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (i.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (i.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (i.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (i.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (i.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (i.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (i.rotation = e.rotation), 1 !== e.linewidth && (i.linewidth = e.linewidth), void 0 !== e.dashSize && (i.dashSize = e.dashSize), void 0 !== e.gapSize && (i.gapSize = e.gapSize), void 0 !== e.scale && (i.scale = e.scale), void 0 !== e.polygonOffset && (i.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (i.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (i.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (i.skinning = e.skinning), void 0 !== e.morphTargets && (i.morphTargets = e.morphTargets), void 0 !== e.morphNormals && (i.morphNormals = e.morphNormals), void 0 !== e.dithering && (i.dithering = e.dithering), void 0 !== e.vertexTangents && (i.vertexTangents = e.vertexTangents), void 0 !== e.visible && (i.visible = e.visible), void 0 !== e.toneMapped && (i.toneMapped = e.toneMapped), void 0 !== e.userData && (i.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), void 0 !== e.uniforms)
                    for (var r in e.uniforms) {
                        var o = e.uniforms[r];
                        switch (i.uniforms[r] = {}, o.type) {
                            case "t":
                                i.uniforms[r].value = n(o.value);
                                break;
                            case "c":
                                i.uniforms[r].value = (new va).setHex(o.value);
                                break;
                            case "v2":
                                i.uniforms[r].value = (new jr).fromArray(o.value);
                                break;
                            case "v3":
                                i.uniforms[r].value = (new Kr).fromArray(o.value);
                                break;
                            case "v4":
                                i.uniforms[r].value = (new $r).fromArray(o.value);
                                break;
                            case "m3":
                                i.uniforms[r].value = (new Gr).fromArray(o.value);
                            case "m4":
                                i.uniforms[r].value = (new so).fromArray(o.value);
                                break;
                            default:
                                i.uniforms[r].value = o.value
                        }
                    }
                if (void 0 !== e.defines && (i.defines = e.defines), void 0 !== e.vertexShader && (i.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (i.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                    for (var a in e.extensions) i.extensions[a] = e.extensions[a];
                if (void 0 !== e.shading && (i.flatShading = 1 === e.shading), void 0 !== e.size && (i.size = e.size), void 0 !== e.sizeAttenuation && (i.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (i.map = n(e.map)), void 0 !== e.matcap && (i.matcap = n(e.matcap)), void 0 !== e.alphaMap && (i.alphaMap = n(e.alphaMap)), void 0 !== e.bumpMap && (i.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (i.bumpScale = e.bumpScale), void 0 !== e.normalMap && (i.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (i.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
                    var s = e.normalScale;
                    !1 === Array.isArray(s) && (s = [s, s]), i.normalScale = (new jr).fromArray(s)
                }
                return void 0 !== e.displacementMap && (i.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (i.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (i.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (i.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (i.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (i.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (i.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (i.specularMap = n(e.specularMap)), void 0 !== e.envMap && (i.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (i.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (i.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (i.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (i.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (i.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (i.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (i.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (i.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatMap && (i.clearcoatMap = n(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (i.clearcoatNormalScale = (new jr).fromArray(e.clearcoatNormalScale)), i
            },
            setTextures: function (e) {
                return this.textures = e, this
            }
        });
        var mp = function (e) {
            var t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.substr(0, t + 1)
        };

        function gp() {
            Wa.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
        }

        function vp(e, t, n, i) {
            "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Ea.call(this, e, t, n), this.meshPerAttribute = i || 1
        }

        function yp(e) {
            Td.call(this, e)
        }
        gp.prototype = Object.assign(Object.create(Wa.prototype), {
            constructor: gp,
            isInstancedBufferGeometry: !0,
            copy: function (e) {
                return Wa.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            toJSON: function () {
                var e = Wa.prototype.toJSON.call(this);
                return e.maxInstancedCount = this.maxInstancedCount, e.isInstancedBufferGeometry = !0, e
            }
        }), vp.prototype = Object.assign(Object.create(Ea.prototype), {
            constructor: vp,
            isInstancedBufferAttribute: !0,
            copy: function (e) {
                return Ea.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
            },
            toJSON: function () {
                var e = Ea.prototype.toJSON.call(this);
                return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
            }
        }), yp.prototype = Object.assign(Object.create(Td.prototype), {
            constructor: yp,
            load: function (e, t, n, i) {
                var r = this,
                    o = new Ed(r.manager);
                o.setPath(r.path), o.load(e, (function (e) {
                    t(r.parse(JSON.parse(e)))
                }), n, i)
            },
            parse: function (e) {
                var t = e.isInstancedBufferGeometry ? new gp : new Wa,
                    n = e.data.index;
                if (void 0 !== n) {
                    var i = new xp[n.type](n.array);
                    t.setIndex(new Ea(i, 1))
                }
                var r = e.data.attributes;
                for (var o in r) {
                    var a = r[o],
                        s = (i = new xp[a.type](a.array), new (a.isInstancedBufferAttribute ? vp : Ea)(i, a.itemSize, a.normalized));
                    void 0 !== a.name && (s.name = a.name), t.setAttribute(o, s)
                }
                var l = e.data.morphAttributes;
                if (l)
                    for (var o in l) {
                        for (var c = l[o], u = [], h = 0, d = c.length; h < d; h++) {
                            a = c[h], s = new Ea(i = new xp[a.type](a.array), a.itemSize, a.normalized);
                            void 0 !== a.name && (s.name = a.name), u.push(s)
                        }
                        t.morphAttributes[o] = u
                    }
                e.data.morphTargetsRelative && (t.morphTargetsRelative = !0);
                var p = e.data.groups || e.data.drawcalls || e.data.offsets;
                if (void 0 !== p) {
                    h = 0;
                    for (var f = p.length; h !== f; ++h) {
                        var m = p[h];
                        t.addGroup(m.start, m.count, m.materialIndex)
                    }
                }
                var g = e.data.boundingSphere;
                if (void 0 !== g) {
                    var v = new Kr;
                    void 0 !== g.center && v.fromArray(g.center), t.boundingSphere = new Vo(v, g.radius)
                }
                return e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t
            }
        });
        var xp = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array
        };

        function wp(e) {
            Td.call(this, e)
        }
        wp.prototype = Object.assign(Object.create(Td.prototype), {
            constructor: wp,
            load: function (e, t, n, i) {
                var r = this,
                    o = "" === this.path ? mp(e) : this.path;
                this.resourcePath = this.resourcePath || o;
                var a = new Ed(r.manager);
                a.setPath(this.path), a.load(e, (function (n) {
                    var o = null;
                    try {
                        o = JSON.parse(n)
                    } catch (t) {
                        return void 0 !== i && i(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
                    }
                    var a = o.metadata;
                    void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? r.parse(o, t) : console.error("THREE.ObjectLoader: Can't load " + e)
                }), n, i)
            },
            parse: function (e, t) {
                var n = this.parseShape(e.shapes),
                    i = this.parseGeometries(e.geometries, n),
                    r = this.parseImages(e.images, (function () {
                        void 0 !== t && t(s)
                    })),
                    o = this.parseTextures(e.textures, r),
                    a = this.parseMaterials(e.materials, o),
                    s = this.parseObject(e.object, i, a);
                return e.animations && (s.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(s), s
            },
            parseShape: function (e) {
                var t = {};
                if (void 0 !== e)
                    for (var n = 0, i = e.length; n < i; n++) {
                        var r = (new tp).fromJSON(e[n]);
                        t[r.uuid] = r
                    }
                return t
            },
            parseGeometries: function (e, t) {
                var n = {};
                if (void 0 !== e)
                    for (var i = new yp, r = 0, o = e.length; r < o; r++) {
                        var a, s = e[r];
                        switch (s.type) {
                            case "PlaneGeometry":
                            case "PlaneBufferGeometry":
                                a = new Xh[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                                break;
                            case "BoxGeometry":
                            case "BoxBufferGeometry":
                            case "CubeGeometry":
                                a = new Xh[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                                break;
                            case "CircleGeometry":
                            case "CircleBufferGeometry":
                                a = new Xh[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                                break;
                            case "CylinderGeometry":
                            case "CylinderBufferGeometry":
                                a = new Xh[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                break;
                            case "ConeGeometry":
                            case "ConeBufferGeometry":
                                a = new Xh[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                break;
                            case "SphereGeometry":
                            case "SphereBufferGeometry":
                                a = new Xh[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                                break;
                            case "DodecahedronGeometry":
                            case "DodecahedronBufferGeometry":
                            case "IcosahedronGeometry":
                            case "IcosahedronBufferGeometry":
                            case "OctahedronGeometry":
                            case "OctahedronBufferGeometry":
                            case "TetrahedronGeometry":
                            case "TetrahedronBufferGeometry":
                                a = new Xh[s.type](s.radius, s.detail);
                                break;
                            case "RingGeometry":
                            case "RingBufferGeometry":
                                a = new Xh[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                                break;
                            case "TorusGeometry":
                            case "TorusBufferGeometry":
                                a = new Xh[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                                break;
                            case "TorusKnotGeometry":
                            case "TorusKnotBufferGeometry":
                                a = new Xh[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                                break;
                            case "TubeGeometry":
                            case "TubeBufferGeometry":
                                a = new Xh[s.type]((new Qd[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
                                break;
                            case "LatheGeometry":
                            case "LatheBufferGeometry":
                                a = new Xh[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                                break;
                            case "PolyhedronGeometry":
                            case "PolyhedronBufferGeometry":
                                a = new Xh[s.type](s.vertices, s.indices, s.radius, s.details);
                                break;
                            case "ShapeGeometry":
                            case "ShapeBufferGeometry":
                                for (var l = [], c = 0, u = s.shapes.length; c < u; c++) {
                                    var h = t[s.shapes[c]];
                                    l.push(h)
                                }
                                a = new Xh[s.type](l, s.curveSegments);
                                break;
                            case "ExtrudeGeometry":
                            case "ExtrudeBufferGeometry":
                                for (l = [], c = 0, u = s.shapes.length; c < u; c++) {
                                    h = t[s.shapes[c]];
                                    l.push(h)
                                }
                                var d = s.options.extrudePath;
                                void 0 !== d && (s.options.extrudePath = (new Qd[d.type]).fromJSON(d)), a = new Xh[s.type](l, s.options);
                                break;
                            case "BufferGeometry":
                            case "InstancedBufferGeometry":
                                a = i.parse(s);
                                break;
                            case "Geometry":
                                console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                                break;
                            default:
                                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                                continue
                        }
                        a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), !0 === a.isBufferGeometry && void 0 !== s.userData && (a.userData = s.userData), n[s.uuid] = a
                    }
                return n
            },
            parseMaterials: function (e, t) {
                var n = {},
                    i = {};
                if (void 0 !== e) {
                    var r = new fp;
                    r.setTextures(t);
                    for (var o = 0, a = e.length; o < a; o++) {
                        var s = e[o];
                        if ("MultiMaterial" === s.type) {
                            for (var l = [], c = 0; c < s.materials.length; c++) {
                                var u = s.materials[c];
                                void 0 === n[u.uuid] && (n[u.uuid] = r.parse(u)), l.push(n[u.uuid])
                            }
                            i[s.uuid] = l
                        } else void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)), i[s.uuid] = n[s.uuid]
                    }
                }
                return i
            },
            parseAnimations: function (e) {
                for (var t = [], n = 0; n < e.length; n++) {
                    var i = e[n],
                        r = xd.parse(i);
                    void 0 !== i.uuid && (r.uuid = i.uuid), t.push(r)
                }
                return t
            },
            parseImages: function (e, t) {
                var n = this,
                    i = {};

                function r(e) {
                    return n.manager.itemStart(e), o.load(e, (function () {
                        n.manager.itemEnd(e)
                    }), void 0, (function () {
                        n.manager.itemError(e), n.manager.itemEnd(e)
                    }))
                }
                if (void 0 !== e && e.length > 0) {
                    var o = new Pd(new _d(t));
                    o.setCrossOrigin(this.crossOrigin);
                    for (var a = 0, s = e.length; a < s; a++) {
                        var l = e[a],
                            c = l.url;
                        if (Array.isArray(c)) {
                            i[l.uuid] = [];
                            for (var u = 0, h = c.length; u < h; u++) {
                                var d = c[u],
                                    p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.resourcePath + d;
                                i[l.uuid].push(r(p))
                            }
                        } else {
                            p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : n.resourcePath + l.url;
                            i[l.uuid] = r(p)
                        }
                    }
                }
                return i
            },
            parseTextures: function (e, t) {
                function n(e, t) {
                    return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
                }
                var i = {};
                if (void 0 !== e)
                    for (var r = 0, o = e.length; r < o; r++) {
                        var a, s = e[r];
                        void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (a = Array.isArray(t[s.image]) ? new Ys(t[s.image]) : new qr(t[s.image])).needsUpdate = !0, a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, _p)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], Mp), a.wrapT = n(s.wrap[1], Mp)), void 0 !== s.format && (a.format = s.format), void 0 !== s.type && (a.type = s.type), void 0 !== s.encoding && (a.encoding = s.encoding), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, Tp)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, Tp)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment), i[s.uuid] = a
                    }
                return i
            },
            parseObject: function (e, t, n) {
                var i;

                function r(e) {
                    return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
                }

                function o(e) {
                    if (void 0 !== e) {
                        if (Array.isArray(e)) {
                            for (var t = [], i = 0, r = e.length; i < r; i++) {
                                var o = e[i];
                                void 0 === n[o] && console.warn("THREE.ObjectLoader: Undefined material", o), t.push(n[o])
                            }
                            return t
                        }
                        return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e]
                    }
                }
                switch (e.type) {
                    case "Scene":
                        i = new Ao, void 0 !== e.background && Number.isInteger(e.background) && (i.background = new va(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? i.fog = new Nc(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (i.fog = new kc(e.fog.color, e.fog.density)));
                        break;
                    case "PerspectiveCamera":
                        i = new Ms(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (i.focus = e.focus), void 0 !== e.zoom && (i.zoom = e.zoom), void 0 !== e.filmGauge && (i.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (i.filmOffset = e.filmOffset), void 0 !== e.view && (i.view = Object.assign({}, e.view));
                        break;
                    case "OrthographicCamera":
                        i = new cp(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (i.zoom = e.zoom), void 0 !== e.view && (i.view = Object.assign({}, e.view));
                        break;
                    case "AmbientLight":
                        i = new dp(e.color, e.intensity);
                        break;
                    case "DirectionalLight":
                        i = new hp(e.color, e.intensity);
                        break;
                    case "PointLight":
                        i = new lp(e.color, e.intensity, e.distance, e.decay);
                        break;
                    case "RectAreaLight":
                        i = new pp(e.color, e.intensity, e.width, e.height);
                        break;
                    case "SpotLight":
                        i = new ap(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                        break;
                    case "HemisphereLight":
                        i = new ip(e.color, e.groundColor, e.intensity);
                        break;
                    case "SkinnedMesh":
                        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                    case "Mesh":
                        i = new cs(a = r(e.geometry), s = o(e.material));
                        break;
                    case "InstancedMesh":
                        var a = r(e.geometry),
                            s = o(e.material),
                            l = e.count,
                            c = e.instanceMatrix;
                        (i = new pu(a, s, l)).instanceMatrix = new Ea(new Float32Array(c.array), 16);
                        break;
                    case "LOD":
                        i = new iu;
                        break;
                    case "Line":
                        i = new wu(r(e.geometry), o(e.material), e.mode);
                        break;
                    case "LineLoop":
                        i = new Tu(r(e.geometry), o(e.material));
                        break;
                    case "LineSegments":
                        i = new Mu(r(e.geometry), o(e.material));
                        break;
                    case "PointCloud":
                    case "Points":
                        i = new Pu(r(e.geometry), o(e.material));
                        break;
                    case "Sprite":
                        i = new Kc(o(e.material));
                        break;
                    case "Group":
                        i = new Rc;
                        break;
                    default:
                        i = new Eo
                }
                if (i.uuid = e.uuid, void 0 !== e.name && (i.name = e.name), void 0 !== e.matrix ? (i.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (i.matrixAutoUpdate = e.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== e.position && i.position.fromArray(e.position), void 0 !== e.rotation && i.rotation.fromArray(e.rotation), void 0 !== e.quaternion && i.quaternion.fromArray(e.quaternion), void 0 !== e.scale && i.scale.fromArray(e.scale)), void 0 !== e.castShadow && (i.castShadow = e.castShadow), void 0 !== e.receiveShadow && (i.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (i.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (i.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && i.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (i.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (i.visible = e.visible), void 0 !== e.frustumCulled && (i.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (i.renderOrder = e.renderOrder), void 0 !== e.userData && (i.userData = e.userData), void 0 !== e.layers && (i.layers.mask = e.layers), void 0 !== e.children)
                    for (var u = e.children, h = 0; h < u.length; h++) i.add(this.parseObject(u[h], t, n));
                if ("LOD" === e.type) {
                    void 0 !== e.autoUpdate && (i.autoUpdate = e.autoUpdate);
                    for (var d = e.levels, p = 0; p < d.length; p++) {
                        var f = d[p],
                            m = i.getObjectByProperty("uuid", f.object);
                        void 0 !== m && i.addLevel(m, f.distance)
                    }
                }
                return i
            }
        });
        var bp, _p = {
            UVMapping: 300,
            CubeReflectionMapping: 301,
            CubeRefractionMapping: 302,
            EquirectangularReflectionMapping: 303,
            EquirectangularRefractionMapping: 304,
            SphericalReflectionMapping: 305,
            CubeUVReflectionMapping: ar,
            CubeUVRefractionMapping: 307
        },
            Mp = {
                RepeatWrapping: sr,
                ClampToEdgeWrapping: lr,
                MirroredRepeatWrapping: cr
            },
            Tp = {
                NearestFilter: ur,
                NearestMipmapNearestFilter: hr,
                NearestMipmapLinearFilter: dr,
                LinearFilter: pr,
                LinearMipmapNearestFilter: 1007,
                LinearMipmapLinearFilter: fr
            };

        function Sp(e) {
            "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Td.call(this, e), this.options = void 0
        }

        function Ep() {
            this.type = "ShapePath", this.color = new va, this.subPaths = [], this.currentPath = null
        }

        function Ap(e) {
            this.type = "Font", this.data = e
        }

        function Cp(e, t, n, i, r) {
            var o = r.glyphs[e] || r.glyphs["?"];
            if (o) {
                var a, s, l, c, u, h, d, p, f = new Ep;
                if (o.o)
                    for (var m = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), g = 0, v = m.length; g < v;) {
                        switch (m[g++]) {
                            case "m":
                                a = m[g++] * t + n, s = m[g++] * t + i, f.moveTo(a, s);
                                break;
                            case "l":
                                a = m[g++] * t + n, s = m[g++] * t + i, f.lineTo(a, s);
                                break;
                            case "q":
                                l = m[g++] * t + n, c = m[g++] * t + i, u = m[g++] * t + n, h = m[g++] * t + i, f.quadraticCurveTo(u, h, l, c);
                                break;
                            case "b":
                                l = m[g++] * t + n, c = m[g++] * t + i, u = m[g++] * t + n, h = m[g++] * t + i, d = m[g++] * t + n, p = m[g++] * t + i, f.bezierCurveTo(u, h, d, p, l, c)
                        }
                    }
                return {
                    offsetX: o.ha * t,
                    path: f
                }
            }
            console.error('THREE.Font: character "' + e + '" does not exists in font family ' + r.familyName + ".")
        }

        function Lp(e) {
            Td.call(this, e)
        }
        Sp.prototype = Object.assign(Object.create(Td.prototype), {
            constructor: Sp,
            setOptions: function (e) {
                return this.options = e, this
            },
            load: function (e, t, n, i) {
                void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                var r = this,
                    o = bd.get(e);
                if (void 0 !== o) return r.manager.itemStart(e), setTimeout((function () {
                    t && t(o), r.manager.itemEnd(e)
                }), 0), o;
                fetch(e).then((function (e) {
                    return e.blob()
                })).then((function (e) {
                    return void 0 === r.options ? createImageBitmap(e) : createImageBitmap(e, r.options)
                })).then((function (n) {
                    bd.add(e, n), t && t(n), r.manager.itemEnd(e)
                })).catch((function (t) {
                    i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                })), r.manager.itemStart(e)
            }
        }), Object.assign(Ep.prototype, {
            moveTo: function (e, t) {
                return this.currentPath = new ep, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
            },
            lineTo: function (e, t) {
                return this.currentPath.lineTo(e, t), this
            },
            quadraticCurveTo: function (e, t, n, i) {
                return this.currentPath.quadraticCurveTo(e, t, n, i), this
            },
            bezierCurveTo: function (e, t, n, i, r, o) {
                return this.currentPath.bezierCurveTo(e, t, n, i, r, o), this
            },
            splineThru: function (e) {
                return this.currentPath.splineThru(e), this
            },
            toShapes: function (e, t) {
                function n(e) {
                    for (var t = [], n = 0, i = e.length; n < i; n++) {
                        var r = e[n],
                            o = new tp;
                        o.curves = r.curves, t.push(o)
                    }
                    return t
                }

                function i(e, t) {
                    for (var n = t.length, i = !1, r = n - 1, o = 0; o < n; r = o++) {
                        var a = t[r],
                            s = t[o],
                            l = s.x - a.x,
                            c = s.y - a.y;
                        if (Math.abs(c) > Number.EPSILON) {
                            if (c < 0 && (a = t[o], l = -l, s = t[r], c = -c), e.y < a.y || e.y > s.y) continue;
                            if (e.y === a.y) {
                                if (e.x === a.x) return !0
                            } else {
                                var u = c * (e.x - a.x) - l * (e.y - a.y);
                                if (0 === u) return !0;
                                if (u < 0) continue;
                                i = !i
                            }
                        } else {
                            if (e.y !== a.y) continue;
                            if (s.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= s.x) return !0
                        }
                    }
                    return i
                }
                var r = Mh.isClockWise,
                    o = this.subPaths;
                if (0 === o.length) return [];
                if (!0 === t) return n(o);
                var a, s, l, c = [];
                if (1 === o.length) return s = o[0], (l = new tp).curves = s.curves, c.push(l), c;
                var u = !r(o[0].getPoints());
                u = e ? !u : u;
                var h, d, p = [],
                    f = [],
                    m = [],
                    g = 0;
                f[g] = void 0, m[g] = [];
                for (var v = 0, y = o.length; v < y; v++) a = r(h = (s = o[v]).getPoints()), (a = e ? !a : a) ? (!u && f[g] && g++, f[g] = {
                    s: new tp,
                    p: h
                }, f[g].s.curves = s.curves, u && g++, m[g] = []) : m[g].push({
                    h: s,
                    p: h[0]
                });
                if (!f[0]) return n(o);
                if (f.length > 1) {
                    for (var x = !1, w = [], b = 0, _ = f.length; b < _; b++) p[b] = [];
                    for (b = 0, _ = f.length; b < _; b++)
                        for (var M = m[b], T = 0; T < M.length; T++) {
                            for (var S = M[T], E = !0, A = 0; A < f.length; A++) i(S.p, f[A].p) && (b !== A && w.push({
                                froms: b,
                                tos: A,
                                hole: T
                            }), E ? (E = !1, p[A].push(S)) : x = !0);
                            E && p[b].push(S)
                        }
                    w.length > 0 && (x || (m = p))
                }
                v = 0;
                for (var C = f.length; v < C; v++) {
                    l = f[v].s, c.push(l);
                    for (var L = 0, P = (d = m[v]).length; L < P; L++) l.holes.push(d[L].h)
                }
                return c
            }
        }), Object.assign(Ap.prototype, {
            isFont: !0,
            generateShapes: function (e, t) {
                void 0 === t && (t = 100);
                for (var n = [], i = function (e, t, n) {
                    for (var i = Array.from ? Array.from(e) : String(e).split(""), r = t / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, a = [], s = 0, l = 0, c = 0; c < i.length; c++) {
                        var u = i[c];
                        if ("\n" === u) s = 0, l -= o;
                        else {
                            var h = Cp(u, r, s, l, n);
                            s += h.offsetX, a.push(h.path)
                        }
                    }
                    return a
                }(e, t, this.data), r = 0, o = i.length; r < o; r++) Array.prototype.push.apply(n, i[r].toShapes());
                return n
            }
        }), Lp.prototype = Object.assign(Object.create(Td.prototype), {
            constructor: Lp,
            load: function (e, t, n, i) {
                var r = this,
                    o = new Ed(this.manager);
                o.setPath(this.path), o.load(e, (function (e) {
                    var n;
                    try {
                        n = JSON.parse(e)
                    } catch (t) {
                        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(e.substring(65, e.length - 2))
                    }
                    var i = r.parse(n);
                    t && t(i)
                }), n, i)
            },
            parse: function (e) {
                return new Ap(e)
            }
        });
        var Pp = function () {
            return void 0 === bp && (bp = new (window.AudioContext || window.webkitAudioContext)), bp
        };

        function Rp(e) {
            Td.call(this, e)
        }

        function Op() {
            this.coefficients = [];
            for (var e = 0; e < 9; e++) this.coefficients.push(new Kr)
        }

        function Dp(e, t) {
            np.call(this, void 0, t), this.sh = void 0 !== e ? e : new Op
        }

        function kp(e, t, n) {
            Dp.call(this, void 0, n);
            var i = (new va).set(e),
                r = (new va).set(t),
                o = new Kr(i.r, i.g, i.b),
                a = new Kr(r.r, r.g, r.b),
                s = Math.sqrt(Math.PI),
                l = s * Math.sqrt(.75);
            this.sh.coefficients[0].copy(o).add(a).multiplyScalar(s), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(l)
        }

        function Np(e, t) {
            Dp.call(this, void 0, t);
            var n = (new va).set(e);
            this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
        }
        Rp.prototype = Object.assign(Object.create(Td.prototype), {
            constructor: Rp,
            load: function (e, t, n, i) {
                var r = new Ed(this.manager);
                r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(e, (function (e) {
                    var n = e.slice(0);
                    Pp().decodeAudioData(n, (function (e) {
                        t(e)
                    }))
                }), n, i)
            }
        }), Object.assign(Op.prototype, {
            isSphericalHarmonics3: !0,
            set: function (e) {
                for (var t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                return this
            },
            zero: function () {
                for (var e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                return this
            },
            getAt: function (e, t) {
                var n = e.x,
                    i = e.y,
                    r = e.z,
                    o = this.coefficients;
                return t.copy(o[0]).multiplyScalar(.282095), t.addScaledVector(o[1], .488603 * i), t.addScaledVector(o[2], .488603 * r), t.addScaledVector(o[3], .488603 * n), t.addScaledVector(o[4], n * i * 1.092548), t.addScaledVector(o[5], i * r * 1.092548), t.addScaledVector(o[6], .315392 * (3 * r * r - 1)), t.addScaledVector(o[7], n * r * 1.092548), t.addScaledVector(o[8], .546274 * (n * n - i * i)), t
            },
            getIrradianceAt: function (e, t) {
                var n = e.x,
                    i = e.y,
                    r = e.z,
                    o = this.coefficients;
                return t.copy(o[0]).multiplyScalar(.886227), t.addScaledVector(o[1], 1.023328 * i), t.addScaledVector(o[2], 1.023328 * r), t.addScaledVector(o[3], 1.023328 * n), t.addScaledVector(o[4], .858086 * n * i), t.addScaledVector(o[5], .858086 * i * r), t.addScaledVector(o[6], .743125 * r * r - .247708), t.addScaledVector(o[7], .858086 * n * r), t.addScaledVector(o[8], .429043 * (n * n - i * i)), t
            },
            add: function (e) {
                for (var t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
                return this
            },
            addScaledSH: function (e, t) {
                for (var n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
                return this
            },
            scale: function (e) {
                for (var t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
                return this
            },
            lerp: function (e, t) {
                for (var n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
                return this
            },
            equals: function (e) {
                for (var t = 0; t < 9; t++)
                    if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
                return !0
            },
            copy: function (e) {
                return this.set(e.coefficients)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            fromArray: function (e, t) {
                void 0 === t && (t = 0);
                for (var n = this.coefficients, i = 0; i < 9; i++) n[i].fromArray(e, t + 3 * i);
                return this
            },
            toArray: function (e, t) {
                void 0 === e && (e = []), void 0 === t && (t = 0);
                for (var n = this.coefficients, i = 0; i < 9; i++) n[i].toArray(e, t + 3 * i);
                return e
            }
        }), Object.assign(Op, {
            getBasisAt: function (e, t) {
                var n = e.x,
                    i = e.y,
                    r = e.z;
                t[0] = .282095, t[1] = .488603 * i, t[2] = .488603 * r, t[3] = .488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * r, t[6] = .315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = .546274 * (n * n - i * i)
            }
        }), Dp.prototype = Object.assign(Object.create(np.prototype), {
            constructor: Dp,
            isLightProbe: !0,
            copy: function (e) {
                return np.prototype.copy.call(this, e), this.sh.copy(e.sh), this.intensity = e.intensity, this
            },
            toJSON: function (e) {
                return np.prototype.toJSON.call(this, e)
            }
        }), kp.prototype = Object.assign(Object.create(Dp.prototype), {
            constructor: kp,
            isHemisphereLightProbe: !0,
            copy: function (e) {
                return Dp.prototype.copy.call(this, e), this
            },
            toJSON: function (e) {
                return Dp.prototype.toJSON.call(this, e)
            }
        }), Np.prototype = Object.assign(Object.create(Dp.prototype), {
            constructor: Np,
            isAmbientLightProbe: !0,
            copy: function (e) {
                return Dp.prototype.copy.call(this, e), this
            },
            toJSON: function (e) {
                return Dp.prototype.toJSON.call(this, e)
            }
        });
        var Ip = new so,
            zp = new so;

        function Fp(e) {
            this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
        }
        Object.assign(function () {
            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Ms, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Ms, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                focus: null,
                fov: null,
                aspect: null,
                near: null,
                far: null,
                zoom: null,
                eyeSep: null
            }
        }.prototype, {
            update: function (e) {
                var t = this._cache;
                if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                    t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep;
                    var n, i, r = e.projectionMatrix.clone(),
                        o = t.eyeSep / 2,
                        a = o * t.near / t.focus,
                        s = t.near * Math.tan(Ur.DEG2RAD * t.fov * .5) / t.zoom;
                    zp.elements[12] = -o, Ip.elements[12] = o, n = -s * t.aspect + a, i = s * t.aspect + a, r.elements[0] = 2 * t.near / (i - n), r.elements[8] = (i + n) / (i - n), this.cameraL.projectionMatrix.copy(r), n = -s * t.aspect - a, i = s * t.aspect - a, r.elements[0] = 2 * t.near / (i - n), r.elements[8] = (i + n) / (i - n), this.cameraR.projectionMatrix.copy(r)
                }
                this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(zp), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Ip)
            }
        }), Object.assign(Fp.prototype, {
            start: function () {
                this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            },
            stop: function () {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            },
            getElapsedTime: function () {
                return this.getDelta(), this.elapsedTime
            },
            getDelta: function () {
                var e = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    var t = ("undefined" == typeof performance ? Date : performance).now();
                    e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                }
                return e
            }
        });
        var Hp = new Kr,
            Bp = new Zr,
            Up = new Kr,
            jp = new Kr;

        function Gp() {
            Eo.call(this), this.type = "AudioListener", this.context = Pp(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Fp
        }

        function Vp(e) {
            Eo.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this._startedAt = 0, this._pausedAt = 0, this.filters = []
        }
        Gp.prototype = Object.assign(Object.create(Eo.prototype), {
            constructor: Gp,
            getInput: function () {
                return this.gain
            },
            removeFilter: function () {
                return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
            },
            getFilter: function () {
                return this.filter
            },
            setFilter: function (e) {
                return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
            },
            getMasterVolume: function () {
                return this.gain.gain.value
            },
            setMasterVolume: function (e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
            },
            updateMatrixWorld: function (e) {
                Eo.prototype.updateMatrixWorld.call(this, e);
                var t = this.context.listener,
                    n = this.up;
                if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Hp, Bp, Up), jp.set(0, 0, -1).applyQuaternion(Bp), t.positionX) {
                    var i = this.context.currentTime + this.timeDelta;
                    t.positionX.linearRampToValueAtTime(Hp.x, i), t.positionY.linearRampToValueAtTime(Hp.y, i), t.positionZ.linearRampToValueAtTime(Hp.z, i), t.forwardX.linearRampToValueAtTime(jp.x, i), t.forwardY.linearRampToValueAtTime(jp.y, i), t.forwardZ.linearRampToValueAtTime(jp.z, i), t.upX.linearRampToValueAtTime(n.x, i), t.upY.linearRampToValueAtTime(n.y, i), t.upZ.linearRampToValueAtTime(n.z, i)
                } else t.setPosition(Hp.x, Hp.y, Hp.z), t.setOrientation(jp.x, jp.y, jp.z, n.x, n.y, n.z)
            }
        }), Vp.prototype = Object.assign(Object.create(Eo.prototype), {
            constructor: Vp,
            getOutput: function () {
                return this.gain
            },
            setNodeSource: function (e) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
            },
            setMediaElementSource: function (e) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
            },
            setMediaStreamSource: function (e) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
            },
            setBuffer: function (e) {
                return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
            },
            play: function (e) {
                if (void 0 === e && (e = 0), !0 !== this.isPlaying) {
                    if (!1 !== this.hasPlaybackControl) {
                        this._startedAt = this.context.currentTime + e;
                        var t = this.context.createBufferSource();
                        return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._pausedAt + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                    }
                    console.warn("THREE.Audio: this Audio has no playback control.")
                } else console.warn("THREE.Audio: Audio is already playing.")
            },
            pause: function () {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._pausedAt += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            stop: function () {
                if (!1 !== this.hasPlaybackControl) return this._pausedAt = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            connect: function () {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this
            },
            disconnect: function () {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this
            },
            getFilters: function () {
                return this.filters
            },
            setFilters: function (e) {
                return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
            },
            setDetune: function (e) {
                if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
            },
            getDetune: function () {
                return this.detune
            },
            getFilter: function () {
                return this.getFilters()[0]
            },
            setFilter: function (e) {
                return this.setFilters(e ? [e] : [])
            },
            setPlaybackRate: function (e) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            getPlaybackRate: function () {
                return this.playbackRate
            },
            onEnded: function () {
                this.isPlaying = !1
            },
            getLoop: function () {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            },
            setLoop: function (e) {
                if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            setLoopStart: function (e) {
                return this.loopStart = e, this
            },
            setLoopEnd: function (e) {
                return this.loopEnd = e, this
            },
            getVolume: function () {
                return this.gain.gain.value
            },
            setVolume: function (e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
            }
        });
        var Wp = new Kr,
            qp = new Zr,
            $p = new Kr,
            Xp = new Kr;

        function Yp(e) {
            Vp.call(this, e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
        }

        function Zp(e, t) {
            this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
        }

        function Jp(e, t, n) {
            this.binding = e, this.valueSize = n;
            var i, r = Float64Array;
            switch (t) {
                case "quaternion":
                    i = this._slerp;
                    break;
                case "string":
                case "bool":
                    r = Array, i = this._select;
                    break;
                default:
                    i = this._lerp
            }
            this.buffer = new r(4 * n), this._mixBufferRegion = i, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
        }
        Yp.prototype = Object.assign(Object.create(Vp.prototype), {
            constructor: Yp,
            getOutput: function () {
                return this.panner
            },
            getRefDistance: function () {
                return this.panner.refDistance
            },
            setRefDistance: function (e) {
                return this.panner.refDistance = e, this
            },
            getRolloffFactor: function () {
                return this.panner.rolloffFactor
            },
            setRolloffFactor: function (e) {
                return this.panner.rolloffFactor = e, this
            },
            getDistanceModel: function () {
                return this.panner.distanceModel
            },
            setDistanceModel: function (e) {
                return this.panner.distanceModel = e, this
            },
            getMaxDistance: function () {
                return this.panner.maxDistance
            },
            setMaxDistance: function (e) {
                return this.panner.maxDistance = e, this
            },
            setDirectionalCone: function (e, t, n) {
                return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
            },
            updateMatrixWorld: function (e) {
                if (Eo.prototype.updateMatrixWorld.call(this, e), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
                    this.matrixWorld.decompose(Wp, qp, $p), Xp.set(0, 0, 1).applyQuaternion(qp);
                    var t = this.panner;
                    if (t.positionX) {
                        var n = this.context.currentTime + this.listener.timeDelta;
                        t.positionX.linearRampToValueAtTime(Wp.x, n), t.positionY.linearRampToValueAtTime(Wp.y, n), t.positionZ.linearRampToValueAtTime(Wp.z, n), t.orientationX.linearRampToValueAtTime(Xp.x, n), t.orientationY.linearRampToValueAtTime(Xp.y, n), t.orientationZ.linearRampToValueAtTime(Xp.z, n)
                    } else t.setPosition(Wp.x, Wp.y, Wp.z), t.setOrientation(Xp.x, Xp.y, Xp.z)
                }
            }
        }), Object.assign(Zp.prototype, {
            getFrequencyData: function () {
                return this.analyser.getByteFrequencyData(this.data), this.data
            },
            getAverageFrequency: function () {
                for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n];
                return e / t.length
            }
        }), Object.assign(Jp.prototype, {
            accumulate: function (e, t) {
                var n = this.buffer,
                    i = this.valueSize,
                    r = e * i + i,
                    o = this.cumulativeWeight;
                if (0 === o) {
                    for (var a = 0; a !== i; ++a) n[r + a] = n[a];
                    o = t
                } else {
                    var s = t / (o += t);
                    this._mixBufferRegion(n, r, 0, s, i)
                }
                this.cumulativeWeight = o
            },
            apply: function (e) {
                var t = this.valueSize,
                    n = this.buffer,
                    i = e * t + t,
                    r = this.cumulativeWeight,
                    o = this.binding;
                if (this.cumulativeWeight = 0, r < 1) {
                    var a = 3 * t;
                    this._mixBufferRegion(n, i, a, 1 - r, t)
                }
                for (var s = t, l = t + t; s !== l; ++s)
                    if (n[s] !== n[s + t]) {
                        o.setValue(n, i);
                        break
                    }
            },
            saveOriginalState: function () {
                var e = this.binding,
                    t = this.buffer,
                    n = this.valueSize,
                    i = 3 * n;
                e.getValue(t, i);
                for (var r = n, o = i; r !== o; ++r) t[r] = t[i + r % n];
                this.cumulativeWeight = 0
            },
            restoreOriginalState: function () {
                var e = 3 * this.valueSize;
                this.binding.setValue(this.buffer, e)
            },
            _select: function (e, t, n, i, r) {
                if (i >= .5)
                    for (var o = 0; o !== r; ++o) e[t + o] = e[n + o]
            },
            _slerp: function (e, t, n, i) {
                Zr.slerpFlat(e, t, e, t, e, n, i)
            },
            _lerp: function (e, t, n, i, r) {
                for (var o = 1 - i, a = 0; a !== r; ++a) {
                    var s = t + a;
                    e[s] = e[s] * o + e[n + a] * i
                }
            }
        });
        var Qp = "\\[\\]\\.:\\/",
            Kp = new RegExp("[\\[\\]\\.:\\/]", "g"),
            ef = "[^\\[\\]\\.:\\/]",
            tf = "[^" + Qp.replace("\\.", "") + "]",
            nf = /((?:WC+[\/:])*)/.source.replace("WC", ef),
            rf = /(WCOD+)?/.source.replace("WCOD", tf),
            of = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ef),
            af = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ef),
            sf = new RegExp("^" + nf + rf + of + af + "$"),
            lf = ["material", "materials", "bones"];

        function cf(e, t, n) {
            var i = n || uf.parseTrackName(t);
            this._targetGroup = e, this._bindings = e.subscribe_(t, i)
        }

        function uf(e, t, n) {
            this.path = t, this.parsedPath = n || uf.parseTrackName(t), this.node = uf.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
        }

        function hf(e, t, n) {
            this._mixer = e, this._clip = t, this._localRoot = n || null;
            for (var i = t.tracks, r = i.length, o = new Array(r), a = {
                endingStart: Cr,
                endingEnd: Cr
            }, s = 0; s !== r; ++s) {
                var l = i[s].createInterpolant(null);
                o[s] = l, l.settings = a
            }
            this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
        }

        function df(e) {
            this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
        }

        function pf(e) {
            "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
        }

        function ff(e, t, n) {
            Ic.call(this, e, t), this.meshPerAttribute = n || 1
        }

        function mf(e, t, n, i) {
            this.ray = new Qo(e, t), this.near = n || 0, this.far = i || 1 / 0, this.camera = null, this.layers = new ho, this.params = {
                Mesh: {},
                Line: {
                    threshold: 1
                },
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }, Object.defineProperties(this.params, {
                PointCloud: {
                    get: function () {
                        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                    }
                }
            })
        }

        function gf(e, t) {
            return e.distance - t.distance
        }

        function vf(e, t, n, i) {
            if (e.layers.test(t.layers) && e.raycast(t, n), !0 === i)
                for (var r = e.children, o = 0, a = r.length; o < a; o++) vf(r[o], t, n, !0)
        }
        Object.assign(cf.prototype, {
            getValue: function (e, t) {
                this.bind();
                var n = this._targetGroup.nCachedObjects_,
                    i = this._bindings[n];
                void 0 !== i && i.getValue(e, t)
            },
            setValue: function (e, t) {
                for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t)
            },
            bind: function () {
                for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
            },
            unbind: function () {
                for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
            }
        }), Object.assign(uf, {
            Composite: cf,
            create: function (e, t, n) {
                return e && e.isAnimationObjectGroup ? new uf.Composite(e, t, n) : new uf(e, t, n)
            },
            sanitizeNodeName: function (e) {
                return e.replace(/\s/g, "_").replace(Kp, "")
            },
            parseTrackName: function (e) {
                var t = sf.exec(e);
                if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                var n = {
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    propertyIndex: t[6]
                },
                    i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    var r = n.nodeName.substring(i + 1); - 1 !== lf.indexOf(r) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return n
            },
            findNode: function (e, t) {
                if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                if (e.skeleton) {
                    var n = e.skeleton.getBoneByName(t);
                    if (void 0 !== n) return n
                }
                if (e.children) {
                    var i = function (e) {
                        for (var n = 0; n < e.length; n++) {
                            var r = e[n];
                            if (r.name === t || r.uuid === t) return r;
                            var o = i(r.children);
                            if (o) return o
                        }
                        return null
                    },
                        r = i(e.children);
                    if (r) return r
                }
                return null
            }
        }), Object.assign(uf.prototype, {
            _getValue_unavailable: function () { },
            _setValue_unavailable: function () { },
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function (e, t) {
                e[t] = this.node[this.propertyName]
            }, function (e, t) {
                for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) e[t++] = n[i]
            }, function (e, t) {
                e[t] = this.resolvedProperty[this.propertyIndex]
            }, function (e, t) {
                this.resolvedProperty.toArray(e, t)
            }],
            SetterByBindingTypeAndVersioning: [
                [function (e, t) {
                    this.targetObject[this.propertyName] = e[t]
                }, function (e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                }, function (e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function (e, t) {
                    for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++]
                }, function (e, t) {
                    for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                    this.targetObject.needsUpdate = !0
                }, function (e, t) {
                    for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function (e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t]
                }, function (e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                }, function (e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function (e, t) {
                    this.resolvedProperty.fromArray(e, t)
                }, function (e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                }, function (e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                }]
            ],
            getValue: function (e, t) {
                this.bind(), this.getValue(e, t)
            },
            setValue: function (e, t) {
                this.bind(), this.setValue(e, t)
            },
            bind: function () {
                var e = this.node,
                    t = this.parsedPath,
                    n = t.objectName,
                    i = t.propertyName,
                    r = t.propertyIndex;
                if (e || (e = uf.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
                    if (n) {
                        var o = t.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                e = e.skeleton.bones;
                                for (var a = 0; a < e.length; a++)
                                    if (e[a].name === o) {
                                        o = a;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                e = e[n]
                        }
                        if (void 0 !== o) {
                            if (void 0 === e[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                            e = e[o]
                        }
                    }
                    var s = e[i];
                    if (void 0 !== s) {
                        var l = this.Versioning.None;
                        this.targetObject = e, void 0 !== e.needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate);
                        var c = this.BindingType.Direct;
                        if (void 0 !== r) {
                            if ("morphTargetInfluences" === i) {
                                if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (e.geometry.isBufferGeometry) {
                                    if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                        if (e.geometry.morphAttributes.position[a].name === r) {
                                            r = a;
                                            break
                                        }
                                } else {
                                    if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                    for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                        if (e.geometry.morphTargets[a].name === r) {
                                            r = a;
                                            break
                                        }
                                }
                            }
                            c = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                        } else void 0 !== s.fromArray && void 0 !== s.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (c = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                        this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l]
                    } else {
                        var u = t.nodeName;
                        console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + i + " but it wasn't found.", e)
                    }
                } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
            },
            unbind: function () {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }), Object.assign(uf.prototype, {
            _getValue_unbound: uf.prototype.getValue,
            _setValue_unbound: uf.prototype.setValue
        }), Object.assign(function () {
            this.uuid = Ur.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
            var e = {};
            this._indicesByUUID = e;
            for (var t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
            var i = this;
            this.stats = {
                objects: {
                    get total() {
                        return i._objects.length
                    },
                    get inUse() {
                        return this.total - i.nCachedObjects_
                    }
                },
                get bindingsPerObject() {
                    return i._bindings.length
                }
            }
        }.prototype, {
            isAnimationObjectGroup: !0,
            add: function () {
                for (var e = this._objects, t = e.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, l = void 0, c = 0, u = arguments.length; c !== u; ++c) {
                    var h = arguments[c],
                        d = h.uuid,
                        p = i[d];
                    if (void 0 === p) {
                        p = t++, i[d] = p, e.push(h);
                        for (var f = 0, m = s; f !== m; ++f) a[f].push(new uf(h, r[f], o[f]))
                    } else if (p < n) {
                        l = e[p];
                        var g = --n,
                            v = e[g];
                        i[v.uuid] = p, e[p] = v, i[d] = g, e[g] = h;
                        for (f = 0, m = s; f !== m; ++f) {
                            var y = a[f],
                                x = y[g],
                                w = y[p];
                            y[p] = x, void 0 === w && (w = new uf(h, r[f], o[f])), y[g] = w
                        }
                    } else e[p] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = n
            },
            remove: function () {
                for (var e = this._objects, t = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, o = 0, a = arguments.length; o !== a; ++o) {
                    var s = arguments[o],
                        l = s.uuid,
                        c = n[l];
                    if (void 0 !== c && c >= t) {
                        var u = t++,
                            h = e[u];
                        n[h.uuid] = c, e[c] = h, n[l] = u, e[u] = s;
                        for (var d = 0, p = r; d !== p; ++d) {
                            var f = i[d],
                                m = f[u],
                                g = f[c];
                            f[c] = m, f[u] = g
                        }
                    }
                }
                this.nCachedObjects_ = t
            },
            uncache: function () {
                for (var e = this._objects, t = e.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
                    var l = arguments[a],
                        c = l.uuid,
                        u = i[c];
                    if (void 0 !== u)
                        if (delete i[c], u < n) {
                            var h = --n,
                                d = e[h],
                                p = e[y = --t];
                            i[d.uuid] = u, e[u] = d, i[p.uuid] = h, e[h] = p, e.pop();
                            for (var f = 0, m = o; f !== m; ++f) {
                                var g = (x = r[f])[h],
                                    v = x[y];
                                x[u] = g, x[h] = v, x.pop()
                            }
                        } else {
                            var y;
                            i[(p = e[y = --t]).uuid] = u, e[u] = p, e.pop();
                            for (f = 0, m = o; f !== m; ++f) {
                                var x;
                                (x = r[f])[u] = x[y], x.pop()
                            }
                        }
                }
                this.nCachedObjects_ = n
            },
            subscribe_: function (e, t) {
                var n = this._bindingsIndicesByPath,
                    i = n[e],
                    r = this._bindings;
                if (void 0 !== i) return r[i];
                var o = this._paths,
                    a = this._parsedPaths,
                    s = this._objects,
                    l = s.length,
                    c = this.nCachedObjects_,
                    u = new Array(l);
                i = r.length, n[e] = i, o.push(e), a.push(t), r.push(u);
                for (var h = c, d = s.length; h !== d; ++h) {
                    var p = s[h];
                    u[h] = new uf(p, e, t)
                }
                return u
            },
            unsubscribe_: function (e) {
                var t = this._bindingsIndicesByPath,
                    n = t[e];
                if (void 0 !== n) {
                    var i = this._paths,
                        r = this._parsedPaths,
                        o = this._bindings,
                        a = o.length - 1,
                        s = o[a];
                    t[e[a]] = n, o[n] = s, o.pop(), r[n] = r[a], r.pop(), i[n] = i[a], i.pop()
                }
            }
        }), Object.assign(hf.prototype, {
            play: function () {
                return this._mixer._activateAction(this), this
            },
            stop: function () {
                return this._mixer._deactivateAction(this), this.reset()
            },
            reset: function () {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            },
            isRunning: function () {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            },
            isScheduled: function () {
                return this._mixer._isActiveAction(this)
            },
            startAt: function (e) {
                return this._startTime = e, this
            },
            setLoop: function (e, t) {
                return this.loop = e, this.repetitions = t, this
            },
            setEffectiveWeight: function (e) {
                return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
            },
            getEffectiveWeight: function () {
                return this._effectiveWeight
            },
            fadeIn: function (e) {
                return this._scheduleFading(e, 0, 1)
            },
            fadeOut: function (e) {
                return this._scheduleFading(e, 1, 0)
            },
            crossFadeFrom: function (e, t, n) {
                if (e.fadeOut(t), this.fadeIn(t), n) {
                    var i = this._clip.duration,
                        r = e._clip.duration,
                        o = r / i,
                        a = i / r;
                    e.warp(1, o, t), this.warp(a, 1, t)
                }
                return this
            },
            crossFadeTo: function (e, t, n) {
                return e.crossFadeFrom(this, t, n)
            },
            stopFading: function () {
                var e = this._weightInterpolant;
                return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            },
            setEffectiveTimeScale: function (e) {
                return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
            },
            getEffectiveTimeScale: function () {
                return this._effectiveTimeScale
            },
            setDuration: function (e) {
                return this.timeScale = this._clip.duration / e, this.stopWarping()
            },
            syncWith: function (e) {
                return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
            },
            halt: function (e) {
                return this.warp(this._effectiveTimeScale, 0, e)
            },
            warp: function (e, t, n) {
                var i = this._mixer,
                    r = i.time,
                    o = this._timeScaleInterpolant,
                    a = this.timeScale;
                null === o && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
                var s = o.parameterPositions,
                    l = o.sampleValues;
                return s[0] = r, s[1] = r + n, l[0] = e / a, l[1] = t / a, this
            },
            stopWarping: function () {
                var e = this._timeScaleInterpolant;
                return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            },
            getMixer: function () {
                return this._mixer
            },
            getClip: function () {
                return this._clip
            },
            getRoot: function () {
                return this._localRoot || this._mixer._root
            },
            _update: function (e, t, n, i) {
                if (this.enabled) {
                    var r = this._startTime;
                    if (null !== r) {
                        var o = (e - r) * n;
                        if (o < 0 || 0 === n) return;
                        this._startTime = null, t = n * o
                    }
                    t *= this._updateTimeScale(e);
                    var a = this._updateTime(t),
                        s = this._updateWeight(e);
                    if (s > 0)
                        for (var l = this._interpolants, c = this._propertyBindings, u = 0, h = l.length; u !== h; ++u) l[u].evaluate(a), c[u].accumulate(i, s)
                } else this._updateWeight(e)
            },
            _updateWeight: function (e) {
                var t = 0;
                if (this.enabled) {
                    t = this.weight;
                    var n = this._weightInterpolant;
                    if (null !== n) {
                        var i = n.evaluate(e)[0];
                        t *= i, e > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = t, t
            },
            _updateTimeScale: function (e) {
                var t = 0;
                if (!this.paused) {
                    t = this.timeScale;
                    var n = this._timeScaleInterpolant;
                    if (null !== n) t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                }
                return this._effectiveTimeScale = t, t
            },
            _updateTime: function (e) {
                var t = this.time + e,
                    n = this._clip.duration,
                    i = this.loop,
                    r = this._loopCount,
                    o = 2202 === i;
                if (0 === e) return -1 === r ? t : o && 1 == (1 & r) ? n - t : t;
                if (2200 === i) {
                    -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    e: {
                        if (t >= n) t = n;
                        else {
                            if (!(t < 0)) {
                                this.time = t;
                                break e
                            }
                            t = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = t,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e < 0 ? -1 : 1
                            })
                    }
                } else {
                    if (-1 === r && (e >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), t >= n || t < 0) {
                        var a = Math.floor(t / n);
                        t -= n * a, r += Math.abs(a);
                        var s = this.repetitions - r;
                        if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = e > 0 ? n : 0, this.time = t, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e > 0 ? 1 : -1
                        });
                        else {
                            if (1 === s) {
                                var l = e < 0;
                                this._setEndings(l, !l, o)
                            } else this._setEndings(!1, !1, o);
                            this._loopCount = r, this.time = t, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: a
                            })
                        }
                    } else this.time = t;
                    if (o && 1 == (1 & r)) return n - t
                }
                return t
            },
            _setEndings: function (e, t, n) {
                var i = this._interpolantSettings;
                n ? (i.endingStart = Lr, i.endingEnd = Lr) : (i.endingStart = e ? this.zeroSlopeAtStart ? Lr : Cr : Pr, i.endingEnd = t ? this.zeroSlopeAtEnd ? Lr : Cr : Pr)
            },
            _scheduleFading: function (e, t, n) {
                var i = this._mixer,
                    r = i.time,
                    o = this._weightInterpolant;
                null === o && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
                var a = o.parameterPositions,
                    s = o.sampleValues;
                return a[0] = r, s[0] = t, a[1] = r + e, s[1] = n, this
            }
        }), df.prototype = Object.assign(Object.create(zr.prototype), {
            constructor: df,
            _bindAction: function (e, t) {
                var n = e._localRoot || this._root,
                    i = e._clip.tracks,
                    r = i.length,
                    o = e._propertyBindings,
                    a = e._interpolants,
                    s = n.uuid,
                    l = this._bindingsByRootAndName,
                    c = l[s];
                void 0 === c && (c = {}, l[s] = c);
                for (var u = 0; u !== r; ++u) {
                    var h = i[u],
                        d = h.name,
                        p = c[d];
                    if (void 0 !== p) o[u] = p;
                    else {
                        if (void 0 !== (p = o[u])) {
                            null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                            continue
                        }
                        var f = t && t._propertyBindings[u].binding.parsedPath;
                        ++(p = new Jp(uf.create(n, d, f), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(p, s, d), o[u] = p
                    }
                    a[u].resultBuffer = p.buffer
                }
            },
            _activateAction: function (e) {
                if (!this._isActiveAction(e)) {
                    if (null === e._cacheIndex) {
                        var t = (e._localRoot || this._root).uuid,
                            n = e._clip.uuid,
                            i = this._actionsByClip[n];
                        this._bindAction(e, i && i.knownActions[0]), this._addInactiveAction(e, n, t)
                    }
                    for (var r = e._propertyBindings, o = 0, a = r.length; o !== a; ++o) {
                        var s = r[o];
                        0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                    }
                    this._lendAction(e)
                }
            },
            _deactivateAction: function (e) {
                if (this._isActiveAction(e)) {
                    for (var t = e._propertyBindings, n = 0, i = t.length; n !== i; ++n) {
                        var r = t[n];
                        0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                    }
                    this._takeBackAction(e)
                }
            },
            _initMemoryManager: function () {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var e = this;
                this.stats = {
                    actions: {
                        get total() {
                            return e._actions.length
                        },
                        get inUse() {
                            return e._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return e._bindings.length
                        },
                        get inUse() {
                            return e._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return e._controlInterpolants.length
                        },
                        get inUse() {
                            return e._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function (e) {
                var t = e._cacheIndex;
                return null !== t && t < this._nActiveActions
            },
            _addInactiveAction: function (e, t, n) {
                var i = this._actions,
                    r = this._actionsByClip,
                    o = r[t];
                if (void 0 === o) o = {
                    knownActions: [e],
                    actionByRoot: {}
                }, e._byClipCacheIndex = 0, r[t] = o;
                else {
                    var a = o.knownActions;
                    e._byClipCacheIndex = a.length, a.push(e)
                }
                e._cacheIndex = i.length, i.push(e), o.actionByRoot[n] = e
            },
            _removeInactiveAction: function (e) {
                var t = this._actions,
                    n = t[t.length - 1],
                    i = e._cacheIndex;
                n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
                var r = e._clip.uuid,
                    o = this._actionsByClip,
                    a = o[r],
                    s = a.knownActions,
                    l = s[s.length - 1],
                    c = e._byClipCacheIndex;
                l._byClipCacheIndex = c, s[c] = l, s.pop(), e._byClipCacheIndex = null, delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete o[r], this._removeInactiveBindingsForAction(e)
            },
            _removeInactiveBindingsForAction: function (e) {
                for (var t = e._propertyBindings, n = 0, i = t.length; n !== i; ++n) {
                    var r = t[n];
                    0 == --r.referenceCount && this._removeInactiveBinding(r)
                }
            },
            _lendAction: function (e) {
                var t = this._actions,
                    n = e._cacheIndex,
                    i = this._nActiveActions++,
                    r = t[i];
                e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
            },
            _takeBackAction: function (e) {
                var t = this._actions,
                    n = e._cacheIndex,
                    i = --this._nActiveActions,
                    r = t[i];
                e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
            },
            _addInactiveBinding: function (e, t, n) {
                var i = this._bindingsByRootAndName,
                    r = i[t],
                    o = this._bindings;
                void 0 === r && (r = {}, i[t] = r), r[n] = e, e._cacheIndex = o.length, o.push(e)
            },
            _removeInactiveBinding: function (e) {
                var t = this._bindings,
                    n = e.binding,
                    i = n.rootNode.uuid,
                    r = n.path,
                    o = this._bindingsByRootAndName,
                    a = o[i],
                    s = t[t.length - 1],
                    l = e._cacheIndex;
                s._cacheIndex = l, t[l] = s, t.pop(), delete a[r], 0 === Object.keys(a).length && delete o[i]
            },
            _lendBinding: function (e) {
                var t = this._bindings,
                    n = e._cacheIndex,
                    i = this._nActiveBindings++,
                    r = t[i];
                e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
            },
            _takeBackBinding: function (e) {
                var t = this._bindings,
                    n = e._cacheIndex,
                    i = --this._nActiveBindings,
                    r = t[i];
                e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
            },
            _lendControlInterpolant: function () {
                var e = this._controlInterpolants,
                    t = this._nActiveControlInterpolants++,
                    n = e[t];
                return void 0 === n && ((n = new cd(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = n), n
            },
            _takeBackControlInterpolant: function (e) {
                var t = this._controlInterpolants,
                    n = e.__cacheIndex,
                    i = --this._nActiveControlInterpolants,
                    r = t[i];
                e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r
            },
            _controlInterpolantsResultBuffer: new Float32Array(1),
            clipAction: function (e, t) {
                var n = t || this._root,
                    i = n.uuid,
                    r = "string" == typeof e ? xd.findByName(n, e) : e,
                    o = null !== r ? r.uuid : e,
                    a = this._actionsByClip[o],
                    s = null;
                if (void 0 !== a) {
                    var l = a.actionByRoot[i];
                    if (void 0 !== l) return l;
                    s = a.knownActions[0], null === r && (r = s._clip)
                }
                if (null === r) return null;
                var c = new hf(this, r, t);
                return this._bindAction(c, s), this._addInactiveAction(c, o, i), c
            },
            existingAction: function (e, t) {
                var n = t || this._root,
                    i = n.uuid,
                    r = "string" == typeof e ? xd.findByName(n, e) : e,
                    o = r ? r.uuid : e,
                    a = this._actionsByClip[o];
                return void 0 !== a && a.actionByRoot[i] || null
            },
            stopAllAction: function () {
                var e = this._actions,
                    t = this._nActiveActions,
                    n = this._bindings,
                    i = this._nActiveBindings;
                this._nActiveActions = 0, this._nActiveBindings = 0;
                for (var r = 0; r !== t; ++r) e[r].reset();
                for (r = 0; r !== i; ++r) n[r].useCount = 0;
                return this
            },
            update: function (e) {
                e *= this.timeScale;
                for (var t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) {
                    t[a]._update(i, e, r, o)
                }
                var s = this._bindings,
                    l = this._nActiveBindings;
                for (a = 0; a !== l; ++a) s[a].apply(o);
                return this
            },
            setTime: function (e) {
                this.time = 0;
                for (var t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                return this.update(e)
            },
            getRoot: function () {
                return this._root
            },
            uncacheClip: function (e) {
                var t = this._actions,
                    n = e.uuid,
                    i = this._actionsByClip,
                    r = i[n];
                if (void 0 !== r) {
                    for (var o = r.knownActions, a = 0, s = o.length; a !== s; ++a) {
                        var l = o[a];
                        this._deactivateAction(l);
                        var c = l._cacheIndex,
                            u = t[t.length - 1];
                        l._cacheIndex = null, l._byClipCacheIndex = null, u._cacheIndex = c, t[c] = u, t.pop(), this._removeInactiveBindingsForAction(l)
                    }
                    delete i[n]
                }
            },
            uncacheRoot: function (e) {
                var t = e.uuid,
                    n = this._actionsByClip;
                for (var i in n) {
                    var r = n[i].actionByRoot[t];
                    void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                }
                var o = this._bindingsByRootAndName[t];
                if (void 0 !== o)
                    for (var a in o) {
                        var s = o[a];
                        s.restoreOriginalState(), this._removeInactiveBinding(s)
                    }
            },
            uncacheAction: function (e, t) {
                var n = this.existingAction(e, t);
                null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
            }
        }), pf.prototype.clone = function () {
            return new pf(void 0 === this.value.clone ? this.value : this.value.clone())
        }, ff.prototype = Object.assign(Object.create(Ic.prototype), {
            constructor: ff,
            isInstancedInterleavedBuffer: !0,
            copy: function (e) {
                return Ic.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
            }
        }), Object.assign(mf.prototype, {
            set: function (e, t) {
                this.ray.set(e, t)
            },
            setFromCamera: function (e, t) {
                t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type.")
            },
            intersectObject: function (e, t, n) {
                var i = n || [];
                return vf(e, this, i, t), i.sort(gf), i
            },
            intersectObjects: function (e, t, n) {
                var i = n || [];
                if (!1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
                for (var r = 0, o = e.length; r < o; r++) vf(e[r], this, i, t);
                return i.sort(gf), i
            }
        }), Object.assign(function (e, t, n) {
            return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== n ? n : 0, this
        }.prototype, {
            set: function (e, t, n) {
                return this.radius = e, this.phi = t, this.theta = n, this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
            },
            makeSafe: function () {
                var e = 1e-6;
                return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this
            },
            setFromVector3: function (e) {
                return this.setFromCartesianCoords(e.x, e.y, e.z)
            },
            setFromCartesianCoords: function (e, t, n) {
                return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Ur.clamp(t / this.radius, -1, 1))), this
            }
        }), Object.assign(function (e, t, n) {
            return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this
        }.prototype, {
            set: function (e, t, n) {
                return this.radius = e, this.theta = t, this.y = n, this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
            },
            setFromVector3: function (e) {
                return this.setFromCartesianCoords(e.x, e.y, e.z)
            },
            setFromCartesianCoords: function (e, t, n) {
                return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
            }
        });
        var yf = new jr;

        function xf(e, t) {
            this.min = void 0 !== e ? e : new jr(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new jr(-1 / 0, -1 / 0)
        }
        Object.assign(xf.prototype, {
            set: function (e, t) {
                return this.min.copy(e), this.max.copy(t), this
            },
            setFromPoints: function (e) {
                this.makeEmpty();
                for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                return this
            },
            setFromCenterAndSize: function (e, t) {
                var n = yf.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.min.copy(e.min), this.max.copy(e.max), this
            },
            makeEmpty: function () {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
            },
            isEmpty: function () {
                return this.max.x < this.min.x || this.max.y < this.min.y
            },
            getCenter: function (e) {
                return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new jr), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function (e) {
                return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new jr), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
            },
            expandByPoint: function (e) {
                return this.min.min(e), this.max.max(e), this
            },
            expandByVector: function (e) {
                return this.min.sub(e), this.max.add(e), this
            },
            expandByScalar: function (e) {
                return this.min.addScalar(-e), this.max.addScalar(e), this
            },
            containsPoint: function (e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
            },
            containsBox: function (e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
            },
            getParameter: function (e, t) {
                return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new jr), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
            },
            intersectsBox: function (e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
            },
            clampPoint: function (e, t) {
                return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new jr), t.copy(e).clamp(this.min, this.max)
            },
            distanceToPoint: function (e) {
                return yf.copy(e).clamp(this.min, this.max).sub(e).length()
            },
            intersect: function (e) {
                return this.min.max(e.min), this.max.min(e.max), this
            },
            union: function (e) {
                return this.min.min(e.min), this.max.max(e.max), this
            },
            translate: function (e) {
                return this.min.add(e), this.max.add(e), this
            },
            equals: function (e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        });
        var wf = new Kr,
            bf = new Kr;

        function _f(e, t) {
            this.start = void 0 !== e ? e : new Kr, this.end = void 0 !== t ? t : new Kr
        }

        function Mf(e) {
            Eo.call(this), this.material = e, this.render = function () { }
        }
        Object.assign(_f.prototype, {
            set: function (e, t) {
                return this.start.copy(e), this.end.copy(t), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.start.copy(e.start), this.end.copy(e.end), this
            },
            getCenter: function (e) {
                return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new Kr), e.addVectors(this.start, this.end).multiplyScalar(.5)
            },
            delta: function (e) {
                return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new Kr), e.subVectors(this.end, this.start)
            },
            distanceSq: function () {
                return this.start.distanceToSquared(this.end)
            },
            distance: function () {
                return this.start.distanceTo(this.end)
            },
            at: function (e, t) {
                return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new Kr), this.delta(t).multiplyScalar(e).add(this.start)
            },
            closestPointToPointParameter: function (e, t) {
                wf.subVectors(e, this.start), bf.subVectors(this.end, this.start);
                var n = bf.dot(bf),
                    i = bf.dot(wf) / n;
                return t && (i = Ur.clamp(i, 0, 1)), i
            },
            closestPointToPoint: function (e, t, n) {
                var i = this.closestPointToPointParameter(e, t);
                return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new Kr), this.delta(n).multiplyScalar(i).add(this.start)
            },
            applyMatrix4: function (e) {
                return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
            },
            equals: function (e) {
                return e.start.equals(this.start) && e.end.equals(this.end)
            }
        }), Mf.prototype = Object.create(Eo.prototype), Mf.prototype.constructor = Mf, Mf.prototype.isImmediateRenderObject = !0;
        var Tf = new Kr;

        function Sf(e, t) {
            Eo.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
            for (var n = new Wa, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, o = 1; r < 32; r++, o++) {
                var a = r / 32 * Math.PI * 2,
                    s = o / 32 * Math.PI * 2;
                i.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
            }
            n.setAttribute("position", new ka(i, 3));
            var l = new fu({
                fog: !1,
                toneMapped: !1
            });
            this.cone = new Mu(n, l), this.add(this.cone), this.update()
        }
        Sf.prototype = Object.create(Eo.prototype), Sf.prototype.constructor = Sf, Sf.prototype.dispose = function () {
            this.cone.geometry.dispose(), this.cone.material.dispose()
        }, Sf.prototype.update = function () {
            this.light.updateMatrixWorld();
            var e = this.light.distance ? this.light.distance : 1e3,
                t = e * Math.tan(this.light.angle);
            this.cone.scale.set(t, t, e), Tf.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Tf), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        };
        var Ef = new Kr,
            Af = new so,
            Cf = new so;

        function Lf(e) {
            var t = [];
            e && e.isBone && t.push(e);
            for (var n = 0; n < e.children.length; n++) t.push.apply(t, Lf(e.children[n]));
            return t
        }

        function Pf(e) {
            for (var t = Lf(e), n = new Wa, i = [], r = [], o = new va(0, 0, 1), a = new va(0, 1, 0), s = 0; s < t.length; s++) {
                var l = t[s];
                l.parent && l.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b))
            }
            n.setAttribute("position", new ka(i, 3)), n.setAttribute("color", new ka(r, 3));
            var c = new fu({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0
            });
            Mu.call(this, n, c), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
        }

        function Rf(e, t, n) {
            this.light = e, this.light.updateMatrixWorld(), this.color = n;
            var i = new Dh(t, 4, 2),
                r = new Ta({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                });
            cs.call(this, i, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
        }
        Pf.prototype = Object.create(Mu.prototype), Pf.prototype.constructor = Pf, Pf.prototype.isSkeletonHelper = !0, Pf.prototype.updateMatrixWorld = function (e) {
            var t = this.bones,
                n = this.geometry,
                i = n.getAttribute("position");
            Cf.getInverse(this.root.matrixWorld);
            for (var r = 0, o = 0; r < t.length; r++) {
                var a = t[r];
                a.parent && a.parent.isBone && (Af.multiplyMatrices(Cf, a.matrixWorld), Ef.setFromMatrixPosition(Af), i.setXYZ(o, Ef.x, Ef.y, Ef.z), Af.multiplyMatrices(Cf, a.parent.matrixWorld), Ef.setFromMatrixPosition(Af), i.setXYZ(o + 1, Ef.x, Ef.y, Ef.z), o += 2)
            }
            n.getAttribute("position").needsUpdate = !0, Eo.prototype.updateMatrixWorld.call(this, e)
        }, Rf.prototype = Object.create(cs.prototype), Rf.prototype.constructor = Rf, Rf.prototype.dispose = function () {
            this.geometry.dispose(), this.material.dispose()
        }, Rf.prototype.update = function () {
            void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
        };
        var Of = new Kr,
            Df = new va,
            kf = new va;

        function Nf(e, t, n) {
            Eo.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
            var i = new Vu(t);
            i.rotateY(.5 * Math.PI), this.material = new Ta({
                wireframe: !0,
                fog: !1,
                toneMapped: !1
            }), void 0 === this.color && (this.material.vertexColors = !0);
            var r = i.getAttribute("position"),
                o = new Float32Array(3 * r.count);
            i.setAttribute("color", new Ea(o, 3)), this.add(new cs(i, this.material)), this.update()
        }

        function If(e, t, n, i) {
            e = e || 10, t = t || 10, n = new va(void 0 !== n ? n : 4473924), i = new va(void 0 !== i ? i : 8947848);
            for (var r = t / 2, o = e / t, a = e / 2, s = [], l = [], c = 0, u = 0, h = -a; c <= t; c++, h += o) {
                s.push(-a, 0, h, a, 0, h), s.push(h, 0, -a, h, 0, a);
                var d = c === r ? n : i;
                d.toArray(l, u), u += 3, d.toArray(l, u), u += 3, d.toArray(l, u), u += 3, d.toArray(l, u), u += 3
            }
            var p = new Wa;
            p.setAttribute("position", new ka(s, 3)), p.setAttribute("color", new ka(l, 3));
            var f = new fu({
                vertexColors: !0,
                toneMapped: !1
            });
            Mu.call(this, p, f)
        }

        function zf(e, t, n, i, r, o) {
            e = e || 10, t = t || 16, n = n || 8, i = i || 64, r = new va(void 0 !== r ? r : 4473924), o = new va(void 0 !== o ? o : 8947848);
            var a, s, l, c, u, h, d, p = [],
                f = [];
            for (c = 0; c <= t; c++) l = c / t * (2 * Math.PI), a = Math.sin(l) * e, s = Math.cos(l) * e, p.push(0, 0, 0), p.push(a, 0, s), d = 1 & c ? r : o, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
            for (c = 0; c <= n; c++)
                for (d = 1 & c ? r : o, h = e - e / n * c, u = 0; u < i; u++) l = u / i * (2 * Math.PI), a = Math.sin(l) * h, s = Math.cos(l) * h, p.push(a, 0, s), f.push(d.r, d.g, d.b), l = (u + 1) / i * (2 * Math.PI), a = Math.sin(l) * h, s = Math.cos(l) * h, p.push(a, 0, s), f.push(d.r, d.g, d.b);
            var m = new Wa;
            m.setAttribute("position", new ka(p, 3)), m.setAttribute("color", new ka(f, 3));
            var g = new fu({
                vertexColors: !0,
                toneMapped: !1
            });
            Mu.call(this, m, g)
        }
        Nf.prototype = Object.create(Eo.prototype), Nf.prototype.constructor = Nf, Nf.prototype.dispose = function () {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, Nf.prototype.update = function () {
            var e = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color);
            else {
                var t = e.geometry.getAttribute("color");
                Df.copy(this.light.color), kf.copy(this.light.groundColor);
                for (var n = 0, i = t.count; n < i; n++) {
                    var r = n < i / 2 ? Df : kf;
                    t.setXYZ(n, r.r, r.g, r.b)
                }
                t.needsUpdate = !0
            }
            e.lookAt(Of.setFromMatrixPosition(this.light.matrixWorld).negate())
        }, If.prototype = Object.assign(Object.create(Mu.prototype), {
            constructor: If,
            copy: function (e) {
                return Mu.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            }
        }), zf.prototype = Object.create(Mu.prototype), zf.prototype.constructor = zf;
        var Ff = new Kr,
            Hf = new Kr,
            Bf = new Kr;

        function Uf(e, t, n) {
            Eo.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
            var i = new Wa;
            i.setAttribute("position", new ka([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
            var r = new fu({
                fog: !1,
                toneMapped: !1
            });
            this.lightPlane = new wu(i, r), this.add(this.lightPlane), (i = new Wa).setAttribute("position", new ka([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new wu(i, r), this.add(this.targetLine), this.update()
        }
        Uf.prototype = Object.create(Eo.prototype), Uf.prototype.constructor = Uf, Uf.prototype.dispose = function () {
            this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
        }, Uf.prototype.update = function () {
            Ff.setFromMatrixPosition(this.light.matrixWorld), Hf.setFromMatrixPosition(this.light.target.matrixWorld), Bf.subVectors(Hf, Ff), this.lightPlane.lookAt(Hf), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Hf), this.targetLine.scale.z = Bf.length()
        };
        var jf = new Kr,
            Gf = new _s;

        function Vf(e) {
            var t = new Wa,
                n = new fu({
                    color: 16777215,
                    vertexColors: !0,
                    toneMapped: !1
                }),
                i = [],
                r = [],
                o = {},
                a = new va(16755200),
                s = new va(16711680),
                l = new va(43775),
                c = new va(16777215),
                u = new va(3355443);

            function h(e, t, n) {
                d(e, n), d(t, n)
            }

            function d(e, t) {
                i.push(0, 0, 0), r.push(t.r, t.g, t.b), void 0 === o[e] && (o[e] = []), o[e].push(i.length / 3 - 1)
            }
            h("n1", "n2", a), h("n2", "n4", a), h("n4", "n3", a), h("n3", "n1", a), h("f1", "f2", a), h("f2", "f4", a), h("f4", "f3", a), h("f3", "f1", a), h("n1", "f1", a), h("n2", "f2", a), h("n3", "f3", a), h("n4", "f4", a), h("p", "n1", s), h("p", "n2", s), h("p", "n3", s), h("p", "n4", s), h("u1", "u2", l), h("u2", "u3", l), h("u3", "u1", l), h("c", "t", c), h("p", "c", u), h("cn1", "cn2", u), h("cn3", "cn4", u), h("cf1", "cf2", u), h("cf3", "cf4", u), t.setAttribute("position", new ka(i, 3)), t.setAttribute("color", new ka(r, 3)), Mu.call(this, t, n), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
        }

        function Wf(e, t, n, i, r, o, a) {
            jf.set(r, o, a).unproject(i);
            var s = t[e];
            if (void 0 !== s)
                for (var l = n.getAttribute("position"), c = 0, u = s.length; c < u; c++) l.setXYZ(s[c], jf.x, jf.y, jf.z)
        }
        Vf.prototype = Object.create(Mu.prototype), Vf.prototype.constructor = Vf, Vf.prototype.update = function () {
            var e = this.geometry,
                t = this.pointMap;
            Gf.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Wf("c", t, e, Gf, 0, 0, -1), Wf("t", t, e, Gf, 0, 0, 1), Wf("n1", t, e, Gf, -1, -1, -1), Wf("n2", t, e, Gf, 1, -1, -1), Wf("n3", t, e, Gf, -1, 1, -1), Wf("n4", t, e, Gf, 1, 1, -1), Wf("f1", t, e, Gf, -1, -1, 1), Wf("f2", t, e, Gf, 1, -1, 1), Wf("f3", t, e, Gf, -1, 1, 1), Wf("f4", t, e, Gf, 1, 1, 1), Wf("u1", t, e, Gf, .7, 1.1, -1), Wf("u2", t, e, Gf, -.7, 1.1, -1), Wf("u3", t, e, Gf, 0, 2, -1), Wf("cf1", t, e, Gf, -1, 0, 1), Wf("cf2", t, e, Gf, 1, 0, 1), Wf("cf3", t, e, Gf, 0, -1, 1), Wf("cf4", t, e, Gf, 0, 1, 1), Wf("cn1", t, e, Gf, -1, 0, -1), Wf("cn2", t, e, Gf, 1, 0, -1), Wf("cn3", t, e, Gf, 0, -1, -1), Wf("cn4", t, e, Gf, 0, 1, -1), e.getAttribute("position").needsUpdate = !0
        };
        var qf = new Uo;

        function $f(e, t) {
            this.object = e, void 0 === t && (t = 16776960);
            var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                i = new Float32Array(24),
                r = new Wa;
            r.setIndex(new Ea(n, 1)), r.setAttribute("position", new Ea(i, 3)), Mu.call(this, r, new fu({
                color: t,
                toneMapped: !1
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function Xf(e, t) {
            this.type = "Box3Helper", this.box = e, t = t || 16776960;
            var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                i = new Wa;
            i.setIndex(new Ea(n, 1)), i.setAttribute("position", new ka([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Mu.call(this, i, new fu({
                color: t,
                toneMapped: !1
            })), this.geometry.computeBoundingSphere()
        }

        function Yf(e, t, n) {
            this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t;
            var i = void 0 !== n ? n : 16776960,
                r = new Wa;
            r.setAttribute("position", new ka([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), wu.call(this, r, new fu({
                color: i,
                toneMapped: !1
            }));
            var o = new Wa;
            o.setAttribute("position", new ka([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new cs(o, new Ta({
                color: i,
                opacity: .2,
                transparent: !0,
                depthWrite: !1,
                toneMapped: !1
            })))
        }
        $f.prototype = Object.create(Mu.prototype), $f.prototype.constructor = $f, $f.prototype.update = function (e) {
            if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && qf.setFromObject(this.object), !qf.isEmpty()) {
                var t = qf.min,
                    n = qf.max,
                    i = this.geometry.attributes.position,
                    r = i.array;
                r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = t.x, r[4] = n.y, r[5] = n.z, r[6] = t.x, r[7] = t.y, r[8] = n.z, r[9] = n.x, r[10] = t.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = t.z, r[15] = t.x, r[16] = n.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = n.x, r[22] = t.y, r[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
            }
        }, $f.prototype.setFromObject = function (e) {
            return this.object = e, this.update(), this
        }, $f.prototype.copy = function (e) {
            return Mu.prototype.copy.call(this, e), this.object = e.object, this
        }, $f.prototype.clone = function () {
            return (new this.constructor).copy(this)
        }, Xf.prototype = Object.create(Mu.prototype), Xf.prototype.constructor = Xf, Xf.prototype.updateMatrixWorld = function (e) {
            var t = this.box;
            t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), Eo.prototype.updateMatrixWorld.call(this, e))
        }, Yf.prototype = Object.create(wu.prototype), Yf.prototype.constructor = Yf, Yf.prototype.updateMatrixWorld = function (e) {
            var t = -this.plane.constant;
            Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? 1 : 0, this.lookAt(this.plane.normal), Eo.prototype.updateMatrixWorld.call(this, e)
        };
        var Zf, Jf, Qf = new Kr;

        function Kf(e, t, n, i, r, o) {
            Eo.call(this), void 0 === e && (e = new Kr(0, 0, 1)), void 0 === t && (t = new Kr(0, 0, 0)), void 0 === n && (n = 1), void 0 === i && (i = 16776960), void 0 === r && (r = .2 * n), void 0 === o && (o = .2 * r), void 0 === Zf && ((Zf = new Wa).setAttribute("position", new ka([0, 0, 0, 0, 1, 0], 3)), (Jf = new Gh(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new wu(Zf, new fu({
                color: i,
                toneMapped: !1
            })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new cs(Jf, new Ta({
                color: i,
                toneMapped: !1
            })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, r, o)
        }

        function em(e) {
            var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                n = new Wa;
            n.setAttribute("position", new ka(t, 3)), n.setAttribute("color", new ka([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
            var i = new fu({
                vertexColors: !0,
                toneMapped: !1
            });
            Mu.call(this, n, i)
        }
        Kf.prototype = Object.create(Eo.prototype), Kf.prototype.constructor = Kf, Kf.prototype.setDirection = function (e) {
            if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
            else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
            else {
                Qf.set(e.z, 0, -e.x).normalize();
                var t = Math.acos(e.y);
                this.quaternion.setFromAxisAngle(Qf, t)
            }
        }, Kf.prototype.setLength = function (e, t, n) {
            void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
        }, Kf.prototype.setColor = function (e) {
            this.line.material.color.set(e), this.cone.material.color.set(e)
        }, Kf.prototype.copy = function (e) {
            return Eo.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
        }, Kf.prototype.clone = function () {
            return (new this.constructor).copy(this)
        }, em.prototype = Object.create(Mu.prototype), em.prototype.constructor = em;
        var tm, nm, im, rm, om = Math.pow(2, 8),
            am = [.125, .215, .35, .446, .526, .582],
            sm = 5 + am.length,
            lm = 20,
            cm = {
                [Rr]: 0,
                [Or]: 1,
                [Dr]: 2,
                3004: 3,
                3005: 4,
                3006: 5,
                3007: 6
            },
            um = new cp,
            hm = (tm = lm, nm = new Float32Array(tm), im = new Kr(0, 1, 0), (rm = new Zh({
                defines: {
                    n: tm
                },
                uniforms: {
                    envMap: {
                        value: null
                    },
                    samples: {
                        value: 1
                    },
                    weights: {
                        value: nm
                    },
                    latitudinal: {
                        value: !1
                    },
                    dTheta: {
                        value: 0
                    },
                    mipInt: {
                        value: 0
                    },
                    poleAxis: {
                        value: im
                    },
                    inputEncoding: {
                        value: cm[3e3]
                    },
                    outputEncoding: {
                        value: cm[3e3]
                    }
                },
                vertexShader: km(),
                fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n${Nm()}\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })).type = "SphericalGaussianBlur", rm),
            dm = null,
            pm = null,
            {
                _lodPlanes: fm,
                _sizeLods: mm,
                _sigmas: gm
            } = function () {
                for (var e = [], t = [], n = [], i = 8, r = 0; r < sm; r++) {
                    var o = Math.pow(2, i);
                    t.push(o);
                    var a = 1 / o;
                    r > 4 ? a = am[r - 8 + 4 - 1] : 0 == r && (a = 0), n.push(a);
                    for (var s = 1 / (o - 1), l = -s / 2, c = 1 + s / 2, u = [l, l, c, l, c, c, l, l, c, c, l, c], h = new Float32Array(108), d = new Float32Array(72), p = new Float32Array(36), f = 0; f < 6; f++) {
                        var m = f % 3 * 2 / 3 - 1,
                            g = f > 2 ? 0 : -1,
                            v = [m, g, 0, m + 2 / 3, g, 0, m + 2 / 3, g + 1, 0, m, g, 0, m + 2 / 3, g + 1, 0, m, g + 1, 0];
                        h.set(v, 18 * f), d.set(u, 12 * f);
                        var y = [f, f, f, f, f, f];
                        p.set(y, 6 * f)
                    }
                    var x = new Wa;
                    x.setAttribute("position", new Ea(h, 3)), x.setAttribute("uv", new Ea(d, 2)), x.setAttribute("faceIndex", new Ea(p, 1)), e.push(x), i > 4 && i--
                }
                return {
                    _lodPlanes: e,
                    _sizeLods: t,
                    _sigmas: n
                }
            }(),
            vm = null,
            ym = null,
            xm = null,
            wm = (1 + Math.sqrt(5)) / 2,
            bm = 1 / wm,
            _m = [new Kr(1, 1, 1), new Kr(-1, 1, 1), new Kr(1, 1, -1), new Kr(-1, 1, -1), new Kr(0, wm, bm), new Kr(0, wm, -bm), new Kr(bm, 0, wm), new Kr(-bm, 0, wm), new Kr(wm, bm, 0), new Kr(-wm, bm, 0)];

        function Mm(e) {
            ym = e, Em(hm)
        }

        function Tm(e) {
            var t = {
                magFilter: ur,
                minFilter: ur,
                generateMipmaps: !1,
                type: e ? e.type : mr,
                format: e ? e.format : 1023,
                encoding: e ? e.encoding : Dr,
                depthBuffer: !1,
                stencilBuffer: !1
            },
                n = Am(t);
            return n.depthBuffer = !e, vm = Am(t), n
        }

        function Sm(e) {
            vm.dispose(), ym.setRenderTarget(xm), e.scissorTest = !1, e.setSize(e.width, e.height)
        }

        function Em(e) {
            var t = new Ao;
            t.add(new cs(fm[0], e)), ym.compile(t, um)
        }

        function Am(e) {
            var t = new Xr(3 * om, 3 * om, e);
            return t.texture.mapping = ar, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t
        }

        function Cm(e, t, n, i, r) {
            e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r)
        }

        function Lm(e) {
            var t = ym.autoClear;
            ym.autoClear = !1;
            for (var n = 1; n < sm; n++) {
                Pm(e, n - 1, n, Math.sqrt(gm[n] * gm[n] - gm[n - 1] * gm[n - 1]), _m[(n - 1) % _m.length])
            }
            ym.autoClear = t
        }

        function Pm(e, t, n, i, r) {
            Rm(e, vm, t, n, i, "latitudinal", r), Rm(vm, e, n, n, i, "longitudinal", r)
        }

        function Rm(e, t, n, i, r, o, a) {
            "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
            var s = new Ao;
            s.add(new cs(fm[i], hm));
            var l = hm.uniforms,
                c = mm[n] - 1,
                u = isFinite(r) ? Math.PI / (2 * c) : 2 * Math.PI / 39,
                h = r / u,
                d = isFinite(r) ? 1 + Math.floor(3 * h) : lm;
            d > lm && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${d} samples when the maximum is set to 20`);
            for (var p = [], f = 0, m = 0; m < lm; ++m) {
                var g = m / h,
                    v = Math.exp(-g * g / 2);
                p.push(v), 0 == m ? f += v : m < d && (f += 2 * v)
            }
            for (m = 0; m < p.length; m++) p[m] = p[m] / f;
            l.envMap.value = e.texture, l.samples.value = d, l.weights.value = p, l.latitudinal.value = "latitudinal" === o, a && (l.poleAxis.value = a), l.dTheta.value = u, l.mipInt.value = 8 - n, l.inputEncoding.value = cm[e.texture.encoding], l.outputEncoding.value = cm[e.texture.encoding];
            var y = mm[i];
            Cm(t, g = 3 * Math.max(0, om - 2 * y), (0 === i ? 0 : 2 * om) + 2 * y * (i > 4 ? i - 8 + 4 : 0), 3 * y, 2 * y), ym.setRenderTarget(t), ym.render(s, um)
        }

        function Om() {
            var e = new Zh({
                uniforms: {
                    envMap: {
                        value: null
                    },
                    texelSize: {
                        value: new jr(1, 1)
                    },
                    inputEncoding: {
                        value: cm[3e3]
                    },
                    outputEncoding: {
                        value: cm[3e3]
                    }
                },
                vertexShader: km(),
                fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n${Nm()}\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv;\n\tuv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n\tuv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            });
            return e.type = "EquirectangularToCubeUV", e
        }

        function Dm() {
            var e = new Zh({
                uniforms: {
                    envMap: {
                        value: null
                    },
                    inputEncoding: {
                        value: cm[3e3]
                    },
                    outputEncoding: {
                        value: cm[3e3]
                    }
                },
                vertexShader: km(),
                fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n${Nm()}\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            });
            return e.type = "CubemapToCubeUV", e
        }

        function km() {
            return "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t"
        }

        function Nm() {
            return "\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t"
        }
        Mm.prototype = {
            constructor: Mm,
            fromScene: function (e, t = 0, n = .1, i = 100) {
                xm = ym.getRenderTarget();
                var r = Tm();
                return function (e, t, n, i) {
                    var r = new Ms(90, 1, t, n),
                        o = [1, 1, 1, 1, -1, 1],
                        a = [1, 1, -1, -1, -1, 1],
                        s = ym.outputEncoding,
                        l = ym.toneMapping,
                        c = ym.toneMappingExposure,
                        u = ym.getClearColor(),
                        h = ym.getClearAlpha();
                    ym.toneMapping = 1, ym.toneMappingExposure = 1, ym.outputEncoding = Rr, e.scale.z *= -1;
                    var d = e.background;
                    if (d && d.isColor) {
                        d.convertSRGBToLinear();
                        var p = Math.max(d.r, d.g, d.b),
                            f = Math.min(Math.max(Math.ceil(Math.log2(p)), -128), 127);
                        d = d.multiplyScalar(Math.pow(2, -f));
                        var m = (f + 128) / 255;
                        ym.setClearColor(d, m), e.background = null
                    }
                    for (var g = 0; g < 6; g++) {
                        var v = g % 3;
                        0 == v ? (r.up.set(0, o[g], 0), r.lookAt(a[g], 0, 0)) : 1 == v ? (r.up.set(0, 0, o[g]), r.lookAt(0, a[g], 0)) : (r.up.set(0, o[g], 0), r.lookAt(0, 0, a[g])), Cm(i, v * om, g > 2 ? om : 0, om, om), ym.setRenderTarget(i), ym.render(e, r)
                    }
                    ym.toneMapping = l, ym.toneMappingExposure = c, ym.outputEncoding = s, ym.setClearColor(u, h), e.scale.z *= -1
                }(e, n, i, r), t > 0 && Pm(r, 0, 0, t), Lm(r), Sm(r), r
            },
            fromEquirectangular: function (e) {
                return e.magFilter = ur, e.minFilter = ur, e.generateMipmaps = !1, this.fromCubemap(e)
            },
            fromCubemap: function (e) {
                xm = ym.getRenderTarget();
                var t = Tm(e);
                return function (e, t) {
                    var n = new Ao;
                    e.isCubeTexture ? null == pm && (pm = Dm()) : null == dm && (dm = Om());
                    var i = e.isCubeTexture ? pm : dm;
                    n.add(new cs(fm[0], i));
                    var r = i.uniforms;
                    r.envMap.value = e, e.isCubeTexture || r.texelSize.value.set(1 / e.image.width, 1 / e.image.height);
                    r.inputEncoding.value = cm[e.encoding], r.outputEncoding.value = cm[e.encoding], Cm(t, 0, 0, 3 * om, 2 * om), ym.setRenderTarget(t), ym.render(n, um)
                }(e, t), Lm(t), Sm(t), t
            },
            compileCubemapShader: function () {
                null == pm && Em(pm = Dm())
            },
            compileEquirectangularShader: function () {
                null == dm && Em(dm = Om())
            },
            dispose: function () {
                hm.dispose(), null != pm && pm.dispose(), null != dm && dm.dispose();
                for (var e = 0; e < fm.length; e++) fm[e].dispose()
            }
        };

        function Im(e) {
            console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Ud.call(this, e), this.type = "catmullrom"
        }
        Dd.create = function (e, t) {
            return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Dd.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
        }, Object.assign(Kd.prototype, {
            createPointsGeometry: function (e) {
                console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                var t = this.getPoints(e);
                return this.createGeometry(t)
            },
            createSpacedPointsGeometry: function (e) {
                console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                var t = this.getSpacedPoints(e);
                return this.createGeometry(t)
            },
            createGeometry: function (e) {
                console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                for (var t = new gs, n = 0, i = e.length; n < i; n++) {
                    var r = e[n];
                    t.vertices.push(new Kr(r.x, r.y, r.z || 0))
                }
                return t
            }
        }), Object.assign(ep.prototype, {
            fromPoints: function (e) {
                return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
            }
        }), Object.create(Ud.prototype), Object.create(Ud.prototype), Im.prototype = Object.create(Ud.prototype), Object.assign(Im.prototype, {
            initFromArray: function () {
                console.error("THREE.Spline: .initFromArray() has been removed.")
            },
            getControlPointsArray: function () {
                console.error("THREE.Spline: .getControlPointsArray() has been removed.")
            },
            reparametrizeByArcLength: function () {
                console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
            }
        }), If.prototype.setColors = function () {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, Pf.prototype.update = function () {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }, Object.assign(Td.prototype, {
            extractUrlBase: function (e) {
                return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), mp(e)
            }
        }), Td.Handlers = {
            add: function () {
                console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
            },
            get: function () {
                console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
            }
        }, Object.assign(wp.prototype, {
            setTexturePath: function (e) {
                return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
            }
        }), Object.assign(xf.prototype, {
            center: function (e) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
            },
            empty: function () {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            },
            isIntersectionBox: function (e) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
            },
            size: function (e) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
            }
        }), Object.assign(Uo.prototype, {
            center: function (e) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
            },
            empty: function () {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            },
            isIntersectionBox: function (e) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
            },
            isIntersectionSphere: function (e) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
            },
            size: function (e) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
            }
        }), Ps.prototype.setFromMatrix = function (e) {
            return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e)
        }, _f.prototype.center = function (e) {
            return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
        }, Object.assign(Ur, {
            random16: function () {
                return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
            },
            nearestPowerOfTwo: function (e) {
                return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Ur.floorPowerOfTwo(e)
            },
            nextPowerOfTwo: function (e) {
                return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Ur.ceilPowerOfTwo(e)
            }
        }), Object.assign(Gr.prototype, {
            flattenToArrayOffset: function (e, t) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
            },
            multiplyVector3: function (e) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
            },
            multiplyVector3Array: function () {
                console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
            },
            applyToBufferAttribute: function (e) {
                return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
            },
            applyToVector3Array: function () {
                console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
            }
        }), Object.assign(so.prototype, {
            extractPosition: function (e) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
            },
            flattenToArrayOffset: function (e, t) {
                return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
            },
            getPosition: function () {
                return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Kr).setFromMatrixColumn(this, 3)
            },
            setRotationFromQuaternion: function (e) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
            },
            multiplyToArray: function () {
                console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
            },
            multiplyVector3: function (e) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            },
            multiplyVector4: function (e) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            },
            multiplyVector3Array: function () {
                console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
            },
            rotateAxis: function (e) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
            },
            crossVector: function (e) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            },
            translate: function () {
                console.error("THREE.Matrix4: .translate() has been removed.")
            },
            rotateX: function () {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            },
            rotateY: function () {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            },
            rotateZ: function () {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            },
            rotateByAxis: function () {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            },
            applyToBufferAttribute: function (e) {
                return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            },
            applyToVector3Array: function () {
                console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
            },
            makeFrustum: function (e, t, n, i, r, o) {
                return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, i, n, r, o)
            }
        }), na.prototype.isIntersectionLine = function (e) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
        }, Zr.prototype.multiplyVector3 = function (e) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
        }, Object.assign(Qo.prototype, {
            isIntersectionBox: function (e) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
            },
            isIntersectionPlane: function (e) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
            },
            isIntersectionSphere: function (e) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
            }
        }), Object.assign(pa.prototype, {
            area: function () {
                return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
            },
            barycoordFromPoint: function (e, t) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
            },
            midpoint: function (e) {
                return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
            },
            normal: function (e) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
            },
            plane: function (e) {
                return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
            }
        }), Object.assign(pa, {
            barycoordFromPoint: function (e, t, n, i, r) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), pa.getBarycoord(e, t, n, i, r)
            },
            normal: function (e, t, n, i) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), pa.getNormal(e, t, n, i)
            }
        }), Object.assign(tp.prototype, {
            extractAllPoints: function (e) {
                return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
            },
            extrude: function (e) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Eh(this, e)
            },
            makeGeometry: function (e) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Fh(this, e)
            }
        }), Object.assign(jr.prototype, {
            fromAttribute: function (e, t, n) {
                return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
            },
            distanceToManhattan: function (e) {
                return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
            },
            lengthManhattan: function () {
                return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), Object.assign(Kr.prototype, {
            setEulerFromRotationMatrix: function () {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            },
            setEulerFromQuaternion: function () {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            },
            getPositionFromMatrix: function (e) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
            },
            getScaleFromMatrix: function (e) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
            },
            getColumnFromMatrix: function (e, t) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
            },
            applyProjection: function (e) {
                return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
            },
            fromAttribute: function (e, t, n) {
                return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
            },
            distanceToManhattan: function (e) {
                return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
            },
            lengthManhattan: function () {
                return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), Object.assign($r.prototype, {
            fromAttribute: function (e, t, n) {
                return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
            },
            lengthManhattan: function () {
                return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), Object.assign(gs.prototype, {
            computeTangents: function () {
                console.error("THREE.Geometry: .computeTangents() has been removed.")
            },
            computeLineDistances: function () {
                console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
            },
            applyMatrix: function (e) {
                return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
            }
        }), Object.assign(Eo.prototype, {
            getChildByName: function (e) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
            },
            renderDepth: function () {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            },
            translate: function (e, t) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
            },
            getWorldRotation: function () {
                console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
            },
            applyMatrix: function (e) {
                return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
            }
        }), Object.defineProperties(Eo.prototype, {
            eulerOrder: {
                get: function () {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                },
                set: function (e) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
                }
            },
            useQuaternion: {
                get: function () {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function () {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }), Object.assign(cs.prototype, {
            setDrawMode: function () {
                console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }
        }), Object.defineProperties(cs.prototype, {
            drawMode: {
                get: function () {
                    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                },
                set: function () {
                    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }
            }
        }), Object.defineProperties(iu.prototype, {
            objects: {
                get: function () {
                    return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                }
            }
        }), Object.defineProperty(su.prototype, "useVertexTexture", {
            get: function () {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            },
            set: function () {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            }
        }), ru.prototype.initBones = function () {
            console.error("THREE.SkinnedMesh: initBones() has been removed.")
        }, Object.defineProperty(Dd.prototype, "__arcLengthDivisions", {
            get: function () {
                return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
            },
            set: function (e) {
                console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
            }
        }), Ms.prototype.setLens = function (e, t) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
        }, Object.defineProperties(np.prototype, {
            onlyShadow: {
                set: function () {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
                }
            },
            shadowCameraLeft: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
                }
            },
            shadowCameraRight: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
                }
            },
            shadowCameraTop: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
                }
            },
            shadowCameraBottom: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
                }
            },
            shadowCameraNear: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
                }
            },
            shadowCameraFar: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
                }
            },
            shadowCameraVisible: {
                set: function () {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
                }
            },
            shadowDarkness: {
                set: function () {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
                }
            },
            shadowMapHeight: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
                }
            }
        }), Object.defineProperties(Ea.prototype, {
            length: {
                get: function () {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                }
            },
            dynamic: {
                get: function () {
                    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Ir
                },
                set: function () {
                    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Ir)
                }
            }
        }), Object.assign(Ea.prototype, {
            setDynamic: function (e) {
                return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? Ir : Nr), this
            },
            copyIndicesArray: function () {
                console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
            },
            setArray: function () {
                console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }
        }), Object.assign(Wa.prototype, {
            addIndex: function (e) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
            },
            addAttribute: function (e, t) {
                return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new Ea(arguments[1], arguments[2])))
            },
            addDrawCall: function (e, t, n) {
                void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
            },
            clearDrawCalls: function () {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            },
            computeTangents: function () {
                console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
            },
            computeOffsets: function () {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            },
            removeAttribute: function (e) {
                return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e)
            },
            applyMatrix: function (e) {
                return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
            }
        }), Object.defineProperties(Wa.prototype, {
            drawcalls: {
                get: function () {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            },
            offsets: {
                get: function () {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                }
            }
        }), Object.defineProperties(mf.prototype, {
            linePrecision: {
                get: function () {
                    return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold
                },
                set: function (e) {
                    console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = e
                }
            }
        }), Object.defineProperties(Ic.prototype, {
            dynamic: {
                get: function () {
                    return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === Ir
                },
                set: function (e) {
                    console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(e)
                }
            }
        }), Object.assign(Ic.prototype, {
            setDynamic: function (e) {
                return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? Ir : Nr), this
            },
            setArray: function () {
                console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }
        }), Object.assign(Ah.prototype, {
            getArrays: function () {
                console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
            },
            addShapeList: function () {
                console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
            },
            addShape: function () {
                console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
            }
        }), Object.defineProperties(pf.prototype, {
            dynamic: {
                set: function () {
                    console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                }
            },
            onUpdate: {
                value: function () {
                    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                }
            }
        }), Object.defineProperties(Ma.prototype, {
            wrapAround: {
                get: function () {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                },
                set: function () {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            },
            overdraw: {
                get: function () {
                    console.warn("THREE.Material: .overdraw has been removed.")
                },
                set: function () {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }
            },
            wrapRGB: {
                get: function () {
                    return console.warn("THREE.Material: .wrapRGB has been removed."), new va
                }
            },
            shading: {
                get: function () {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                },
                set: function (e) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
                }
            },
            stencilMask: {
                get: function () {
                    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                },
                set: function (e) {
                    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e
                }
            }
        }), Object.defineProperties(Kh.prototype, {
            metal: {
                get: function () {
                    return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                },
                set: function () {
                    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                }
            }
        }), Object.defineProperties(bs.prototype, {
            derivatives: {
                get: function () {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                },
                set: function (e) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
                }
            }
        }), Object.assign(Dc.prototype, {
            clearTarget: function (e, t, n, i) {
                console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, i)
            },
            animate: function (e) {
                console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
            },
            getCurrentRenderTarget: function () {
                return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
            },
            getMaxAnisotropy: function () {
                return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
            },
            getPrecision: function () {
                return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
            },
            resetGLState: function () {
                return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
            },
            supportsFloatTextures: function () {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            },
            supportsHalfFloatTextures: function () {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            },
            supportsStandardDerivatives: function () {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            },
            supportsCompressedTextureS3TC: function () {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            },
            supportsCompressedTexturePVRTC: function () {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            },
            supportsBlendMinMax: function () {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            },
            supportsVertexTextures: function () {
                return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
            },
            supportsInstancedArrays: function () {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            },
            enableScissorTest: function (e) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
            },
            initMaterial: function () {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            },
            addPrePlugin: function () {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            },
            addPostPlugin: function () {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            },
            updateShadowMap: function () {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            },
            setFaceCulling: function () {
                console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
            },
            allocTextureUnit: function () {
                console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
            },
            setTexture: function () {
                console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
            },
            setTexture2D: function () {
                console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
            },
            setTextureCube: function () {
                console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
            },
            getActiveMipMapLevel: function () {
                return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
            }
        }), Object.defineProperties(Dc.prototype, {
            shadowMapEnabled: {
                get: function () {
                    return this.shadowMap.enabled
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
                }
            },
            shadowMapType: {
                get: function () {
                    return this.shadowMap.type
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
                }
            },
            shadowMapCullFace: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            context: {
                get: function () {
                    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                }
            },
            vr: {
                get: function () {
                    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                }
            },
            gammaInput: {
                get: function () {
                    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                },
                set: function () {
                    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                }
            },
            gammaOutput: {
                get: function () {
                    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? Or : Rr
                }
            }
        }), Object.defineProperties(Ec.prototype, {
            cullFace: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            renderReverseSided: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                },
                set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }
            },
            renderSingleSided: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                },
                set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }
            }
        }), Object.defineProperties(Xr.prototype, {
            wrapS: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
                }
            },
            wrapT: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
                }
            },
            magFilter: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
                }
            },
            minFilter: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
                }
            },
            anisotropy: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
                }
            },
            offset: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
                }
            },
            repeat: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
                }
            },
            format: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
                }
            },
            type: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
                }
            },
            generateMipmaps: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
                }
            }
        }), Object.defineProperties(Vp.prototype, {
            load: {
                value: function (e) {
                    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                    var t = this;
                    return (new Rp).load(e, (function (e) {
                        t.setBuffer(e)
                    })), this
                }
            },
            startTime: {
                set: function () {
                    console.warn("THREE.Audio: .startTime is now .play( delay ).")
                }
            }
        }), Zp.prototype.getData = function () {
            return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
        }, Ss.prototype.updateCubeMap = function (e, t) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
        };
        Vr.crossOrigin = void 0, Vr.loadTexture = function (e, t, n, i) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            var r = new Od;
            r.setCrossOrigin(this.crossOrigin);
            var o = r.load(e, n, void 0, i);
            return t && (o.mapping = t), o
        }, Vr.loadTextureCube = function (e, t, n, i) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            var r = new Rd;
            r.setCrossOrigin(this.crossOrigin);
            var o = r.load(e, n, void 0, i);
            return t && (o.mapping = t), o
        }, Vr.loadCompressedTexture = function () {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        }, Vr.loadCompressedTextureCube = function () {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        };
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: "115"
            }
        }));
        var zm, Fm = function (e) {
            var t = e.index,
                n = e.attributes;
            if (null !== t && void 0 !== n.position && void 0 !== n.normal && void 0 !== n.uv) {
                var i = t.array,
                    r = n.position.array,
                    o = n.normal.array,
                    a = n.uv.array,
                    s = r.length / 3;
                void 0 === n.tangent && e.setAttribute("tangent", new Ea(new Float32Array(4 * s), 4));
                for (var l = n.tangent.array, c = [], u = [], h = 0; h < s; h++) c[h] = new Kr, u[h] = new Kr;
                var d = new Kr,
                    p = new Kr,
                    f = new Kr,
                    m = new jr,
                    g = new jr,
                    v = new jr,
                    y = new Kr,
                    x = new Kr,
                    w = e.groups;
                0 === w.length && (w = [{
                    start: 0,
                    count: i.length
                }]);
                h = 0;
                for (var b = w.length; h < b; ++h)
                    for (var _ = O = (R = w[h]).start, M = O + R.count; _ < M; _ += 3) D(i[_ + 0], i[_ + 1], i[_ + 2]);
                var T, S, E, A = new Kr,
                    C = new Kr,
                    L = new Kr,
                    P = new Kr;
                for (h = 0, b = w.length; h < b; ++h) {
                    var R, O;
                    for (_ = O = (R = w[h]).start, M = O + R.count; _ < M; _ += 3) k(i[_ + 0]), k(i[_ + 1]), k(i[_ + 2])
                }
            } else console.warn("THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");

            function D(e, t, n) {
                d.fromArray(r, 3 * e), p.fromArray(r, 3 * t), f.fromArray(r, 3 * n), m.fromArray(a, 2 * e), g.fromArray(a, 2 * t), v.fromArray(a, 2 * n), p.sub(d), f.sub(d), g.sub(m), v.sub(m);
                var i = 1 / (g.x * v.y - v.x * g.y);
                isFinite(i) && (y.copy(p).multiplyScalar(v.y).addScaledVector(f, -g.y).multiplyScalar(i), x.copy(f).multiplyScalar(g.x).addScaledVector(p, -v.x).multiplyScalar(i), c[e].add(y), c[t].add(y), c[n].add(y), u[e].add(x), u[t].add(x), u[n].add(x))
            }

            function k(e) {
                L.fromArray(o, 3 * e), P.copy(L), S = c[e], A.copy(S), A.sub(L.multiplyScalar(L.dot(S))).normalize(), C.crossVectors(P, S), E = C.dot(u[e]), T = E < 0 ? -1 : 1, l[4 * e] = A.x, l[4 * e + 1] = A.y, l[4 * e + 2] = A.z, l[4 * e + 3] = T
            }
        },
            Hm = new Dc({
                alpha: !0,
                antialias: !0
            }),
            Bm = new Fp(!0),
            Um = null,
            jm = window.innerWidth,
            Gm = window.innerHeight,
            Vm = new Ms(45, jm / Gm, 1, 1e3),
            Wm = null,
            qm = null,
            $m = null,
            Xm = null,
            Ym = r()("#canvas").data("people"),
            Zm = "uniform vec3 lightDirection;\n\n                            varying vec2 vUv;\n                            varying vec3 vEyeDirectionEyeSpace;\n                            varying vec3 vLightDirection;\n                            attribute vec4 tangent;\n\n                            // all in eye space\n                            varying mat3 tbn;\n\n                            void main(){\n\n                              vUv = uv;\n                              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n                              vLightDirection = mat3(viewMatrix) * lightDirection; // should be computed outside of shader\n                              vEyeDirectionEyeSpace = mat3(viewMatrix) * normalize(position - cameraPosition).xyz;\n\n                              // normal mapping\n                              vec3 t = normalize(tangent.xyz);\n                              vec3 n = normalize(normal.xyz);\n                              vec3 b = normalize(cross(t, n));\n\n                              // everything in eye space\n                              t = normalize(normalMatrix * t);\n                              b = normalize(normalMatrix * b);\n                              n = normalize(normalMatrix * n);\n\n                              tbn = mat3(t, b, n);\n\n                                }",
            Jm = " uniform sampler2D diffuseTexture;\n                            uniform sampler2D diffuseNight;\n                            uniform sampler2D specularMap;\n                            uniform sampler2D cloudsMap;\n                            uniform sampler2D normalMap;\n\n                            varying vec2 vUv;\n                            varying vec3 vEyeDirectionEyeSpace;\n                            varying vec3 vLightDirection;\n\n                            // tangent-bitangent-normal matrix\n                            varying mat3 tbn;\n\n                            void main(){\n\n                              vec3 lightDir = normalize(vLightDirection);\n\n                              vec3 n        = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;\n                              vec3 normal   = normalize(tbn * n);\n\n\n                              // directional light\n                              float lightIntensity  = dot(normal, lightDir);\n                              float selectImage     = dot(tbn[2], lightDir);\n\n                              gl_FragColor = texture2D(diffuseTexture, vUv) * selectImage + texture2D(diffuseNight, vUv) * (1.0-selectImage);\n\n                              //gl_FragColor = vec4(vec3(0.5), 1.0 );\n                              gl_FragColor *= (1.0 + 10.0*(lightIntensity - selectImage));\n\n                              // specular\n                              vec3 reflection = reflect(lightDir, normal);\n                              float specPower = texture2D(specularMap, vUv).r;\n\n                              float spec  = 10.2;\n                              float gloss = 0.1 * texture2D(specularMap, vUv).a;\n\n                              float specular  =  pow(clamp(dot(reflection, normalize(vEyeDirectionEyeSpace)), 0.0, 1.0), spec) * gloss;\n                              gl_FragColor    = gl_FragColor + specular * vec4(0.26, 0.96, 0.99, 1);\n\n                              // cloud colors + a small bump\n                              vec4 cloudsColor = texture2D(cloudsMap, vUv) * vec4(1.0, 1.5, 1.2, 1.0);\n\n                              vec4 cloudsShadow = texture2D(cloudsMap, vec2(vUv.x+ normal.x * 0.005, vUv.y + normal.y * 0.005));\n\n                              if (cloudsColor.r < 0.1 && cloudsShadow.r > 0.1){\n                                gl_FragColor *= 0.75;\n                                cloudsShadow = vec4(0);\n                              }\n\n                              gl_FragColor = gl_FragColor * (vec4(1.2) - cloudsColor) + cloudsColor * (lightIntensity * 2.0);\n\n                                }";
        const Qm = "uniform vec3 earthCenter;\n                                uniform float earthRadius;\n                                uniform float atmosphereRadius;\n                                uniform vec3 lightDirection;\n\n                                varying float atmosphereThickness;\n                                varying vec3 vLightDirection;\n                                varying vec3 vNormalEyeSpace;\n\n\n                                void main(){\n                                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n                                  vec3 positionW = (modelMatrix * vec4(position, 1.0)).xyz;\n\n                                  vec3 vCameraEarth   = cameraPosition.xyz - earthCenter;\n                                  vec3 vCameraVertex  = normalize(cameraPosition.xyz - positionW);\n\n                                  float tca = dot(vCameraEarth,  vCameraVertex);\n\n                                  if (tca < 0.0){\n                                    // not intesect, looking in opposite direction\n                                    atmosphereThickness = 0.0;\n                                    return;\n                                  }\n\n                                  float dsq = dot(vCameraEarth, vCameraEarth) - tca * tca;\n                                  float thc_sq_atmosphere = max(atmosphereRadius * atmosphereRadius - dsq, 0.0);\n                                  float thc_sq_earth = max(earthRadius * earthRadius - dsq, 0.0);\n\n                                  float thc_atmosphere = 2.0 * sqrt(thc_sq_atmosphere);\n                                  float thc_earth = 2.0 * sqrt(max(0.0,thc_sq_earth));\n\n                                  float thc           = (thc_atmosphere - thc_earth) * 0.09; // 0.01 - density factor\n                                  atmosphereThickness = thc;\n\n                                  // light calculation\n                                  vLightDirection = mat3(viewMatrix) * lightDirection;\n                                  vNormalEyeSpace = normalize(normalMatrix * normal);\n\n                                }",
            Km = " varying float atmosphereThickness;\n                                varying vec3 vLightDirection;\n                                varying vec3 vNormalEyeSpace;\n\n                                void main(){\n\n                                  vec3 lightDir = normalize(vLightDirection);\n                                  vec3 normal = normalize(vNormalEyeSpace);\n                                  float lightIntensity = max(dot(normal, lightDir) * 1.5, -0.7);\n                                  gl_FragColor = vec4( (vec3(57.0, 97.0, 162.0) / 256.0) * (1.0 + lightIntensity), atmosphereThickness);\n\n                                }";
        async function eg() {
            Hm.setSize(jm, Gm), Hm.autoClear = !1, document.getElementById("canvas").appendChild(Hm.domElement), (Um = await async function (e) {
                let t = new wp;
                return new Promise(((n, i) => t.load(e, n, null, i)))
            }("./wp-content/themes/kcg/assets/img/earth_and_water.json")).fog = new Nc(0, 1500, 2100);
            const e = new Od;
            zm = new Rc;
            for (let i = 0; i < Ym.length; i++) {
                const r = Math.random() - .5,
                    o = (t = -.15, n = .15, Math.floor(Math.random() * (n - t + 1)) + t),
                    a = Math.random() - .5;
                let s;
                "south-america" == Ym[0].place || "north-america" == Ym[0].place || "europe" == Ym[0].place || "asia" == Ym[0].place || "africa" == Ym[0].place || Ym[0].place, s = new Bc({
                    map: e.load(Ym[i].thumb),
                    color: 16777215,
                    fog: !0
                });
                const l = new Kc(s);
                l.position.set(r, o, a), l.position.normalize(), l.position.multiplyScalar(12.2), zm.add(l)
            }
            var t, n;
            Um.add(zm), Vm.position.set(5, 0, 44), Wm = Um.getObjectByName("Earth"), Xm = Um.getObjectByName("Atmosphere"), Wm.receiveShadow = !0, Wm.castShadow = !0, Vm.lookAt(Wm.position), async function () {
                $m = {
                    earthCenter: new pf(Wm.position),
                    earthRadius: new pf(10),
                    atmosphereRadius: new pf(10.4)
                }, qm = {
                    diffuseTexture: {
                        type: "t",
                        value: await ig("./wp-content/themes/kcg/assets/img/earth/earth_diffuse.jpg")
                    },
                    diffuseNight: {
                        type: "t",
                        value: await ig("./wp-content/themes/kcg/assets/img/earth/earth_diffuse_night.jpg")
                    },
                    normalMap: {
                        type: "t",
                        value: await ig("./wp-content/themes/kcg/assets/img/earth/earth_normal_map.jpg")
                    },
                    specularMap: {
                        type: "t",
                        value: await ig("./wp-content/themes/kcg/assets/img/earth/earth_specular_map.png")
                    },
                    cloudsMap: {
                        type: "t",
                        value: await ig("./wp-content/themes/kcg/assets/img/earth/earth_diffuse_clouds.jpg")
                    }
                }, tg(0), Fm(Wm.geometry), Wm.material = new bs({
                    uniforms: qm,
                    vertexShader: Zm,
                    fragmentShader: Jm,
                    side: 0
                }), Xm.material = new bs({
                    uniforms: $m,
                    vertexShader: Qm,
                    fragmentShader: Km,
                    blending: 5,
                    blendEquation: ir,
                    blendSrc: rr,
                    blendDst: or,
                    side: 0,
                    transparent: !0
                })
            }().then((() => {
                Hm.autoClear = !1, ng()
            }))
        }

        function tg(e) {
            let t = new Kr(-10, 10, -3),
                n = new pf(new Kr((i = t).x, i.y, i.z));
            var i;
            qm.lightDirection = n, Wm.rotation.y += .05 * e, $m.lightDirection = n, Xm.rotation.y += .05 * e;
            for (let e = 0, t = zm.children.length; e < t; e++) {
                zm.children[e].scale.set(2, 2, 1)
            }
            zm.rotation.y += .05 * e
        }

        function ng() {
            requestAnimationFrame(ng), tg(Bm.getDelta()), Hm.clear(), Hm.render(Um, Vm)
        }
        async function ig(e) {
            let t = new Od;
            return new Promise(((n, i) => t.load(e, (function (e) {
                e.anisotropy = Hm.capabilities.getMaxAnisotropy(), n(e)
            }), null, i)))
        }

        function rg(e) {
            r()(e).each((function () {
                var e = r()(this).html().replace("<strong>", " -- ").replace("</strong>", " -- ").replace("<br>", " |").split(" "),
                    t = "",
                    n = 0;
                r()(this).html(" ");
                for (var i = 0; i < e.length; i++) "--" == e[i] && (t = 0 == n ? "bold" : "", n++), "|" == e[i] ? r()(this).append('<div class="words w-block"><span></span></div>') : "" != e[i] && " " != e[i] && "|" != e[i] && "--" != e[i] && r()(this).append('<div class="words ' + t + '"><span>' + e[i] + "</span></div>")
            }))
        }

        function og(e) {
            r()(e).find(".words").each((function (e, t) {
                r()(t).removeClass("motion-in")
            }))
        }

        function ag(e) {
            r()(e).find(".words").each((function (e, t) {
                r()(t).addClass("motion-in")
            }))
        }
        var sg = r()(".pages"),
            lg = r()(".header"),
            cg = r()(".scrolldown"),
            ug = r()(".home-bullets"),
            hg = null,
            dg = window.innerHeight,
            pg = 0,
            fg = [];

        function mg() {
            var e, t;
            sg.find(".infos").height(window.innerHeight), sg.find(".circle").css({
                width: window.innerHeight / 1.8,
                height: window.innerHeight / 1.8
            }), rg(sg.find(".title")), e = sg.find(".hc-slides"), t = sg.find(".hc-clients"), fg = [], hg = new f.Controller({
                globalSceneOptions: {
                    triggerHook: 0,
                    reverse: !0
                }
            }), e.find(".infos").each((function (t) {
                var n = this,
                    i = t,
                    o = r()(this).data("color"),
                    a = new f.Scene({
                        triggerElement: this,
                        duration: "100%"
                    }).setPin(this).on("enter", (function (t) {
                        e.find(".home-bckg").css({
                            background: o
                        }), 0 == i ? Ki.to(r()(".globe").find(".g-wrapper"), .4, {
                            ease: Un.easeOut,
                            opacity: 1,
                            y: "0%"
                        }, 0) : Ki.to(e.find(".images").find(".img").eq(i), .5, {
                            ease: Un.easeOut,
                            opacity: 1
                        }, 0), ug.find(".button").removeClass("active"), ug.find(".button").eq(i).addClass("active"), ag(r()(n)), r()(n).find(".paragraph").addClass("motion-in"), r()(n).find(".button").addClass("motion-in"), pg = i
                    })).on("leave", (function (t) {
                        "FORWARD" == t.scrollDirection && (0 == i ? Ki.to(r()(".globe").find(".g-wrapper"), .4, {
                            ease: Un.easeOut,
                            opacity: 0,
                            y: "-10%"
                        }, 0) : Ki.to(e.find(".images").find(".img").eq(i), .5, {
                            ease: Un.easeOut,
                            opacity: 0
                        }, 0)), og(r()(n)), r()(n).find(".paragraph").removeClass("motion-in"), r()(n).find(".button").removeClass("motion-in")
                    })).addTo(hg),
                    s = (new on).add([Ki.to(sg.find(".shape-image").eq(i), 2, {
                        opacity: 1
                    }, 0)]);
                new f.Scene({
                    triggerElement: this,
                    duration: "100%",
                    offset: -dg
                }).setTween(s).addTo(hg);
                var l = (new on).add([Ki.fromTo(e.find(".images").find(".img").eq(i).find("img"), 2, {
                    x: "-20%",
                    opacity: 0
                }, {
                    x: "0%",
                    opacity: 1
                }, 0)]);
                new f.Scene({
                    triggerElement: this,
                    duration: "100%",
                    offset: -dg / 2
                }).setTween(l).addTo(hg), fg.push(a.scrollOffset() + (a.duration() - 10))
            })), t.find(".infos").each((function (e) {
                var t = this,
                    n = new f.Scene({
                        triggerElement: this,
                        duration: "100%"
                    }).setPin(this).on("enter", (function (e) {
                        lg.removeClass("h-white").addClass("check-footer"), cg.removeClass("s-white").removeClass("hide"), ug.find(".button").removeClass("active"), ug.find(".button").eq(4).addClass("active"), ug.addClass("hb-dark"), ag(r()(t)), Ki.to(ug, 1, {
                            ease: Un.easeOut,
                            x: "0%"
                        }, 0), r()(t).find(".image").each((function (e, t) {
                            Ki.to(r()(t), 1, {
                                ease: Un.easeOut,
                                opacity: 1
                            }, 0)
                        })), pg = 4
                    })).on("leave", (function (e) {
                        ug.removeClass("hb-dark"), "REVERSE" == e.scrollDirection && (cg.addClass("s-white").removeClass("hide"), lg.addClass("h-white").removeClass("check-footer")), "FORWARD" == e.scrollDirection && (Ki.to(ug, 1, {
                            ease: Un.easeOut,
                            x: "-200px"
                        }, 0), cg.addClass("hide")), r()(t).find(".image").each((function () {
                            Ki.to(r()(this), 1, {
                                ease: Un.easeOut,
                                opacity: 0
                            }, 0)
                        })), og(r()(t))
                    })).addTo(hg);
                fg.push(n.scrollOffset() + (n.duration() - 10))
            })), hg.scrollTo((function (e) {
                Ki.to(window, 2, {
                    scrollTo: {
                        y: e,
                        ease: Un.easeOut
                    }
                })
            })), ug.find(".button").on("click", (function () {
                var e = parseInt(r()(this).data("target").split("slide-")[1]);
                hg.scrollTo(fg[e - 1])
            })), cg.on("click", (function () {
                4 == pg ? hg.scrollTo(r()(document).height()) : hg.scrollTo(fg[pg + 1])
            })), eg(), gg()
        }

        function gg() {
            sg.find(".infos").height(window.innerHeight), r()(window).width() > 500 && sg.find(".circle").css({
                width: window.innerHeight / 1.8,
                height: window.innerHeight / 1.8
            }), jm = r()(window).width(), Gm = r()(window).height(), Hm.setSize(jm, Gm), console.log(jm), null != Vm && (Vm.aspect = jm / Gm, Vm.updateProjectionMatrix()), hg.update(!0)
        }
        var vg, yg = (vg = navigator.userAgent || navigator.vendor || window.opera, /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(vg) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(vg.substr(0, 4)));

        function xg(e) {
            var t = e;
            yg || (t.on("mouseenter", (function () {
                t.on("mousemove", (function (e) {
                    var t, n, i, o, a, s, l, c;
                    n = this, i = (t = e).pageX - r()(n).offset().left, o = t.pageY - r()(n).offset().top, a = i / r()(n).width(), s = o / r()(n).height(), l = 30 * a - 20, c = 20 - 30 * s, er.killTweensOf(r()(n)), er.to(r()(n), 1, {
                        rotationY: l,
                        rotationX: c,
                        rotationZ: 0,
                        transformPerspective: 1e3,
                        ease: jn.easeOut
                    })
                }))
            })), t.on("mouseleave", (function () {
                var e;
                e = this, r()(e).off("mousemove"), er.killTweensOf(r()(e)), er.to(r()(e), .5, {
                    rotationY: 0,
                    rotationX: 0,
                    rotationZ: 0,
                    transformPerspective: 1e3,
                    ease: jn.easeOut
                })
            })))
        }
        var wg = r()(".about-world"),
            bg = wg.find(".item"),
            _g = r()(".highlights"),
            Mg = wg.find(".aw-people").height(),
            Tg = wg.find(".aw-people").width();

        function Sg() {
            bg.each((function (e, t) {
                var n = this;
                setTimeout((function () {
                    Ag(n)
                }), 300 * e)
            })), r()(window).width() >= 860 && xg(_g.find("img"))
        }

        function Eg(e, t) {
            return Math.floor(Math.random() * (t - e + 1)) + e
        }

        function Ag(e) {
            var t = Eg(1, Mg),
                n = Eg(1, Tg);
            r()(e).css("transform", "translate(" + n + "px," + t + "px)"),
                function (e) {
                    var t = r()(e),
                        n = r()(e).find("img");
                    new on({
                        onComplete: function () {
                            er.killTweensOf(n), setTimeout((function () {
                                Ag(t)
                            }), 1e3)
                        }
                    }).add([er.to(n, 5, {
                        scale: 1,
                        ease: "Elastic.easeOut"
                    })]).add([er.to(n, .5, {
                        scale: 0,
                        ease: "Power3.easeOut"
                    })], 20)
                }(e)
        }
        var Cg = r()(".approach"),
            Lg = Cg.find(".item"),
            Pg = r()(".video-background");

        function Rg() {
            var e = r()(this).data("video");
            Lg.addClass("hide"), r()(this).removeClass("hide"), er.killTweensOf(r()(".title.t-center")), er.killTweensOf(r()(".header")), er.killTweensOf(r()(".submenu")), (new on).add([er.to(r()(".title.t-center"), .5, {
                ease: Un.easeOut,
                opacity: 0
            }), er.to(r()(".header"), .1, {
                ease: Un.easeOut,
                opacity: 0
            }, 0), er.to(r()(".submenu"), .2, {
                ease: Vn.easeOut,
                opacity: 0
            }, 0)]), Pg.find(".video").removeClass("active"), Pg.find('[data-target="' + e + '"]').addClass("active")
        }

        function Og() {
            Lg.removeClass("hide"), Pg.find(".video").removeClass("active"), er.killTweensOf(r()(".title.t-center")), er.killTweensOf(r()(".header")), er.killTweensOf(r()(".submenu")), (new on).add([er.to(r()(".title.t-center"), .5, {
                ease: Un.easeOut,
                opacity: 1
            }), er.to(r()(".header"), .1, {
                ease: Un.easeOut,
                opacity: 1
            }, 0), er.to(r()(".submenu"), .2, {
                ease: Vn.easeOut,
                opacity: 1
            }, 0)])
        }
        r()(".webdoor");
        var Dg = r()(".people"),
            kg = r()(".people-scramble"),
            Ng = kg.find(".item"),
            Ig = document.querySelector(".name"),
            zg = document.querySelector(".area"),
            Fg = null,
            Hg = null,
            Bg = null,
            Ug = null,
            jg = [
                [0, 12.5, 12.5, 0],
                [12.5, 25, 25, 12.5],
                [25, 37.5, 37.5, 25],
                [37.5, 50, 50, 37.5],
                [50, 62.5, 62.5, 50],
                [62.5, 75, 75, 62.5],
                [75, 87.5, 87.5, 75],
                [87.5, 100, 100, 87.5]
            ];

        function Gg() {
            var e = r()(this).data("target");
            Bg = r()(this).data("name"), Ug = r()(this).data("area"), Ng.each((function (t, n) {
                var i = kg.find(".wrapper").find("figure").eq(t);
                er.killTweensOf(i), t == e ? er.to(i, 1, {
                    ease: Un.easeOut,
                    "clip-path": "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)"
                }) : t < e ? er.to(i, 1, {
                    ease: Un.easeOut,
                    "clip-path": "polygon(0% 0%, 0% 0%, 0% 100%, 0% 100%)"
                }) : er.to(i, 1, {
                    ease: Un.easeOut,
                    "clip-path": "polygon(100% 0%, 100% 0%, 100% 100%, 100% 100%)"
                })
            })), Fg.setText(Bg), Hg.setText(Ug)
        }

        function Vg() {
            var e = r()(this);
            Ng.each((function (t, n) {
                var i = r()(this).data("target"),
                    o = e.closest(".wrapper").find("figure").eq(i);
                er.killTweensOf(o), er.to(o, 3, {
                    ease: Gn.easeOut,
                    "clip-path": "polygon(" + jg[t][0] + "% 0%, " + jg[t][1] + "% 0%, " + jg[t][2] + "% 100%, " + jg[t][3] + "% 100%)"
                })
            }))
        }
        class Wg {
            constructor(e) {
                this.el = e, this.chars = "abcdefghijlkmnopqrstuvxz", this.update = this.update.bind(this)
            }
            setText(e) {
                const t = this.el.innerText,
                    n = Math.max(t.length, e.length),
                    i = new Promise((e => this.resolve = e));
                this.queue = [];
                for (let i = 0; i < n; i++) {
                    const n = t[i] || "",
                        r = e[i] || "",
                        o = Math.floor(40 * Math.random()),
                        a = o + Math.floor(40 * Math.random());
                    this.queue.push({
                        from: n,
                        to: r,
                        start: o,
                        end: a
                    })
                }
                return cancelAnimationFrame(this.frameRequest), this.frame = 0, this.update(), i
            }
            update() {
                let e = "",
                    t = 0;
                for (let n = 0, i = this.queue.length; n < i; n++) {
                    let {
                        from: i,
                        to: r,
                        start: o,
                        end: a,
                        char: s
                    } = this.queue[n];
                    this.frame >= a ? (t++, e += r) : this.frame >= o ? ((!s || Math.random() < .28) && (s = this.randomChar(), this.queue[n].char = s), e += `<span class="dud">${s}</span>`) : e += i
                }
                this.el.innerHTML = e, t === this.queue.length ? this.resolve() : (this.frameRequest = requestAnimationFrame(this.update), this.frame++)
            }
            randomChar() {
                return this.chars[Math.floor(Math.random() * this.chars.length)]
            }
        }
        var qg = r()(".works-list");
        Ki.registerPlugin(nr.ScrollToPlugin);
        var $g = r()(".contact").find(".input"),
            Xg = r()(".scrolldown");

        function Yg() {
            var e;
            e = $g, r()(e).on("focusout", (function () {
                "" == r()(this).find("input").val() && r()(this).removeClass("add-focus"), "" == r()(this).find("textarea").val() && r()(this).removeClass("add-focus")
            })), r()(e).on("focusin", (function () {
                r()(this).addClass("add-focus")
            })), Xg.on("click", (function () {
                r()(this).addClass("hide"), Ki.to(window, .5, {
                    scrollTo: {
                        y: r()(window).height(),
                        ease: Un.easeOut
                    }
                })
            }))
        }
        var Zg = r()(".pages"),
            Jg = r()(".header"),
            Qg = r()(".scrolldown"),
            Kg = r()(".services-bullets"),
            ev = r()(".services-icons"),
            tv = r()(".highlights"),
            nv = null,
            iv = (window.innerHeight, 0),
            rv = [];

        function ov() {
            var e;
            Zg.find(".infos").height(window.innerHeight), rg(Zg.find(".sc-slides").find(".title")), xg(tv.find("img")), e = Zg.find(".sc-slides"), rv = [], nv = null, nv = new f.Controller({
                globalSceneOptions: {
                    triggerHook: 0,
                    reverse: !0
                }
            }), e.find(".infos").each((function (t) {
                var n = this,
                    i = t,
                    o = r()(this).data("color"),
                    a = new f.Scene({
                        triggerElement: this,
                        duration: "100%"
                    }).setPin(this).on("enter", (function (t) {
                        e.find(".services-bckg").css({
                            background: o
                        }), Kg.find(".button").removeClass("active"), Kg.find(".button").eq(i).addClass("active"), Jg.addClass("check-header"), Ki.to(Kg, 1, {
                            ease: Un.easeOut,
                            x: "0%"
                        }, 0), iv = i, 0 == i && (Jg.removeClass("h-white"), Qg.removeClass("s-white"), Kg.addClass("sb-dark"), ag(r()(n)), r()(n).find(".submenu").addClass("motion-in"), setTimeout((function () {
                            r()(n).find(".ico").addClass("motion-in"), r()(n).find("span").addClass("motion-in")
                        }), 1e3)), i >= 1 && (Jg.addClass("h-white"), Qg.addClass("s-white").removeClass("hide"), Kg.removeClass("sb-dark"), r()(n).find(".type").addClass("motion-in"), r()(n).find(".paragraph").addClass("motion-in"), r()(n).find(".button").addClass("motion-in"), r()(n).find(".ico").addClass("motion-in"), r()(n).find(".list").addClass("motion-in"))
                    })).on("leave", (function (e) {
                        3 == i && ("REVERSE" == e.scrollDirection && Qg.removeClass("hide"), "FORWARD" == e.scrollDirection && (Ki.to(Kg, 1, {
                            ease: Un.easeOut,
                            x: "-200px"
                        }, 0), Qg.addClass("hide"), Jg.addClass("h-white").removeClass("check-header"))), 0 == i && (og(r()(n)), r()(n).find(".ico").removeClass("motion-in"), r()(n).find(".submenu").removeClass("motion-in"), r()(n).find("span").removeClass("motion-in")), i >= 1 && (r()(n).find(".type").removeClass("motion-in"), r()(n).find(".paragraph").removeClass("motion-in"), r()(n).find(".button").removeClass("motion-in"), r()(n).find(".ico").removeClass("motion-in"), r()(n).find(".list").removeClass("motion-in"))
                    })).addTo(nv);
                rv.push(a.scrollOffset() + (a.duration() - 10))
            })), nv.scrollTo((function (e) {
                Ki.to(window, 1.5, {
                    scrollTo: {
                        y: e,
                        ease: Un.easeOut
                    }
                })
            })), Kg.find(".button").on("click", (function () {
                var e = parseInt(r()(this).data("target").split("slide-")[1]);
                nv.scrollTo(rv[e - 1])
            })), ev.find(".item").on("click", (function () {
                var e = parseInt(r()(this).data("target").split("slide-")[1]);
                nv.scrollTo(rv[e - 1])
            })), Qg.on("click", (function () {
                3 == iv ? nv.scrollTo(rv[3] + r()(window).height() + 10) : nv.scrollTo(rv[iv + 1])
            })), av()
        }

        function av() {
            Zg.find(".infos").height(window.innerHeight), nv.update(!0)
        }
        var sv = r()(".pages"),
            lv = r()(".header"),
            cv = r()(".scrolldown"),
            uv = r()(".works-list"),
            hv = null,
            dv = 0,
            pv = [];

        function fv() {
            var e;
            sv.find(".sc-slides").find(".infos").height(window.innerHeight), rg(sv.find(".sc-slides").find(".title")), xg(uv.find(".item").find(".wrapper")), e = sv.find(".sc-slides"), pv = [], hv = null, hv = new f.Controller({
                globalSceneOptions: {
                    triggerHook: 0,
                    reverse: !0
                }
            }), e.find(".infos").each((function (t) {
                var n = this,
                    i = t,
                    o = r()(this).data("color"),
                    a = new f.Scene({
                        triggerElement: this,
                        duration: "100%"
                    }).setPin(this).on("enter", (function (t) {
                        e.find(".services-bckg").css({
                            background: o
                        }), lv.addClass("h-white").addClass("check-header"), dv = i, 0 == i && (ag(r()(n)), r()(n).find(".caption").addClass("motion-in"), r()(n).find(".submenu").addClass("motion-in"), setTimeout((function () {
                            r()(n).find(".paragraph").addClass("motion-in"), r()(n).find(".button").addClass("motion-in"), r()(n).find(".image-services").addClass("motion-in")
                        }), 1e3)), 1 == i && (r()(n).find(".caption").addClass("motion-in"), r()(n).find(".subtitle").addClass("motion-in"), r()(n).find(".paragraph").addClass("motion-in"), r()(n).find(".button").addClass("motion-in")), 2 == i && (cv.removeClass("hide"), r()(n).find(".services-items").addClass("motion-in"))
                    })).on("leave", (function (e) {
                        0 == i && (og(r()(n)), r()(n).find(".submenu").removeClass("motion-in"), r()(n).find(".paragraph").removeClass("motion-in"), r()(n).find(".button").removeClass("motion-in"), r()(n).find(".caption").removeClass("motion-in"), r()(n).find(".image-services").removeClass("motion-in")), 1 == i && (r()(n).find(".caption").removeClass("motion-in"), r()(n).find(".subtitle").removeClass("motion-in"), r()(n).find(".paragraph").removeClass("motion-in"), r()(n).find(".button").removeClass("motion-in")), 2 == i && ("FORWARD" == e.scrollDirection && cv.addClass("hide"), r()(n).find(".services-items").removeClass("motion-in"))
                    })).addTo(hv);
                pv.push(a.scrollOffset() + (a.duration() - 10))
            })), hv.scrollTo((function (e) {
                Ki.to(window, 1.5, {
                    scrollTo: {
                        y: e,
                        ease: Un.easeOut
                    }
                })
            })), cv.on("click", (function () {
                2 == dv ? hv.scrollTo(pv[2] + r()(window).height() + 10) : hv.scrollTo(pv[dv + 1])
            })), mv()
        }

        function mv() {
            sv.find(".sc-slides").find(".infos").height(window.innerHeight), hv.update(!0)
        }
        Ki.config({
            nullTargetWarn: !1
        });
        var gv = r()(".button");
        gv.length && gv.each((function () {
            var e;
            e = this, r()(e).each((function () {
                var e = r()(this).find(".wrapper"),
                    t = !1,
                    n = e.attr("offset-hover-max") || .7,
                    i = e.attr("offset-hover-min") || .5;

                function o(t, n) {
                    Ki.to(e, 1.5, {
                        x: .2 * t,
                        y: .2 * n,
                        rotation: .05 * t,
                        ease: Bn.easeOut
                    }, 0)
                }

                function a() {
                    Ki.to(e, 1.5, {
                        x: 0,
                        y: 0,
                        rotation: 0,
                        ease: Gn.easeOut
                    }, 0)
                }
                r()(window).on("mousemove", (function (s) {
                    var l = t ? n : i,
                        c = {
                            x: s.clientX,
                            y: s.clientY
                        },
                        u = e.outerWidth(),
                        h = e.outerHeight(),
                        d = e.offset(),
                        p = {
                            x: d.left + u / 2,
                            y: d.top - r()(window).scrollTop() + h / 2
                        },
                        f = c.x - p.x,
                        m = c.y - p.y,
                        g = !1;
                    Math.sqrt(f * f + m * m) < u * l && (g = !0, t || (t = !0), o(f, m)), !g && t && (a(), t = !1)
                }))
            }))
        }));
        var vv = r()(".footer"),
            yv = vv.find(".scrollup"),
            xv = null,
            wv = null;

        function bv() {
            wv = window.innerHeight, xv = r()(document).height(), vv.css({
                height: window.innerHeight
            })
        }

        function _v() {
            wv = window.innerHeight, xv = r()(document).height();
            var e = r()(window).scrollTop();
            e + wv >= xv - wv / 2 ? vv.addClass("motion-in-1") : vv.removeClass("motion-in-1"), e + wv >= xv - wv / 3 ? vv.addClass("motion-in-2") : vv.removeClass("motion-in-2"), e + wv >= xv ? vv.addClass("motion-in-3") : vv.removeClass("motion-in-3")
        }
        vv.length && (vv.css({
            height: wv
        }), yv.find(".button").on("click", (function () {
            Ki.to(window, 1, {
                scrollTo: {
                    y: 0,
                    ease: "Power3.easeOut"
                }
            })
        })), wv = window.innerHeight, xv = r()(document).height(), r()(window).on("scroll.footer", _v), r()(window).on("resize", bv), _v(), bv());
        var Mv = r()(".header"),
            Tv = r()(".menu"),
            Sv = Mv.find(".hmbrg"),
            Ev = r()("main").data("page"),
            Av = r()(".header").find(".logo").height() + (r()(".header").height() - r()(".header").find(".logo").height()) / 2;

        function Cv() {
            var e = r()(document).height(),
                t = window.innerHeight,
                n = r()(window).scrollTop();
            switch (Ev) {
                case "home":
                    n + t >= e - Av ? Mv.addClass("h-white") : Mv.hasClass("check-footer") && Mv.removeClass("h-white");
                    break;
                case "about-approach":
                    n + t >= e - Av ? Mv.removeClass("h-white") : Mv.addClass("h-white");
                    break;
                case "journal-inner":
                    n >= .8 * t - Av ? n + t >= e - Av ? Mv.addClass("h-white") : Mv.removeClass("h-white") : Mv.addClass("h-white");
                    break;
                case "contact":
                    Mv.addClass("h-white");
                    break;
                case "services":
                    n >= r()(".sc-clients").offset().top - Av ? n + t >= e - Av ? (Mv.addClass("h-white"), console.log("footer")) : (Mv.removeClass("h-white"), console.log("crientes")) : Mv.hasClass("check-header") || Mv.addClass("h-white");
                    break;
                case "service":
                    n >= r()(".sc-testimonials").offset().top - Av ? n + t >= e - Av ? Mv.addClass("h-white") : Mv.removeClass("h-white") : Mv.addClass("h-white");
                    break;
                default:
                    n + t >= e - Av ? Mv.addClass("h-white") : Mv.removeClass("h-white")
            }
        }
        Mv.length && (Mv.find(".menu").css({
            height: window.innerHeight
        }), Sv.on("click", (function () {
            r()(this).hasClass("active") ? (Mv.removeClass("show-menu"), Tv.removeClass("show-menu"), Sv.removeClass("active")) : (Mv.addClass("show-menu"), Tv.addClass("show-menu"), Sv.addClass("active"))
        })), r()(window).on("scroll.header", Cv), r()(window).on("resize", (function () {
            Mv.find(".menu").css({
                height: window.innerHeight
            })
        })), Cv());
        n(3);
        var Lv = r()(".testimonial:not(.no-slick)");
        Lv.length && (Lv.find(".slides").slick({
            infinite: !0,
            lazyLoad: "ondemand",
            slidesToShow: 3,
            slidesToScroll: 1,
            arrows: !1,
            dots: !0,
            centerMode: !0,
            variableWidth: !0,
            responsive: [{
                breakpoint: 768,
                settings: {
                    arrows: !1,
                    centerMode: !0,
                    slidesToShow: 1
                }
            }]
        }), Lv.find(".t-prev").on("click", (function () {
            Lv.find(".slides").slick("slickPrev")
        })), Lv.find(".t-next").on("click", (function () {
            Lv.find(".slides").slick("slickNext")
        })));
        var Pv = r()(".services-items");
        Pv.length && (Pv.slick({
            infinite: !1,
            slidesToShow: 1,
            slidesToScroll: 1,
            arrows: !1,
            variableWidth: !0,
            responsive: [{
                breakpoint: 768,
                settings: {
                    arrows: !1
                }
            }]
        }), Pv.find(".t-prev").on("click", (function () {
            Pv.find(".slides").slick("slickPrev")
        })), Pv.find(".t-next").on("click", (function () {
            Pv.find(".slides").slick("slickNext")
        })));
        const Rv = r()("main").data("page");
        ! function () {
            for (var e = 0; e < 800; e += 50) setTimeout((function () {
                r()(window).scrollTop(0)
            }), e);
            o.css({
                display: "flex"
            }), setTimeout((function () {
                o.addClass("motion-in"),
                    function (e) {
                        var t, n = e.before || function () { },
                            i = e.progress || function () { },
                            o = e.complete || function () { },
                            a = e.testDelay || 0,
                            s = r()(e.elem || "body"),
                            l = [],
                            c = [];
                        if (s.find("*").add(s).each((function () {
                            var e, t = r()(this),
                                n = t.css("background-image"),
                                i = (/(^url\([\'\"]?)([^\"\']*)([\'\"]?\))/.exec(n) || [])[2];
                            t.is("img") ? e = t.attr("src") : i && (e = i), e && l.indexOf(e) < 0 && (l.push(e), c.push({
                                src: e,
                                progress: 0
                            }))
                        })), !l.length) return o(l);

                        function u() {
                            var e = 0,
                                n = c.length;
                            c.forEach((function (t) {
                                e += t.progress
                            }));
                            var r = 100 * e / n;
                            i(r), r >= 100 && !t && (t = !0, o(l))
                        }
                        n(), c.forEach((function (e, t) {
                            setTimeout((function () {
                                var t = new XMLHttpRequest;
                                t.onprogress = function (t) {
                                    e.progress = t.loaded / t.total, u()
                                }, t.onloadend = t.ontimeout = t.onerror = t.onabort = function (t) {
                                    e.progress = 1, u()
                                }, t.open("GET", e.src, !0), t.send(null)
                            }), a * (t + 1))
                        }))
                    }({
                        elem: r()("body"),
                        testDelay: 400,
                        progress: function (e) {
                            "about-person" != d && a(parseInt(e))
                        },
                        complete: function () {
                            "contact" == d || "about-approach" == d || "about-person" == d || "legals" == d ? (setTimeout((function () {
                                a(0), setTimeout((function () {
                                    a(20), setTimeout((function () {
                                        a(40), setTimeout((function () {
                                            a(60), setTimeout((function () {
                                                a(80), setTimeout((function () {
                                                    a(100)
                                                }), 100)
                                            }), 100)
                                        }), 100)
                                    }), 100)
                                }), 100)
                            }), 50), setTimeout((function () {
                                p()
                            }), 800)) : p()
                        }
                    })
            }), 500)
        }(), r()((function () {
            switch (console.log("INIT"), Rv) {
                case "home":
                    mg();
                    break;
                case "about":
                    Sg();
                    break;
                case "about-approach":
                    r()(window).width() >= 860 && (xg(Cg.find(".item").find(".wrapper")), Lg.on("mouseenter", Rg), Lg.on("mouseleave", Og), r()("video")[0].play(), r()("video")[1].play(), r()("video")[2].play());
                    break;
                case "about-team":
                    r()(window).width() >= 860 && (Fg = new Wg(Ig), Hg = new Wg(zg), xg(Dg.find(".item").find(".i-wrapper")), Ng.on("mouseenter", Gg), Ng.on("mouseleave", Vg), kg.on("mouseleave", (function () {
                        Fg.setText("the people"), Hg.setText("magic")
                    })));
                    break;
                case "works":
                    r()(window).width() >= 860 && xg(qg.find(".item").find(".wrapper"));
                    break;
                case "contact":
                    Yg();
                    break;
                case "services":
                    ov();
                    break;
                case "service":
                    fv()
            }
            r()(window).on("resize", (function () {
                switch (Rv) {
                    case "home":
                        gg();
                        break;
                    case "services":
                        av();
                        break;
                    case "service":
                        mv()
                }
                console.log("resize")
            }))
        }));
        n(5)
    }]).default
}));
//# sourceMappingURL=main.js.map